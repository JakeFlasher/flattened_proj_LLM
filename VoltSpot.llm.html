<documents>
<document index="1">
<source>3D_examples/3layer.lcf</source>
<document_content>
#Lines starting with # are used for commenting
#Blank lines are also ignored
#File Format:
#<Layer Number> start from 0
# flp file
# number of metal layers
# metal layer spec file
# TSV location spec file
0
./A.flp
./example.mlcf
./example.tsvloc
1
./B.flp
./example.mlcf
./example.tsvloc
2
./C.flp
./example.mlcf
./example.tsvloc
</document_content>
</document>
<document index="2">
<source>3D_examples/3layer.ptrace</source>
<document_content>
A       B       C
1       1       1
</document_content>
</document>
<document index="3">
<source>3D_examples/A.flp</source>
<document_content>
A 0.002031 0.002708 0 0
</document_content>
</document>
<document index="4">
<source>3D_examples/B.flp</source>
<document_content>
B 0.002031 0.002708 0 0
</document_content>
</document>
<document index="5">
<source>3D_examples/C.flp</source>
<document_content>
C 0.002031 0.002708 0 0
</document_content>
</document>
<document index="6">
<source>3D_examples/example.ivrloc</source>
<document_content>
4	4
4	9
4	15
4	20
9	4
9	9
9	15
9	20
14	4
14	9
14	15
14	20
</document_content>
</document>
<document index="7">
<source>3D_examples/example.mlcf</source>
<document_content>
#Lines starting with # are used for commenting
#Blank lines are also ignored
#File Format:
#<Layer Number> start from 0
#<metal pitch     in m>
#<metal width     in m>
#<metal thickness in m>
#<metal Resistivity>
#<Direction 0/1 (x/y or h/v)>
#Example
#0
#30e-6
#10e-6
#3.5e-6
#1.68e-8 
#0
0
30e-6
10e-6
3.5e-6
1.68e-8 
0
1
30e-6
10e-6
3.5e-6
1.68e-8 
1
2
810e-9
400e-9
720e-9
1.68e-8 
0
3
810e-9
400e-9
720e-9
1.68e-8 
1
</document_content>
</document>
<document index="8">
<source>3D_examples/example.tsvloc</source>
<document_content>
V	0	0
G	1	0
V	3	0
G	4	0
... ... ...
G	16	23
V	17	23
</document_content>
</document>
<document index="9">
<source>HOWTO</source>
<document_content>
 
QUICK USAGE GUIDE FOR VOLTSPOT
-------------------------------
1. Steady-state IR drop simulation:
VoltSpot is a trace-level simulator that takes a power trace file and a 
floorplan file as inputs, and calculate corresponding voltage/current 
for all nodes/branches in the PDN. It is capable of simulating both
the static PDN noise (IR drop only) and the transient voltage fluctuations
(the combination of IR drop, Ldi/dt and LC resonance).
First, let us run the simulation with a set of default model parameters 
listed in the file 'pdn.config', and gather the steady state IR drop onto a file. 
This can be done by:
>> voltspot -c pdn.config -f example.flp -p example.ptrace -run_PDN 1 \
            -gridvol_file steady.gridIR
Here, 'example.flp' describes the floorplan of an Intel-Penryn-based 2-core 
processor and 'example.ptrace' gives the per-cycle power trace of this 
processor for a time period of 2k cycles (running the application dedup from
PARSEC 2.0 benchmark suite). Notice that in steady-state simulations, 
VoltSpot will pre-process the power trace file and use the average power 
consumption to calculate static IR drop. After simulation, VoltSpot will 
print results overview (e.g. chip dimension, sum of chip current consumption, 
max on-chip IR drop, etc.) to stdout. More detailed results will be dumped 
into 'steady.gridIR', which records the IR drop (in terms of percentage Vdd,
combines both voltage drop in vdd net and ground bounce in gnd net) for 
all on-chip nodes. User can plot the on-chip IR drop as a 'heat map' using
the script provided. This is done by:
>> ./plot_onchipIR.pl steady.gridIR
This command should generate figure file 'steady.gif'.
Note that GNU plot is required to run plot_onchipIR.pl.
2. Transient voltage noise simulation:
The command to simulate transient PDN behavior is the following:
>> voltspot -c pdn.config -f example.flp -p example.ptrace -v trans.vtrace
With the option -v specified, VoltSpot will perform transient simulation
and dump results into the designated file (trans.vtrace in this example).
By default, the .vtrace file contains two parts: simulation configurations
and results statistics. The beginning of the .vtrace file lists all the
configuration parameters used during the simulation. The end of 
the configuration listings is marked by line 'END_OF_CONFIGS'.
The rest of the .vtrace file records the per-cycle statistics of the simulation
results. The two columns show the voltage drop at the package node (pkgDrop)
and the maximum on-chip voltage drop (max_drop). All the voltage drop values 
are converted to percentage Vdd.
DETAILED GUIDELINES
------------------------
1. On-chip PDN: physical metal stack and virtual grid.
Power delivery network in modern silicon chips usually consists multiple on-chip
layers of parallel metal wires. VoltSpot is capable of modeling this multi-layer
stack structure in detail. With configuration parameter -mlayer_spec_file,
user can specify the physical structure of metal stack by providing the pitch, 
width, thickness and resistivity of each metal layer.
Here is an example:
>> voltspot -c pdn.config -f example.flp -p example.ptrace \
            -v trans.vtrace -mlayer_spec_file example.mlcf 
In this example, example.mlcf describes four metal layers.
If user do not provide .mlcf file, VoltSpot will use default values 
that assumes four metal layers (see function populate_default_mlayers 
in PDN_sim.c ).
VoltSpot uses a virtual grid to model on-chip PDN stack. The virtual grid
has a regular mesh structure where each branch consists of single or 
multiple resistor-inductor pairs. The size of the virtual grid is related 
to the size of C4 pad array. As an example, assume that the pitch of C4 pads 
is 250um and the chip we want to model is 1cm by 1cm large. The total number 
of C4 pads for this chip is 1600 and they are aligned into a 40x40 array. 
Given the C4 pad array's size, VoltSpot sets virtual grid size to an integer 
multiple of C4 array size (e.g. 40x40, 80x80, 120x120, etc.). This integer 
multiple is configurable through -PDN_grid_intv. Notice that although the 
size of virtual grid is independent of wire count in each physical metal layer,
the resistance and inductance value of virtual grid is calculated based on 
the shape and density of physical metal wires.
With the abstraction of virtual grid, we can increase simulation speed to
study application-level noise behavior. By keeping virtual grid no smaller
than C4 array size, we maintain the precision in modeling individual pads.
User can increase modeling granularity by setting larger value for PDN_grid_intv.
Increasing granularity will improve precision at the cost of simulation speed.
To find out the size of virtual grid, user can run steady state simulation 
and refer to line number 3 in the results printed to stdout.
2. C4 Pads
Since C4 pads are the only connection between the silicon chip and its 
outside world, both power supply and chip I/O have to utilize them exclusively.
In reality, only a portion of total C4 pads are used for power delivery and
in VoltSpot, user can configure the number and locations of power supply pads
with a pad location description file. Here is an example command that simulates 
steady-state PDN with customized power supply pad distribution:
>> voltspot -c pdn.config -f example.flp -p example.ptrace -run_PDN 1\
            -PDN_padconfig 0 -padloc_file_in example.vgrid.padloc 
First of all, setting parameter PDN_padconfig to 0 tells VoltSpot to load power 
pad configuration from file, otherwise VoltSpot will allocate P/G pads to all 
available pad seats. The format of .padloc file is the following:
<Pad_type(V/G)>\t<pad_x_location>\t<pad_y_location>
User can choose to describe pads' location with either virtual-grid coordinate
or pad-grid coordinate. Parameter padloc_format switches between different 
coordinate system for pad location parsing and dumping. The advantage of using 
pad-grid's coordinate is that one .padloc file works for any modeling granularity
(different PDN_grid_intv values). In both coordinate systems, (0,0) refers to 
bottom-left corner. User can plot pad location with dot graph using the script provided.
This is done by:
>> ./plot_padloc.pl example.vgrid.padloc
Vdd pads and ground pads will be plotted separately ('example.vddloc.pdf' and 
'example.gndloc.pdf'). Note that GNU plot is required to run plot_padloc.pl.
3. PDN status analysis and dump.
Besides steady-state simulation's output to stdout and transient simulation's
output file (.vtrace), VoltSpot provides several other options to gather and
dump PDN noise information.
-gridvol_file
 We've shown that in steady-state simulation, option -gridvol_file dumps
 on-chip IR drop into specified file. In transient simulation, enabling 
 this option will make VoltSpot dump all on-chip nodes' (in vdd net only)
 voltage. For each simulated cycle, VoltSpot will print the 2D on-chip 
 voltage array as a row in the specified file (unraveled in row-major).
 Notice that this file might be very large for long simulations.
-senloc_file
 Instead of printing out all nodes' voltage level, VoltSpot also provides
 users the option to dump per-cycle voltage noise of selected on-chip node(s).
 This is similar to monitoring on-chip voltage noise with on-chip voltage 
 sensors, thus we name the related parameter as -senloc_file (sensor location file). 
 Here is an example command:
 >> voltspot -c pdn.config -f example.flp -p example.ptrace \
             -v trans.vtrace -senloc_file example.senloc
 Each line in example.senloc describes the location of a voltage sensor
 (in virtual-grid's coordinate system). During transient simulation, 
 VoltSpot prints all sensors' voltage noise into vtrace file (specified by -v).
 The values were converted to percentage Vdd and they include both supply 
 net voltage drop and ground net bounce.
-padcur_file
 In steady-sate, -padcur_file dumps all power supply C4 pad's current
 density into specified file with the following format:
 <Pad_type(V/G)>\t<pad_x_location>\t<pad_y_location>\t<current_density>
 Here, V represents vdd pad and G represents ground pad. All current
 density values are in A/m^2. User can switch between output coordinate 
 systems with parameter -padloc_format. For now, we do not have functions 
 to dump transient pad current.
-vio_file
 Besides simply printing voltage or current values out, VoltSpot could
 also perform basic analysis on PDN noise on per-node or per-block bases.
 This can be done through providing two extra parameters. Here is an example:
 >> voltspot -c pdn.config -f example.flp -p example.ptrace \
             -v trans.vtrace -PDN_noise_th 5 -vio_file trans.viomap
 PDN_noise_th sets the threshold for voltage drop tolerance. For example, the
 above command will treat voltage drop larger than 5% Vdd as a violation
 (noise violations will threats execution correctness with timing errors).
 After simulation, VoltSpot will dump per-node and per-block noise stats
 into the file specified by -vio_file. trans.viomap contains two parts.
 The first part gives per-node information (one node per line).
 The format is the following:
   <x_loc>\t<y_loc>\t<vio_count>\t<avg_drop>\t<max_drop>
   x_loc is the node's x location
   y_loc is the node's y location
   vio_count is the number of cycles with noise violations
   avg_drop is the average voltage drop across all of cycles
   max_drop is the maximum voltage drop across all of cycles
 The second part of trans.viomap provides per-block stats (one block per line).
 The format is the following:
   <Block_Name>\t<vio_count>\t<max_drop>
   Block_Name is the name of the block.
   vio_count is the number of cycles that any where within the block experiences
             noise violations.
   max_drop is the maximum voltage drop across all the entire block.
VoltSpot models on-chip PDN with tens of thousands of RLC components.
Instead of dumping per-cycle voltage levels for all nodes and post 
process simulation results, we encourage users to integrate their noise
sensing and analysis modules into VoltSpot to save both processing time
and disk space. PDN_analyze.c includes all current functions for on-line 
noise analysing and PDN stats dumping. We hope it provides a starting 
point and references for integrating your own modules.
4. Power trace sampling interval and solver timestep
For transient simulations, each line in the power trace input file (.ptrace) 
represents the processor's average power consumption over a certain period of time. 
This sampling time period, or sampling interval, is configurable through two parameters:
-proc_clock_freq : processor's clock frequency.
-ptrace_sampling_intvl : sampling interval in terms of clock cycles.
We use an implicit method with fixed timestep to solve the PDN's RLC circuit.
Therefore the length of solver timestep is directly related to both simulation 
speed and result accuracy. In fact, increasing solver's timestep length
reduces simulation time at the cost larger numerical error.
Our test results indicate that with the default settings listed in pdn.config,
a timestep of 50 pico second results in no more than 10e-4 error ratio.
The length of timestep can be specified through parameter -PDN_step_percycle.
To be more specific, timestep = 1/(proc_clock_freq * PDN_step_percycle).
For example, if processor frequency is 2GHz (500 ps clock period), if we want
to make timestep equal to 50ps, we should set PDN_step_percycle to 10.
5. Warming up PDN in transient simulations.
Due to the presence of capacitors and inductors, the status of PDN is dependant
on its initial status. In order to independently exam the noise behavior of a 
particular program trace, the PDN should be 'warmed up' before simulating the 
trace of interest. For each transient simulation, VoltSpot assumes that the 
initial voltages of all nodes in vdd/gnd net are equal to Vdd/0, thus all 
capacitors in the PDN are fully charged before the simulation starts. This way 
we can avoid large rush current toward capacitors during a 'cold start'. However, 
due to the large current step introduced by the first power trace line 
(the initial current consumption assumed to be zero), the beginning of a transient 
simulation might still experience larger voltage fluctuations. To 'skip' this noisy 
period, user can specify warm up period with parameter PDN_ptrace_warmup. 
For example, the following cmd line performs transient simulation and use the 
first 1000 lines in example.ptrace to warm up PDN:
>> voltspot -c pdn.config -f example.flp -p example.ptrace \
            -v trans.vtrace -PDN_ptrace_warmup 1000
Again, the number specified by PDN_ptrace_warmup represent the number of LINES in
ptrace file. During warm up period, VoltSpot does not perform any stats analysis 
or dump any results, but still simulate the PDN' RLC network in detail.
6. 3D-IC and voltage stacking (V-S)
Starting from version 2.0, VoltSpot supports 3D-ICs' PDN modeling. To simulate
a 3D system's PDN noise, users needs to provide the floorplans of all layers
(in separate files), the power maps/traces (in a single file), the information
about all layers' metal/TSV structure, and a layer config file (.lcf) that tells
VoltSpot how to construct the 3D system. The subdirectory ./3D_examples contains
all the necessary files for an example 3D simulation. Here are the example commands
to run:
>> cd ./3D_examples
>> ../voltspot -c ../pdn.config -f A.flp -p 3layer.ptrace -layer_file_3D 3layer.lcf -run_PDN 1 -PDN_padpitch 200e-6
By default, VoltSpot simulates a regular PDN structure with TSVs populated at all
virtual grid nodes. Users can change the TSV configuration by setting -TSV_config to 0
and VoltSpot will load all layers' TSV distributions from the .tsvloc files specified in
the .lcf file. To simulate voltage-stacked PDNs, the -v_stacking parameter should be set to 1,
and the locations of the integrated SC converters can be configured through -IVR_loc_file.
For more information on V-S PDN, please refer to our DAC15 and ISLPED15 papers.
 
</document_content>
</document>
<document index="10">
<source>LICENSE</source>
<document_content>
LICENSE
-------
LICENSE TERMS
Copyright 2015. All rights reserved.
Permission is hereby granted, without written agreement and without license or
royalty fees, to use, copy, modify, and distribute this software and its
documentation for any purpose, provided that the above copyright notice and the
following four paragraphs appear in all copies of this software, whether in
binary form or not.
IN NO EVENT SHALL THE AUTHORS, THE UNIVERSITY OF VIRGINIA, OR THE STATE OF
VIRGINIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
DOCUMENTATION, EVEN IF THEY HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.
THE AUTHORS, THE UNIVERSITY OF VIRGINIA, AND THE STATE OF VIRGINIA SPECIFICALLY
DISCLAIM ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED
HEREUNDER IS ON AN "AS IS" BASIS, AND THE AUTHORS HAVE NO OBLIGATION TO PROVIDE
MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
NEITHER THE NAME OF ANY VIRGINIA ENTITY NOR THE NAMES OF THE CONTRIBUTORS MAY
BE USED TO ENDORSE OR PROMOTE PRODUCTS DERIVED FROM THIS SOFTWARE WITHOUT
SPECIFIC PRIOR WRITTEN PERMISSION.
If you use this software or a modified version of it, we would appreciate it if
you would cite one of the following papers:
1) R. Zhang, K. Wang, B. H. Meyer, M. R. Stan and K. Skadron 
   "Architecture Implications of Pads as a Scarce Resource" In Proceedings of
   the 41th International Symposium on Computer Architecture (ISCA), June 2014
2) R. Zhang, K. Mazumdar, B. Meyer, K. Wang, K. Skadron, and M. R. Stan, 
   "A Cross-Layer Design Exploration of Charge-Recycled Power-Delivery in Many-Layer 3D-IC",
   In Proceedings of the Design Automation Conference (DAC), June, 2015
3) R. Zhang, K. Mazumdar, B. Meyer, K. Wang, K. Skadron, and M. R. Stan, 
   "Transient Voltage Noise in Charge-Recycled Power Delivery Networks for Many-Layer 3D-IC",
   In Proceedings of the International Symposium on Low Power Electronics and Design (ISLPED),
   July, 2015
</document_content>
</document>
<document index="11">
<source>Makefile</source>
<document_content>
# Uncomment the following math acceleration flags 
# relevant to your target and set the appropriate
# path and flag options
#Super LU
SuperLUroot	= $(HOME)/Runjie/Temp/SuperLU_4.3
SUPERLULIB 	= $(SuperLUroot)/lib/libsuperlu_4.3.a
BLASLIB    	= -lblas
SLU_HEADER  = $(SuperLUroot)/SRC
INCDIR		= $(SLU_HEADER)
LIBDIR		= 
LIBS  		= -lm $(SUPERLULIB) $(BLASLIB)
EXTRAFLAGS	= -Wno-unused-result
CC 			= gcc
ifeq ($(DEBUG), 1)
OFLAGS		= -O0 -ggdb -Wall
else
ifeq ($(DEBUG), 2)
OFLAGS		= -O3 -pg -ggdb -Wall
else
OFLAGS		= -O3
endif	# DEBUG = 2
endif	# DEBUG = 1
RM			= rm -f
AR			= ar qcv
RANLIB	= ranlib
OEXT		= o
LEXT		= a
# Verbosity level [0-3]
ifndef VERBOSE
VERBOSE	= 0
endif
ifdef INCDIR
INCDIRFLAG = -I$(INCDIR)
endif
ifdef LIBDIR
LIBDIRFLAG = -L$(LIBDIR)
endif
CFLAGS	= $(OFLAGS) $(EXTRAFLAGS) $(INCDIRFLAG) $(LIBDIRFLAG) -DVERBOSE=$(VERBOSE)
# sources, objects, headers and inputs
# Floorplan
FLPSRC	= flp.c
FLPOBJ	= flp.$(OEXT)
FLPHDR	= flp.h
# PDN model
PDNSRC  = PDN_sim.c PDN_analyze.c pad.c matrix.c
PDNOBJ  = PDN_sim.$(OEXT) PDN_analyze.$(OEXT) pad.$(OEXT) matrix.$(OEXT)
PDNHDR	= PDN_sim.h PDN_analyze.h pad.h
# Miscellaneous
MISCSRC = util.c
MISCOBJ = util.$(OEXT)
MISCHDR = util.h
# all objects
OBJ	= $(PDNOBJ) $(FLPOBJ) $(MISCOBJ)
# targets
all:	voltspot lib
voltspot:	voltspot.$(OEXT) $(OBJ)
	$(CC) $(CFLAGS) -o voltspot voltspot.$(OEXT) $(OBJ) $(LIBS)
ifdef LIBDIR
		@echo
		@echo
		@echo "...Done. Do not forget to include $(LIBDIR) in your LD_LIBRARY_PATH"
endif
lib:	voltspot
	$(RM) libvoltspot.$(LEXT)
	$(AR) libvoltspot.$(LEXT) $(OBJ)
	$(RANLIB) libvoltspot.$(LEXT)
#pull in dependency info for existing .o files
-include $(OBJ:.o=.d)
.c.$(OEXT):
	$(CC) $(CFLAGS) -c $*.c
	$(CC) -MM $(CFLAGS) $*.c > $*.d
filelist:
	@echo $(FLPSRC) $(PDNSRC) $(MISCSRC) \
		  $(FLPHDR) $(PDNHDR) $(MISCHDR) \
		  voltspot.h voltspot.c\
		  Makefile
clean:
	$(RM) *.$(OEXT) *.obj *.d core *~ Makefile.bak voltspot libvoltspot.$(LEXT)
	$(RM) $(OBJ)
cleano:
	$(RM) *.$(OEXT) *.obj
</document_content>
</document>
<document index="12">
<source>PDN_analyze.c</source>
<document_content>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <math.h>
#include <assert.h>
#include "PDN_sim.h"
#include "PDN_analyze.h"
#include "util.h"
#include "pad.h"
static int stat_counter =0;
status_t *alloc_status(model_t *model)
{
  int l, i;
  status_t *status;
  status = (status_t *) calloc(1, sizeof(status_t));
  status->trans_counter = 0;
  status->draw_counter = 0;
  status->maxcur_vdd = 0;
  status->maxcur_gnd = 0;
  status->max_pad_dense = 0;
  status->curIth = 0;
  status->curIth_vdd = 0;
  status->curIth_gnd = 0;
  status->maxdroop = 0;
  status->curIc = 0;
  status->avgIc = 0;
  status->dIc = 0;
  status->curVc = 0;
  status->avgVc = 0;
  status->vio_area_ratio = 0;
  status->pkgDrop = 0;
  status->PDN_power = 0;
  status->sumcur = 0;
  status->prevIc = 0;
  status->prevVc = 1;
  /* for averaging resutls*/
  int m = model->trans_matrix_dim;
  status->cycle_avg  = dvector(m);
  zero_dvector(status->cycle_avg, m);
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int nbr = 2*nr*nc - nr - nc;
  status->maxIR = dvector(nl);
  status->layer_maxdroop = dvector(nl);
	/* tsv current */
  int ntsv = 0;
  for(l=0; l<nl-1; l++){
      ntsv += model->layers[l].tsv.num_gnd;
      ntsv += model->layers[l].tsv.num_vdd;
  }
  status->TSVcur = dvector(ntsv);
  status->maxTSVcur = dvector(nl-1);
	/* sensor location */
  status->sensor_loc = imatrix(nr, nc);
  zero_ivector(status->sensor_loc[0], nr*nc);
  status->sensor_noise = dmatrix(nr, nc);
  zero_dvector(status->sensor_noise[0], nr*nc);
	/* pad current */
  status->vdd_cur = dmatrix(nr, nc);
  status->gnd_cur = dmatrix(nr, nc);
  zero_dvector(status->vdd_cur[0], nr*nc);
  zero_dvector(status->gnd_cur[0], nr*nc);
	/* tsv current */
  /* allocate voltage record */
  status->gridstats.counter_2D  = imatrix(nr, nc);
  status->gridstats.max_2D      = dmatrix(nr, nc);
  status->gridstats.integral_2D = dmatrix(nr, nc);
  status->blkstats.counter_1D   = ivector(model->total_n_blocks);
  status->blkstats.max_1D       = dvector(model->total_n_blocks);
  status->corestats.max_1D      = dvector(MAX_CORE_NUM);
  zero_ivector(status->gridstats.counter_2D[0], nr*nc);
  negL_dvector(status->gridstats.max_2D[0], nr*nc);
  zero_dvector(status->gridstats.integral_2D[0], nr*nc);
  zero_ivector(status->blkstats.counter_1D, model->total_n_blocks);
  negL_dvector(status->blkstats.max_1D, model->total_n_blocks);
  negL_dvector(status->corestats.max_1D, MAX_CORE_NUM);
  /* allocate current record */
  //for trans WP
  if(model->config.vgradient_analyse){
      status->vgradient.max_1D = dvector(9*nbr);
      zero_dvector(status->vgradient.max_1D, 6*nbr);
      for(i = 0; i<3*nbr; i++)
        status->vgradient.max_1D[i] = -1000.0;
      for(i = 3*nbr; i<6*nbr; i++)
        status->vgradient.max_1D[i] = 1000.0;
  }
  //if(model->config.vgradient_analyse){
  //    status->vgradient.max_1D = dvector(2*nbr);
  //    zero_dvector(status->vgradient.max_1D, 2*nbr);
  //}
  return status;
}
void free_status(model_t *model, status_t *status)
{
  free_dvector(status->cycle_avg);
  free_imatrix(status->sensor_loc);
  free_dmatrix(status->sensor_noise);
  free_dvector(status->maxIR);
  free_dvector(status->layer_maxdroop);
  free_dvector(status->TSVcur);
  free_dvector(status->maxTSVcur);
  free_imatrix(status->gridstats.counter_2D);
  free_dmatrix(status->gridstats.max_2D);
  free_dmatrix(status->gridstats.integral_2D);
  free_ivector(status->blkstats.counter_1D);
  free_dvector(status->blkstats.max_1D);
  free_dvector(status->corestats.max_1D);
  free_dmatrix(status->vdd_cur);
  free_dmatrix(status->gnd_cur);
  if(model->config.vgradient_analyse)
    free_dvector(status->vgradient.max_1D);
  free(status);
}
void populate_status(model_t *model, status_t *status)
{
  if (strcmp(model->config.senloc_file, NULLFILE)){
      parse_sensor_loc(model, status, model->config.senloc_file);
  }
}
void parse_sensor_loc(model_t *model, status_t *status, char *file)
{
  char str[LINE_SIZE], copy[LINE_SIZE]; 
  char s[STR_SIZE];
  int grid_x, grid_y;
  char *ptr;
  FILE *fp;
  /* short cuts */  
  int nr = model->rows;
  int nc = model->cols;
  if (!strcasecmp(file, "stdin"))
    fp = stdin;
  else
    fp = fopen (file, "r");
  if (!fp) {
      sprintf(s, "error opening sensor_loc file %s\n", file);
      fatal(s);
  }
  fseek(fp, 0, SEEK_SET);
  while(!feof(fp)) {
      fgets(str, LINE_SIZE, fp);
      if (feof(fp))
        break;
      strcpy(copy, str);
      /* ignore comments and empty lines */
      ptr = strtok(str, " \r\t\n");
      if (!ptr || ptr[0] == '#')
        continue;
      if (sscanf(copy, "%d%d", &grid_x, &grid_y) == 2) {
          if ((grid_x >= model->cols) || (grid_y >= model->rows) ||
              (grid_x < 0) || (grid_y < 0)){
              printf("x = %d, y = %d\n", grid_x, grid_y);
              printf("grid_size = %d*%d\n", nc,nr);
              fatal("Sensor location does not fit in current grid!\n");
          }
          if (SENSOR == status->sensor_loc[nr - grid_y - 1][grid_x])
            warning("Duplication exists in sensor location file\n");
          status->sensor_loc[nr - grid_y - 1][grid_x] = SENSOR;
      }
      else
        fatal("invalid pad location file format\n");
  }
  if(fp != stdout)
    fclose(fp);	
}
void PDN_steady_analyze(model_t *model, status_t *status)
{
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  //pad current
  get_pad_current(model, status);
  //TSV current
  if(model->is_3D)
    get_TSV_current(model, status);
  /* IR drop*/
  get_maxIR(model, status->maxIR);
  //calculate static PDN power loss
  status->PDN_power = get_steady_PDN_power(model);
}
void print_steady_analyze(model_t *model, status_t *status)
{
  int l;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int p_count = 1;
  printf("%d: chip dimension (width/height, meter):  %lf/%lf\n", 
         p_count, model->width, model->height);p_count++;
  printf("%d: supply voltage vdd (Volt):             %.2lf\n", 
         p_count, model->config.vdd);p_count++;
  printf("%d: virtual grid size (num_cols/num_rows): %d / %d\n",
         p_count, nc, nr);p_count++;
  printf("%d: pad grid size (num_cols/num_rows):     %d / %d\n",
         p_count, model->c4->pad_grid_col, model->c4->pad_grid_row);p_count++;
  printf("%d: number of pads (vdd/gnd):              %d / %d\n",
         p_count, model->c4->vdd_num, model->c4->gnd_num);p_count++;
  printf("%d: sum of current (A):                    %lf\n",
         p_count, status->sumcur);p_count++;
  printf("%d: Max pad current (A):                   %.4lf / %.4lf\n",
         p_count, status->maxcur_vdd, status->maxcur_gnd);p_count++;
  printf("%d: max on-chip IR drop (%%Vdd):            ", 
         p_count);p_count++;
  for(l=0; l<nl; l++)
    printf("%.3lf / ", status->maxIR[l]);
  printf("\n");
  if(model->is_3D){
      printf("%d: TSV Count:                             ", 
             p_count);p_count++;
      for(l=0; l<nl-1; l++)
        printf("%d/", model->layers[l].tsv.num_gnd + model->layers[l].tsv.num_vdd);
      printf("\n");
      printf("%d: max TSV current (A):                   ", 
             p_count);p_count++;
      for(l=0; l<nl-1; l++)
        printf("%.4lf/", status->maxTSVcur[l]);
      printf("\n");
  }
  printf("%d: PDN static power loss (W):             %lf\n", 
         p_count, status->PDN_power);p_count++;
}
void PDN_trans_analyze(model_t *model, status_t *status)
{
  int i;
  int m = model->trans_matrix_dim;
  double l_pkg_p = model->config.PDN_pkg_pL;
  double r_pkg_p = model->config.PDN_pkg_pR;
  double delta_t = 1/model->config.proc_clock_freq;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  for(i=0; i<m; i++)
    status->cycle_avg[i] += model->last_trans[i];
  if(!(status->trans_counter % model->config.PDN_step_percycle)){
      for(i=0; i<m; i++){
          status->cycle_avg[i] /= model->config.PDN_step_percycle;
      }
      if(model->config.PDN_pkgLC){
          /* Package node droop */
          status->curIc   = status->cycle_avg[m-1];
          status->curVc   = status->cycle_avg[m-2];
          status->avgIc   = (status->curIc + status->prevIc) / 2;
          status->avgVc   = (status->curVc + status->prevVc) / 2;
          status->dIc     = status->curIc - status->prevIc;
          status->pkgDrop = status->avgIc*r_pkg_p + status->avgVc + l_pkg_p*status->dIc/delta_t;
          status->pkgDrop = 100 * ((vdd-gnd) - status->pkgDrop) / (vdd-gnd);
          status->prevIc = status->curIc;
          status->prevVc = status->curVc;
      }
      /* Onchip node droop */
      if(!model->is_3D)
        onchipV_analyze_2D(model, status);
      else
        onchipV_analyze_3D(model, status);
      zero_dvector(status->cycle_avg, m);
  }
  if((model->config.animation) &&
     !(status->trans_counter % model->config.frame_intv)){
      draw_single_gif(model, status, status->draw_counter, TRANSIENT);
      status->draw_counter++;
  }
}
void print_trans_header(model_t *model, status_t *status, FILE *fp)
{
  int i, j, l;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int **sloc = status->sensor_loc;
  if(model->config.PDN_pkgLC){
      //fprintf(fp, "pkgCur\t");
      fprintf(fp, "pkgDrop\t");
  }
  fprintf(fp, "max_onchip_drop\t");
  //fprintf(fp, "vio_area_ratio\t");
  //for(i=0; i<MAX_CORE_NUM; i++)
  //  if(-LARGENUM != status->corestats.max_1D[i])
  //    fprintf(fp, "C_%d\t", i);
  if(model->is_3D){
      for(l=0; l<nl; l++)
        fprintf(fp, "Layer_%d\t", l);
  }
  if(strcmp(model->config.senloc_file, NULLFILE)){
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++)
          if(SENSOR == sloc[i][j])
            fprintf(fp, "S_%d_%d\t", j, nr-i-1);
  }
  fprintf(fp, "\n");
}
void print_trans_analyze(model_t *model, status_t *status, FILE *fp)
{
  int i, j, l;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int **sloc = status->sensor_loc;
  if(model->config.PDN_pkgLC){
      //fprintf(fp, "%.4lf\t", status->curIc);
      fprintf(fp, "%.4lf\t", status->pkgDrop);
  }
  fprintf(fp, "%.4lf\t", status->maxdroop);
  //fprintf(fp, "%.4lf\t", status->vio_area_ratio);
  //for(i=0; i<MAX_CORE_NUM; i++){
  //    if(-LARGENUM != status->corestats.max_1D[i]){
  //        fprintf(fp, "%lf\t", status->corestats.max_1D[i]);
  //    }
  //}
  if(model->is_3D){
      for(l=0; l<nl; l++)
        fprintf(fp, "%.4lf\t", status->layer_maxdroop[l]);
  }
  if (strcmp(model->config.senloc_file, NULLFILE)){
      for(i=0; i < nr; i++){
          for(j=0; j < nc; j++){
              if (SENSOR == sloc[i][j]){
                  fprintf(fp, "%.4lf\t", status->sensor_noise[i][j]);
              }
          }
      }
  }
  fprintf(fp, "\n");
}
void print_step_singlenode(model_t *model, FILE *fp, int pi, int pj)
{
  double vdroop, vnoise;
  int nr = model->rows;
  int nc = model->cols;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  int nbr = 2*nr*nc - nr - nc;
  int nml = model->layers[0].metal_layers.n_metal/2;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  int cur_idx = pi*nc + pj;
  if(model->config.PDN_gridL)
    vdroop = model->last_trans[nvp+cur_idx] - model->last_trans[nvp+nr*nc+nbr*nml+ngp+cur_idx];
  else
    vdroop = model->last_trans[nvp+cur_idx] - model->last_trans[nvp+nr*nc+ngp+cur_idx];
  vnoise = 100*(vdd-gnd-vdroop)/(vdd-gnd);
  fprintf(fp, "%lf\t%lf\n", model->last_trans[nvp+cur_idx], vnoise);
}
void print_status_singlenode(model_t *model, status_t *status, FILE *fp, int pi, int pj)
{
  double vdroop, vnoise;
  int nr = model->rows;
  int nc = model->cols;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  int nbr = 2*nr*nc - nr - nc;
  int nml = model->layers[0].metal_layers.n_metal/2;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  if((pi>=nr) || (pj>=nc)){
      fatal("out of bound! func. print_status_singlenode\n");
  }
  int cur_idx = pi*nc + pj;
  if(model->config.PDN_gridL)
    vdroop = status->cycle_avg[nvp+cur_idx] - status->cycle_avg[nvp+nr*nc+nbr*nml+ngp+cur_idx];
  else
    vdroop = status->cycle_avg[nvp+cur_idx] - status->cycle_avg[nvp+nr*nc+ngp+cur_idx];
  vnoise = 100*(vdd-gnd-vdroop)/(vdd-gnd);
  fprintf(fp, "%lf\t%lf\n", status->cycle_avg[nvp+cur_idx], vnoise);
}
// get current for pad and top level metal
void get_pad_current(model_t *model, status_t *status)
{
  int i, j, k;
  double r_tsv_pad;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int vs = model->config.v_stacking;
  double **vcur = status->vdd_cur;
  double **gcur = status->gnd_cur;
  int **vloc = model->c4->vdd_loc;
  int **gloc = model->c4->gnd_loc;
  double *v = model->last_steady;
  double r_pad = model->c4->pad_r;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  double pkg_vdd = model->last_steady[2*nl*nr*nc+PKG_VDD];
  double pkg_gnd = model->last_steady[2*nl*nr*nc+PKG_GND];
  double padD = model->config.PDN_padD/2;
  double pad_area = PI * padD * padD;
  /* pad current */
  if(!vs){
      for(i = 0; i < nr; i++)
        for(j = 0; j < nc; j++){
            if (vloc[i][j] & PGPAD)
              vcur[i][j] = (pkg_vdd - v[i*nc + j]) / r_pad;
            else
              vcur[i][j] = 0;
            if (gloc[i][j] & PGPAD)
              gcur[i][j] = (v[nl*nr*nc + i*nc + j] - pkg_gnd) / r_pad;
            else
              gcur[i][j] = 0;
        }
  }
  else{
      r_tsv_pad = r_pad;
      for(k=0; k<nl-1; k++)
        r_tsv_pad += model->layers[k].tsv.r;
      for(i = 0; i < nr; i++)
        for(j = 0; j < nc; j++){
            if (vloc[i][j] & PGPAD)
              vcur[i][j] = (nl*vdd - v[(2*nl-1)*nr*nc + i*nc + j]) / r_tsv_pad;
            else
              vcur[i][j] = 0;
            if (gloc[i][j] & PGPAD)
              gcur[i][j] = (v[i*nc + j] - gnd) / r_pad;
            else
              gcur[i][j] = 0;
        }
  }
  /* Vdd pad current */
  status->sumcur = sum_dmatrix(vcur, nr, nc);
  status->maxcur_vdd = max_dmatrix_skip0(vcur, nr, nc);
  status->curIth_vdd = above_threshold_dmatrix(vcur, nr, nc, model->c4->Ith);
  /* Gnd pad current */
  status->maxcur_gnd = max_dmatrix_skip0(gcur, nr, nc);
  status->curIth_gnd = above_threshold_dmatrix(gcur, nr, nc, model->c4->Ith);
  if(status->maxcur_vdd > status->maxcur_gnd)
    status->max_pad_dense = status->maxcur_vdd;
  else
    status->max_pad_dense = status->maxcur_gnd;
  status->max_pad_dense /= pad_area;
}
void get_TSV_current(model_t *model, status_t *status)
{
  int i, j, l;
  int a_grid_idx, b_grid_idx;
  double cur_val = 0;
  double layer_max, layer_sum;
  double Rv;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int vs = model->config.v_stacking;
  double *v = model->last_steady;
  int counter = 0;
  for(l=0; l<nl-1; l++){
      layer_max = 0;
      //layer_sum = 0;
      Rv = model->layers[l].tsv.r;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            if(!vs){
                if((VDDTSV == model->layers[l].tsv.loc[i][j])){
                    a_grid_idx = l*nr*nc + i*nc + j;
                    b_grid_idx = a_grid_idx + nr*nc;
                    cur_val = (v[a_grid_idx] - v[b_grid_idx]) / Rv;
                    status->TSVcur[counter] = cur_val;
                    counter++;
                }
                else if((GNDTSV == model->layers[l].tsv.loc[i][j])){
                    a_grid_idx = nl*nr*nc + l*nr*nc + i*nc + j;
                    b_grid_idx = a_grid_idx + nr*nc;
                    cur_val = (v[b_grid_idx] - v[a_grid_idx]) / Rv;
                    status->TSVcur[counter] = cur_val;
                    counter++;
                    //layer_sum += cur_val;
                }
            }
            else{
                a_grid_idx = l*2*nr*nc + nr*nc + i*nc + j;
                b_grid_idx = a_grid_idx + nr*nc;
                if((GNDTSV == model->layers[l].tsv.loc[i][j])){
                    cur_val = (v[b_grid_idx] - v[a_grid_idx]) / Rv;
                    status->TSVcur[counter] = cur_val;
                    counter++;
                    //layer_sum += cur_val;
                }
            }
            if(cur_val > layer_max)
              layer_max = cur_val;
        }
      status->maxTSVcur[l] = layer_max;
      //printf("%.2lf\n", layer_sum);
  }
}
double get_steady_PDN_power(model_t *model)
{
  int i, j, l, k, grid_idx, direc;
  int a_grid_idx, b_grid_idx;
  double r_tsv_pad;
  double pad_cur, branch_cur, tsv_cur;
  double cur_sum, cur_sq_sum, vddpad_cur_sq_sum ;
  double pad_power, pkg_power, onchip_power, tsv_power;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int vs = model->config.v_stacking;
  int **vloc = model->c4->vdd_loc;
  int **gloc = model->c4->gnd_loc;
  double *v = model->last_steady;
  double r_pad = model->c4->pad_r;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  double pkg_vdd = model->last_steady[2*nl*nr*nc+PKG_VDD];
  double pkg_gnd = model->last_steady[2*nl*nr*nc+PKG_GND];
  double pkg_r = model->config.PDN_pkg_sR;
  double rv; double rx; double ry;
  if(!vs){
      cur_sum = 0;
      cur_sq_sum = 0;
      /* pad power */
      l = 0;
      for(i = 0; i < nr; i++)
        for(j = 0; j < nc; j++){
            grid_idx = l*nr*nc + i*nc + j;
            if (vloc[i][j] & PGPAD){
                pad_cur = (pkg_vdd - v[grid_idx]) / r_pad;
                cur_sq_sum += pad_cur*pad_cur;
                cur_sum += pad_cur;
            }
            if (gloc[i][j] & PGPAD){
                pad_cur = (v[nl*nr*nc + grid_idx] - pkg_gnd) / r_pad;
                cur_sq_sum += pad_cur*pad_cur;
            }
        }
      pad_power = cur_sq_sum * r_pad;
      /* on-chip power */
      onchip_power = 0;
      for(l=0; l<nl; l++){
          rx = 0; ry = 0;
          //calculate grid R
          for(i=0; i<model->layers[l].metal_layers.n_metal; i++){
              direc = model->layers[l].metal_layers.geo[i].direc;
              if(MLCF_X == direc)
                rx += 1/model->layers[l].metal_layers.gridRL[i].r;
              else
                ry += 1/model->layers[l].metal_layers.gridRL[i].r;
          }
          rx = 1/rx; ry = 1/ry;
          cur_sq_sum = 0;
          for(i=0; i<nr; i++)
            for(j=0; j<nc-1; j++){
                grid_idx = l*nr*nc + i*nc + j;
                branch_cur = (v[grid_idx] - v[grid_idx+1])/rx;
                cur_sq_sum += branch_cur*branch_cur;
                branch_cur = (v[nl*nr*nc+grid_idx] - v[nl*nr*nc+grid_idx+1])/rx;
                cur_sq_sum += branch_cur*branch_cur;
            }
          onchip_power += cur_sq_sum * rx;
          cur_sq_sum = 0;
          for(i=0; i<nr-1; i++)
            for(j=0; j<nc; j++){
                grid_idx = l*nr*nc + i*nc + j;
                branch_cur = (v[grid_idx] - v[grid_idx+nc])/ry;
                cur_sq_sum += branch_cur*branch_cur;
                branch_cur = (v[nl*nr*nc+grid_idx] - v[nl*nr*nc+grid_idx+nc])/ry;
                cur_sq_sum += branch_cur*branch_cur;
            }
          onchip_power += cur_sq_sum * ry;
      }
      cur_sq_sum = 0;
      tsv_power = 0;
      /* TSV power */
      for(l=0; l<nl-1; l++){
          rv = model->layers[l].tsv.r;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                if((VDDTSV == model->layers[l].tsv.loc[i][j])){
                    a_grid_idx = l*nr*nc + i*nc + j;
                    b_grid_idx = a_grid_idx + nr*nc;
                    tsv_cur = (v[a_grid_idx] - v[b_grid_idx]) / rv;
                    cur_sq_sum += tsv_cur*tsv_cur;
                }
                else if((GNDTSV == model->layers[l].tsv.loc[i][j])){
                    a_grid_idx = nl*nr*nc + l*nr*nc + i*nc + j;
                    b_grid_idx = a_grid_idx + nr*nc;
                    tsv_cur = (v[b_grid_idx] - v[a_grid_idx]) / rv;
                    cur_sq_sum += tsv_cur*tsv_cur;
                }
            }
          tsv_power += cur_sq_sum * rv; 
      }
      pkg_power = 2 * cur_sum * cur_sum * pkg_r;
  }
  else{
      /* pad power */
      cur_sq_sum = 0;
      vddpad_cur_sq_sum = 0;
      r_tsv_pad = r_pad;
      for(k=0; k<nl-1; k++)
        r_tsv_pad += model->layers[k].tsv.r;
      for(i = 0; i < nr; i++)
        for(j = 0; j < nc; j++){
            if (vloc[i][j] & PGPAD){
                pad_cur = (nl*vdd - v[(2*nl-1)*nr*nc + i*nc + j]) / r_tsv_pad;
                cur_sq_sum += pad_cur*pad_cur;
                vddpad_cur_sq_sum += pad_cur*pad_cur;
            }
            if (gloc[i][j] & PGPAD){
                pad_cur = (v[i*nc + j] - gnd) / r_pad;
                cur_sq_sum += pad_cur*pad_cur;
            }
        }
      pad_power = cur_sq_sum * r_pad;
      for(l=0; l<nl; l++){
          rx = 0; ry = 0;
          //calculate grid R
          for(i=0; i<model->layers[l].metal_layers.n_metal; i++){
              direc = model->layers[l].metal_layers.geo[i].direc;
              if(MLCF_X == direc)
                rx += 1/model->layers[l].metal_layers.gridRL[i].r;
              else
                ry += 1/model->layers[l].metal_layers.gridRL[i].r;
          }
          rx = 1/rx; ry = 1/ry;
          cur_sq_sum = 0;
          /* on-chip power */
          for(i=0; i<nr; i++)
            for(j=0; j<nc-1; j++){
                grid_idx = (2*l)*nr*nc + i*nc + j;
                branch_cur = (v[grid_idx] - v[grid_idx+1])/rx;
                cur_sq_sum += branch_cur*branch_cur;
                grid_idx = (2*l+1)*nr*nc + i*nc + j;
                branch_cur = (v[grid_idx] - v[grid_idx+1])/rx;
                cur_sq_sum += branch_cur*branch_cur;
            }
          onchip_power += cur_sq_sum * rx;
          cur_sq_sum = 0;
          for(i=0; i<nr-1; i++)
            for(j=0; j<nc; j++){
                grid_idx = (2*l)*nr*nc + i*nc + j;
                branch_cur = fabs((v[grid_idx] - v[grid_idx+nc])/ry);
                cur_sq_sum += branch_cur*branch_cur;
                grid_idx = (2*l+1)*nr*nc + i*nc + j;
                branch_cur = fabs((v[grid_idx] - v[grid_idx+nc])/ry);
                cur_sq_sum += branch_cur*branch_cur;
            }
          onchip_power += cur_sq_sum * ry;
      }
      cur_sq_sum = 0;
      tsv_power = 0;
      /* TSV power */
      for(l=0; l<nl-1; l++){
          rv = model->layers[l].tsv.r;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                if((GNDTSV == model->layers[l].tsv.loc[i][j])){
                    a_grid_idx = l*2*nr*nc + nr*nc + i*nc + j;
                    b_grid_idx = a_grid_idx + nr*nc;
                    tsv_cur = (v[b_grid_idx] - v[a_grid_idx]) / rv;
                    cur_sq_sum += tsv_cur*tsv_cur;
                }
            }
          tsv_power += cur_sq_sum * rv; 
      }
      tsv_power += vddpad_cur_sq_sum * (r_tsv_pad - r_pad); 
  }
  return pad_power + pkg_power + onchip_power + tsv_power;
}
void get_maxIR(model_t *model, double *maxIR)
{
  int i, j, l;
  int v_grid_idx, g_grid_idx;
  int cur_id;
  double temp;
  double min;
  blist_t *ptr;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int vs = model->config.v_stacking;
  double *v = model->last_steady;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  if(!vs){
      for(l = 0; l < nl; l++){
          min = LARGENUM;
          for(i = 0; i < nr; i++)
            for(j = 0; j < nc; j++){
                v_grid_idx = l*nr*nc + i*nc + j;
                g_grid_idx = nl*nr*nc + v_grid_idx;
                temp = v[v_grid_idx] - v[g_grid_idx];
                if (temp < min){
                    min = temp;
                }
            }
          maxIR[l] = 100 * (1-min/(vdd-gnd));
      }
  }
  else{
      for(l = 0; l < nl; l++){
          min = LARGENUM;
          for(i = 0; i < nr; i++)
            for(j = 0; j < nc; j++){
                g_grid_idx = l*2*nr*nc + i*nc + j;
                v_grid_idx = g_grid_idx + nr*nc;
                temp = v[v_grid_idx] - v[g_grid_idx];
                if (temp < min){
                    min = temp;
                }
            }
          maxIR[l] = 100 * (1-min/(vdd-gnd));
      }
  }
  return ;
}
/* Analyze onchip voltage droop, return adjusted max percent */
void onchipV_analyze_2D(model_t *model, status_t *status)
{
  int i, j;
  double temp, vnoise;
  double max = -LARGENUM;
  int blk_idx, core_id;
  int cur;
  int print_nodetrace = 0;
  blist_t *ptr;
  FILE *fp_t, *fp_v;
  char str[STR_SIZE];
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  int nml = model->layers[0].metal_layers.n_metal/2;
  int nbr = 2*nr*nc - nr - nc;
  int **sloc = status->sensor_loc;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  if (strcmp(model->config.node_viotrace_file, NULLFILE)){
      print_nodetrace = 1;
      fp_t = fopen (model->config.node_viotrace_file, "a");
      if (!fp_t) {
          sprintf (str,"error: %s could not be opened for writing\n", model->config.node_viotrace_file);
          fatal(str);
      }
  }
  status->vio_area_ratio = 0;
  negL_dvector(status->corestats.max_1D, MAX_CORE_NUM);
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++){
        cur = i*nc + j;
        ptr = model->layers[0].b2gmap[i][j];
        blk_idx = ptr->idx;
        core_id = get_core_id(model->layers[0].flp->units[blk_idx].name);
        if(!model->is_3D){
            if(model->config.PDN_gridL)
              temp = status->cycle_avg[nvp+cur] - status->cycle_avg[nvp+nr*nc+nbr*nml+ngp+cur];
            else
              temp = status->cycle_avg[nvp+cur] - status->cycle_avg[nvp+nr*nc+ngp+cur];
        }
        else{
            temp = status->cycle_avg[nvp+ngp+cur] - status->cycle_avg[nvp+ngp+nr*nc+cur];
        }
        vnoise = 100*(vdd-gnd-temp)/(vdd-gnd);
        if (vnoise > max){ max = vnoise; }
        status->gridstats.integral_2D[i][j] += vnoise;
        /* per cycle noise amplitude analysis */
        if(vnoise > status->gridstats.max_2D[i][j]){
            status->gridstats.max_2D[i][j] = vnoise;
        }
        if(vnoise > status->blkstats.max_1D[blk_idx]){
            status->blkstats.max_1D[blk_idx] = vnoise;
        }
        // per-core max droop of this analysis run
        if((core_id >= 0) && (vnoise > status->corestats.max_1D[core_id]))
          status->corestats.max_1D[core_id] = vnoise;
        /* per cycle violation analysis */
        if(vnoise > (model->config.PDN_noise_th)){
            /* grid violation counter */
            status->gridstats.counter_2D[i][j]++;
            /* per block violation counter */
            if(status->blkstats.counter_1D[blk_idx] >= 0){
                // at most increment once in a cycle
                status->blkstats.counter_1D[blk_idx]++;
                status->blkstats.counter_1D[blk_idx] *= -1;
            }
            /* get vio grid # */
            status->vio_area_ratio += 1;
        }
        /* Update sensor record */
        if (SENSOR == sloc[i][j]){
            status->sensor_noise[i][j] = vnoise;
        }
        /* per cycle grid violation trace */
        if(print_nodetrace){
            if(vnoise > (model->config.PDN_noise_th)){ fprintf(fp_t, "1"); }
            else{ fprintf(fp_t, "0"); }
        }
    }
  /* convert vio area to ratio */
  status->vio_area_ratio /= nr*nc;
  abs_ivector(status->blkstats.counter_1D, model->total_n_blocks);
  if(print_nodetrace){
      fprintf(fp_t, "\n");
      fclose(fp_t);	
  }
  //print grid voltage trace
  if (strcmp(model->config.gridvol_file, NULLFILE)){
      fp_v = fopen (model->config.gridvol_file, "a");
      if (!fp_v) {
          sprintf (str,"error: %s could not be opened for writing\n", model->config.gridvol_file);
          fatal(str);
      }
      for(i = 0; i < nr; i++)
        for(j = 0; j < nc; j++){
            cur = i*nc + j;
            fprintf(fp_v, "%.7f ", status->cycle_avg[nvp+cur]);
        }
      fprintf(fp_v, "\n");
      fclose(fp_v);	
  }
  status->maxdroop = max;
  //transient grid voltage gradient analysis
  if(model->config.vgradient_analyse){
      trans_vgradient_analyze(model, status);
  }
}
void onchipV_analyze_3D(model_t *model, status_t *status)
{
  int i, j, l;
  int vdd_idx, gnd_idx;
  double rail_v, vnoise;
  double max, l_max;
  int cur;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  max = -LARGENUM;
  for(l=0; l<nl; l++){
      l_max = -LARGENUM;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            cur = i*nc + j;
            vdd_idx = nvp + ngp + l*2*nr*nc + cur; 
            gnd_idx = nvp + ngp + l*2*nr*nc + nr*nc + cur; 
            rail_v = status->cycle_avg[vdd_idx] - status->cycle_avg[gnd_idx];
            vnoise = 100*(vdd-gnd-rail_v)/(vdd-gnd);
            if (vnoise > l_max){ l_max = vnoise; }
            if (vnoise > max){ max = vnoise; }
        }
      status->layer_maxdroop[l] = l_max;
  }
  status->maxdroop = max;
}
void perstep_droop_3D(model_t *model, FILE *fp)
{
  int i, j, l;
  int vdd_idx, gnd_idx;
  double rail_v, vnoise;
  double max, l_max;
  int cur;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  max = -LARGENUM;
  for(l=0; l<nl; l++){
      l_max = -LARGENUM;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            cur = i*nc + j;
            vdd_idx = nvp + ngp + l*2*nr*nc + cur; 
            gnd_idx = nvp + ngp + l*2*nr*nc + nr*nc + cur; 
            rail_v = model->last_trans[vdd_idx] - model->last_trans[gnd_idx];
            vnoise = 100*(vdd-gnd-rail_v)/(vdd-gnd);
            if (vnoise > l_max){ l_max = vnoise; }
            if (vnoise > max){ max = vnoise; }
        }
      fprintf(fp, "%.4lf\t", l_max);
  }
  fprintf(fp, "%.4lf\n", max);
}
//for trans WP
void trans_vgradient_analyze(model_t *model, status_t *status)
{
  int i,j;
  double v_grad;
  double *rst_v, *rst_g;
  int brc_idx, nod_idx;
  /* shortcuts */
  int nr = model->rows;
  int nc = model->cols;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  int nml = model->layers[0].metal_layers.n_metal/2;
  int nbr = 2*nr*nc - nr - nc;
  // max
  //////////////////////////////////////////////////
  //VDD
  rst_v = &status->cycle_avg[nvp];
  for(i=0; i<nr; i++){
      for(j=0; j<nc-1; j++){
          brc_idx = i*(nc-1) + j;
          nod_idx = i*nc + j;
          v_grad = (rst_v[nod_idx] - rst_v[nod_idx + 1]);
          if(v_grad > status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  for(i=0; i<nr-1; i++){
      for(j=0; j<nc; j++){
          brc_idx = (nc-1)*nr + i*nc + j;
          nod_idx = i*nc + j;
          v_grad = (rst_v[nod_idx] - rst_v[nod_idx + nc]);
          if(v_grad > status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  //GND
  if(model->config.PDN_gridL)
    rst_g = &status->cycle_avg[nvp+ngp+nr*nc+nml*nbr];
  else
    rst_g = &status->cycle_avg[nvp+ngp+nr*nc];
  for(i=0; i<nr; i++){
      for(j=0; j<nc-1; j++){
          brc_idx = nbr + i*(nc-1) + j;
          nod_idx = i*nc + j;
          v_grad = (rst_g[nod_idx] - rst_g[nod_idx + 1]);
          if(v_grad > status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  for(i=0; i<nr-1; i++){
      for(j=0; j<nc; j++){
          brc_idx = nbr + (nc-1)*nr + i*nc + j;
          nod_idx = i*nc + j;
          v_grad = (rst_g[nod_idx] - rst_g[nod_idx + nc]);
          if(v_grad > status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  // VDD-GND
  for(i=0; i<nr; i++){
      for(j=0; j<nc-1; j++){
          brc_idx = nbr*2 + i*(nc-1) + j;
          nod_idx = i*nc + j;
          v_grad = (rst_v[nod_idx] - rst_g[nod_idx]) - (rst_v[nod_idx + 1]-rst_g[nod_idx + 1]);
          if(v_grad > status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  for(i=0; i<nr-1; i++){
      for(j=0; j<nc; j++){
          brc_idx = nbr*2 + (nc-1)*nr + i*nc + j;
          nod_idx = i*nc + j;
          v_grad = (rst_v[nod_idx] - rst_g[nod_idx]) - (rst_v[nod_idx + nc] - rst_g[nod_idx + nc]);
          if(v_grad > status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  // min
  //////////////////////////////////////////////////
  //VDD
  rst_v = &status->cycle_avg[nvp];
  for(i=0; i<nr; i++){
      for(j=0; j<nc-1; j++){
          brc_idx = nbr*3 + i*(nc-1) + j;
          nod_idx = i*nc + j;
          v_grad = (rst_v[nod_idx] - rst_v[nod_idx + 1]);
          if(v_grad < status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  for(i=0; i<nr-1; i++){
      for(j=0; j<nc; j++){
          brc_idx = nbr*3 + (nc-1)*nr + i*nc + j;
          nod_idx = i*nc + j;
          v_grad = (rst_v[nod_idx] - rst_v[nod_idx + nc]);
          if(v_grad < status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  //GND
  if(model->config.PDN_gridL)
    rst_g = &status->cycle_avg[nvp+ngp+nr*nc+nml*nbr];
  else
    rst_g = &status->cycle_avg[nvp+ngp+nr*nc];
  for(i=0; i<nr; i++){
      for(j=0; j<nc-1; j++){
          brc_idx = nbr*4 + i*(nc-1) + j;
          nod_idx = i*nc + j;
          v_grad = (rst_g[nod_idx] - rst_g[nod_idx + 1]);
          if(v_grad < status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  for(i=0; i<nr-1; i++){
      for(j=0; j<nc; j++){
          brc_idx = nbr*4 + (nc-1)*nr + i*nc + j;
          nod_idx = i*nc + j;
          v_grad = (rst_g[nod_idx] - rst_g[nod_idx + nc]);
          if(v_grad < status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  // VDD-GND
  for(i=0; i<nr; i++){
      for(j=0; j<nc-1; j++){
          brc_idx = nbr*5 + i*(nc-1) + j;
          nod_idx = i*nc + j;
          v_grad = (rst_v[nod_idx] - rst_g[nod_idx]) - (rst_v[nod_idx + 1]-rst_g[nod_idx + 1]);
          if(v_grad < status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  for(i=0; i<nr-1; i++){
      for(j=0; j<nc; j++){
          brc_idx = nbr*5 + (nc-1)*nr + i*nc + j;
          nod_idx = i*nc + j;
          v_grad = (rst_v[nod_idx] - rst_g[nod_idx]) - (rst_v[nod_idx + nc] - rst_g[nod_idx + nc]);
          if(v_grad < status->vgradient.max_1D[brc_idx])
            status->vgradient.max_1D[brc_idx] = v_grad;
      }
  }
  // Root mean square
  //////////////////////////////////////////////////
  //VDD
  rst_v = &status->cycle_avg[nvp];
  for(i=0; i<nr; i++){
      for(j=0; j<nc-1; j++){
          brc_idx = nbr*6 + i*(nc-1) + j;
          nod_idx = i*nc + j;
          v_grad = (rst_v[nod_idx] - rst_v[nod_idx + 1]);
          if(stat_counter == 0)
            status->vgradient.max_1D[brc_idx] = v_grad*v_grad;
          else
            status->vgradient.max_1D[brc_idx] += v_grad*v_grad;
      }
  }
  for(i=0; i<nr-1; i++){
      for(j=0; j<nc; j++){
          brc_idx = nbr*6 + (nc-1)*nr + i*nc + j;
          nod_idx = i*nc + j;
          v_grad = (rst_v[nod_idx] - rst_v[nod_idx + nc]);
          if(stat_counter == 0)
            status->vgradient.max_1D[brc_idx] = v_grad*v_grad;
          else
            status->vgradient.max_1D[brc_idx] += v_grad*v_grad;
      }
  }
  //GND
  if(model->config.PDN_gridL)
    rst_g = &status->cycle_avg[nvp+ngp+nr*nc+nml*nbr];
  else
    rst_g = &status->cycle_avg[nvp+ngp+nr*nc];
  for(i=0; i<nr; i++){
      for(j=0; j<nc-1; j++){
          brc_idx = nbr*7 + i*(nc-1) + j;
          nod_idx = i*nc + j;
          v_grad = (rst_g[nod_idx] - rst_g[nod_idx + 1]);
          if(stat_counter == 0)
            status->vgradient.max_1D[brc_idx] = v_grad*v_grad;
          else
            status->vgradient.max_1D[brc_idx] += v_grad*v_grad;
      }
  }
  for(i=0; i<nr-1; i++){
      for(j=0; j<nc; j++){
          brc_idx = nbr*7 + (nc-1)*nr + i*nc + j;
          nod_idx = i*nc + j;
          v_grad = (rst_g[nod_idx] - rst_g[nod_idx + nc]);
          if(stat_counter == 0)
            status->vgradient.max_1D[brc_idx] = v_grad*v_grad;
          else
            status->vgradient.max_1D[brc_idx] += v_grad*v_grad;
      }
  }
  stat_counter++;
}
//void trans_vgradient_analyze(model_t *model, status_t *status)
//{
//  int i,j;
//  double v_grad;
//  double *rst;
//  int brc_idx, nod_idx;
//
//  /* shortcuts */
//  int nr = model->rows;
//  int nc = model->cols;
//  int nvp = model->c4->vdd_num;
//  int ngp = model->c4->gnd_num;
//  int nml = model->layers[0].metal_layers.n_metal/2;
//  int nbr = 2*nr*nc - nr - nc;
//
//  //VDD
//  rst = &status->cycle_avg[nvp];
//  for(i=0; i<nr; i++){
//      for(j=0; j<nc-1; j++){
//          brc_idx = i*(nc-1) + j;
//          nod_idx = i*nc + j;
//          v_grad = (rst[nod_idx] - rst[nod_idx + 1]);
//          if(fabs(v_grad) > fabs(status->vgradient.max_1D[brc_idx]))
//            status->vgradient.max_1D[brc_idx] = v_grad;
//      }
//  }
//  for(i=0; i<nr-1; i++){
//      for(j=0; j<nc; j++){
//          nod_idx = i*nc + j;
//          brc_idx = (nc-1)*nr + i*nc + j;
//          v_grad = (rst[nod_idx] - rst[nod_idx + nc]);
//          if(fabs(v_grad) > fabs(status->vgradient.max_1D[brc_idx]))
//            status->vgradient.max_1D[brc_idx] = v_grad;
//      }
//  }
//
//  //GND
//  if(model->config.PDN_gridL)
//    rst = &status->cycle_avg[nvp+ngp+nr*nc+nml*nbr];
//  else
//    rst = &status->cycle_avg[nvp+ngp+nr*nc];
//
//  for(i=0; i<nr; i++){
//      for(j=0; j<nc-1; j++){
//          brc_idx = nbr + i*(nc-1) + j;
//          nod_idx = i*nc + j;
//          v_grad = (rst[nod_idx] - rst[nod_idx + 1]);
//          if(fabs(v_grad) > fabs(status->vgradient.max_1D[brc_idx]))
//            status->vgradient.max_1D[brc_idx] = v_grad;
//      }
//  }
//  for(i=0; i<nr-1; i++){
//      for(j=0; j<nc; j++){
//          nod_idx = i*nc + j;
//          brc_idx = nbr + (nc-1)*nr + i*nc + j;
//          v_grad = (rst[nod_idx] - rst[nod_idx + nc]);
//          if(fabs(v_grad) > fabs(status->vgradient.max_1D[brc_idx]))
//            status->vgradient.max_1D[brc_idx] = v_grad;
//      }
//  }
//}
void dump_files(model_t *model, status_t *status, int mode)
{
  if (strcmp(model->config.padloc_file_out, NULLFILE)){
      dump_anypadloc(model, model->config.padloc_file_out, PGPAD);
  }
  if(STEADY == mode){
      if (strcmp(model->config.gridvol_file, NULLFILE)){
          dump_grid_drop(model, model->config.gridvol_file);
      }
      if (strcmp(model->config.padcur_file, NULLFILE)){
          dump_cur_with_cordt(model, status, model->config.padcur_file);
      }
      if ((model->is_3D) && (strcmp(model->config.tsvcur_file, NULLFILE))){
          dump_tsv_cur(model, status, model->config.tsvcur_file);
      }
  }
  if(TRANSIENT == mode){
      if (strcmp(model->config.vio_file, NULLFILE)){
          dump_violation(model, status, model->config.vio_file);
      }
      if(model->config.vgradient_analyse)
        if (strcmp(model->config.trans_vgradient_file, NULLFILE)){
            dump_trans_vgradient(model, status, model->config.trans_vgradient_file);
        }
  }
}
void dump_PDN_config(model_t *model, FILE *fp)
{
  int i;
  fprintf(fp, "PDN_grid_intv=%d\n", model->config.PDN_grid_intv);
  for(i=0; i<model->layers[0].metal_layers.n_metal; i++){
      fprintf(fp, "Metal Layer %d: p%e\tw%e\tt%e\n", 
              i, model->layers[0].metal_layers.geo[i].pitch,
              model->layers[0].metal_layers.geo[i].width, 
              model->layers[0].metal_layers.geo[i].thick);
      fprintf(fp, "R:%lf\tL:%e\n", 
              model->layers[0].metal_layers.gridRL[i].r, 
              model->layers[0].metal_layers.gridRL[i].l);
  }
  fprintf(fp, "PDN_padpitch=%e\n", model->config.PDN_padpitch);
  fprintf(fp, "PDN_padD=%e\n", model->config.PDN_padD);
  fprintf(fp, "PDN_padR=%e\n", model->config.PDN_padR);
  fprintf(fp, "PDN_cur_dense=%e\n", model->config.PDN_cur_dense);
  fprintf(fp, "PDN_padconfig=%d\n", model->config.PDN_padconfig);
  fprintf(fp, "padloc_format=%d\n", model->config.padloc_format);
  fprintf(fp, "PDN_decap_dense=%e\n", model->config.PDN_decap_dense);
  fprintf(fp, "PDN_decap_ratio=%e\n", model->config.PDN_decap_ratio);
  fprintf(fp, "PDN_decap_unifm=%d\n", model->config.PDN_decap_unifm);
  fprintf(fp, "PDN_padL=%e\n", model->config.PDN_padL);
  fprintf(fp, "PDN_pkg_sL=%e\n", model->config.PDN_pkg_sL);
  fprintf(fp, "PDN_pkg_sR=%e\n", model->config.PDN_pkg_sR);
  fprintf(fp, "PDN_pkg_C=%e\n", model->config.PDN_pkg_C);
  fprintf(fp, "PDN_pkg_pR=%e\n", model->config.PDN_pkg_pR);
  fprintf(fp, "PDN_pkg_pL=%e\n", model->config.PDN_pkg_pL);
  fprintf(fp, "PDN_pkg_scale=%e\n", model->config.PDN_pkg_scale);
  fprintf(fp, "vdd=%e\n", model->config.vdd);
  fprintf(fp, "gnd=%e\n", model->config.gnd);
  fprintf(fp, "proc_clock_freq=%e\n", model->config.proc_clock_freq);
  fprintf(fp, "PDN_step_percycle=%d\n", model->config.PDN_step_percycle);
  fprintf(fp, "ptrace_sampling_intvl=%d\n", model->config.ptrace_sampling_intvl);
  fprintf(fp, "PDN_ptrace_warmup=%d\n", model->config.PDN_ptrace_warmup);
  fprintf(fp, "PDN_multi_dom=%d\n", model->config.PDN_multi_dom);
  //fprintf(fp, "animation=%d\n", model->config.animation);
  //fprintf(fp, "frame_intv=%d\n", model->config.frame_intv);
  //fprintf(fp, "legend_lwr=%lf\n", model->config.legend_lwr);
  //fprintf(fp, "legend_upr=%lf\n", model->config.legend_upr);
  //fprintf(fp, "legend_curupr=%lf\n", model->config.legend_curupr);
  //fprintf(fp, "reserve_io=%d\n", model->config.reserve_io);
  //fprintf(fp, "MC_pads=%d\n", model->config.MC_pads);
  //fprintf(fp, "IO_dense=%lf\n", model->config.IO_dense);
  fprintf(fp, "v_stacking=%d\n", model->config.v_stacking);
  fprintf(fp, "TSV_config=%d\n", model->config.TSV_config);
  fprintf(fp, "TSV_R=%lf\n", model->config.TSV_R);
  fprintf(fp, "TSV_L=%lf\n", model->config.TSV_L);
  fprintf(fp, "SC_freq=%lf\n", model->config.SC_freq);
  fprintf(fp, "SC_totcap=%lf\n", model->config.SC_totcap);
  fprintf(fp, "SC_Rontop=%lf\n", model->config.SC_Rontop);
  fprintf(fp, "SC_Ronbtm=%lf\n", model->config.SC_Ronbtm);
  fprintf(fp, "run_PDN=%d\n", model->config.run_PDN);
  fprintf(fp, "PDN_pkgLC=%d\n", model->config.PDN_pkgLC);
  fprintf(fp, "PDN_gridL=%d\n", model->config.PDN_gridL);
  fprintf(fp, "PDN_sin_pattern=%d\n", model->config.PDN_sin_pattern);
  fprintf(fp, "PDN_sin_totstep=%d\n", model->config.PDN_sin_totstep);
  fprintf(fp, "PDN_sin_freq=%e\n", model->config.PDN_sin_freq);
  //fprintf(fp, "vgradient_analyse=%d\n", model->config.vgradient_analyse);
  fprintf(fp, "mlayer_spec_file=%s\n", model->config.mlayer_spec_file);
  fprintf(fp, "layer_file_3D=%s\n", model->config.layer_file_3D);
  if(0 == model->config.PDN_padconfig)
    fprintf(fp, "padloc_file_in=%s\n", model->config.padloc_file_in);
  fprintf(fp, "padloc_file_out=%s\n", model->config.padloc_file_out);
  fprintf(fp, "vio_file=%s\n", model->config.vio_file);
  fprintf(fp, "node_viotrace_file=%s\n", model->config.node_viotrace_file);
  fprintf(fp, "trans_vgradient_file=%s\n", model->config.trans_vgradient_file);
  fprintf(fp, "senloc_file=%s\n", model->config.senloc_file);
  fprintf(fp, "padcur_file=%s\n", model->config.padcur_file);
  fprintf(fp, "tsvcur_file=%s\n", model->config.tsvcur_file);
  fprintf(fp, "gridvol_file=%s\n", model->config.gridvol_file);
  fprintf(fp, "END_OF_CONFIGS\n");
}
/* dump all grid voltage to a data file */
void dump_grid_drop(model_t *model, char *file)
{
  int i, j, l;
  int v_grid_idx, g_grid_idx;
  char str[STR_SIZE];
  FILE *fp;
  double max_cur_dense;
  double drop_ratio;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int vs = model->config.v_stacking;
  double *v = model->last_steady;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  if (!strcasecmp(file, "stdout"))
    fp = stdout;
  else if (!strcasecmp(file, "stderr"))
    fp = stderr;
  else 	
    fp = fopen (file, "w");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for writing\n", file);
      fatal(str);
  }
  for(l=0; l < nl; l++){
      fprintf(fp, "#Layer:%d\n", l);
      for(i=0; i < nr; i++){
          for(j=0; j < nc; j++){
              if(!vs){
                  v_grid_idx = l*nr*nc + i*nc + j;
                  g_grid_idx = nl*nr*nc + v_grid_idx;
              }
              else{
                  g_grid_idx = l*2*nr*nc + i*nc + j;
                  v_grid_idx = g_grid_idx + nr*nc;
              }
              drop_ratio = 100*(1-(v[v_grid_idx] - v[g_grid_idx])/(vdd-gnd));
              fprintf(fp, "%d\t%d\t%lf\n", j, nr-i-1, drop_ratio);
          }
      }
      fprintf(fp, "\n");
  }
  if(fp != stdout && fp != stderr)
    fclose(fp);	
}
void dump_violation(model_t *model, status_t *status, char *file)
{
  int i, j;
  char str[STR_SIZE];
  FILE *fp;
  char *name;
  /* shortcuts */
  int nr = model->rows;
  int nc = model->cols;
  int nb = model->layers[0].flp->n_units;
  if (!strcasecmp(file, "stdout"))
    fp = stdout;
  else if (!strcasecmp(file, "stderr"))
    fp = stderr;
  else 	
    fp = fopen (file, "w");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for writing\n", file);
      fatal(str);
  }
  for(i=0; i < nr; i++)
    for(j=0; j < nc; j++){
        fprintf(fp, "%d\t%d\t%d\t%lf\t%lf", j, nr-i-1, 
                status->gridstats.counter_2D[i][j], 
                status->gridstats.integral_2D[i][j],
                status->gridstats.max_2D[i][j]);
        fprintf(fp, "\n");
    }
  fprintf(fp, "-_-b\n");
  for(i=0; i < nb; i++){
      name = model->layers[0].flp->units[i].name;
      fprintf(fp, "%s\t%d\t%lf\n", name, status->blkstats.counter_1D[i],
              status->blkstats.max_1D[i]);
  }
  if(fp != stdout && fp != stderr)
    fclose(fp);	
}
// for transient walking pad
void dump_trans_vgradient(model_t *model,  status_t *status, char *file)
{
  int i, j;
  char str[STR_SIZE];
  FILE *fp;
  FILE *fp_info;
  char *name;
  int brc_idx;
  /* shortcuts */
  int nr = model->rows;
  int nc = model->cols;
  int nbr = 2*nr*nc - nr - nc;
  /* Output important information */
  fp_info = fopen ("trans.info", "w");
  if (!fp_info) 
    {
      printf("Error in opening trans.info\n");
      /* sprintf(str,"error: %s could not be opened for writing\n", "trans.info"); */
      /* fatal(str); */
    }
  fprintf(fp_info, "NC %d\n", nc);
  fprintf(fp_info, "NR %d\n", nr);
  fprintf(fp_info, "GRID_INTV %d\n", model->config.PDN_grid_intv);
  /* fprintf(fp_info, "RX %d\n", nc); */
  /* fprintf(fp_info, "RY %d\n", nc); */
  fclose(fp_info);	
  if (!strcasecmp(file, "stdout"))
    fp = stdout;
  else if (!strcasecmp(file, "stderr"))
    fp = stderr;
  else 	
    fp = fopen (file, "w");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for writing\n", file);
      fatal(str);
  }
  if(stat_counter == 0) stat_counter = -1;
  //VDD
  for(i=0; i<nr; i++){
      for(j=0; j<nc-1; j++){
          brc_idx = i*(nc-1) + j;
          fprintf(fp, "VV\t%d_%d\t%d_%d\t%e\t%e\t%e\n", j, nr-i, j+1, nr-i, status->vgradient.max_1D[brc_idx], status->vgradient.max_1D[brc_idx+nbr*3], sqrt(status->vgradient.max_1D[brc_idx+nbr*6]/(double)(stat_counter)));
      }
  }
  for(i=0; i<nr-1; i++){
      for(j=0; j<nc; j++){
          brc_idx = (nc-1)*nr + i*nc + j;
          fprintf(fp, "VV\t%d_%d\t%d_%d\t%e\t%e\t%e\n", j, nr-i, j, nr-(i+1), status->vgradient.max_1D[brc_idx], status->vgradient.max_1D[brc_idx+nbr*3], sqrt(status->vgradient.max_1D[brc_idx+nbr*6]/(double)(stat_counter)));
      }
  }
  //GND
  for(i=0; i<nr; i++){
      for(j=0; j<nc-1; j++){
          brc_idx = nbr + i*(nc-1) + j;
          fprintf(fp, "GG\t%d_%d\t%d_%d\t%e\t%e\t%e\n", j, nr-i, j+1, nr-i, status->vgradient.max_1D[brc_idx], status->vgradient.max_1D[brc_idx+nbr*3], sqrt(status->vgradient.max_1D[brc_idx+nbr*6]/(double)(stat_counter)));
      }
  }
  for(i=0; i<nr-1; i++){
      for(j=0; j<nc; j++){
          brc_idx = nbr + (nc-1)*nr + i*nc + j;
          fprintf(fp, "GG\t%d_%d\t%d_%d\t%e\t%e\t%e\n", j, nr-i, j, nr-(i+1), status->vgradient.max_1D[brc_idx], status->vgradient.max_1D[brc_idx+nbr*3], sqrt(status->vgradient.max_1D[brc_idx+nbr*6]/(double)(stat_counter)));
      }
  }
  //VDD-GND
  for(i=0; i<nr; i++){
      for(j=0; j<nc-1; j++){
          brc_idx = nbr*2 + i*(nc-1) + j;
          fprintf(fp, "VG\t%d_%d\t%d_%d\t%e\t%e\n", j, nr-i, j+1, nr-i, status->vgradient.max_1D[brc_idx], status->vgradient.max_1D[brc_idx+nbr*3]);
      }
  }
  for(i=0; i<nr-1; i++){
      for(j=0; j<nc; j++){
          brc_idx = nbr*2 + (nc-1)*nr + i*nc + j;
          fprintf(fp, "VG\t%d_%d\t%d_%d\t%e\t%e\n", j, nr-i, j, nr-(i+1), status->vgradient.max_1D[brc_idx], status->vgradient.max_1D[brc_idx+nbr*3]);
      }
  }
  if(fp != stdout && fp != stderr)
    fclose(fp);	
}
//void dump_trans_vgradient(model_t *model,  status_t *status, char *file)
//{
//  int i, j;
//  char str[STR_SIZE];
//  FILE *fp;
//  int brc_idx;
//
//  /* shortcuts */
//  int nr = model->rows;
//  int nc = model->cols;
//  int nbr = 2*nr*nc - nr - nc;
//
//  if (!strcasecmp(file, "stdout"))
//    fp = stdout;
//  else if (!strcasecmp(file, "stderr"))
//    fp = stderr;
//  else 	
//    fp = fopen (file, "w");
//  if (!fp) {
//      sprintf (str,"error: %s could not be opened for writing\n", file);
//      fatal(str);
//  }
//
//  //VDD
//  for(i=0; i<nr; i++){
//      for(j=0; j<nc-1; j++){
//          brc_idx = i*(nc-1) + j;
//          fprintf(fp, "V\t%d_%d\t%d_%d\t%e\n", i, j, i, j+1, status->vgradient.max_1D[brc_idx]);
//      }
//  }
//  for(i=0; i<nr-1; i++){
//      for(j=0; j<nc; j++){
//          brc_idx = (nc-1)*nr + i*nc + j;
//          fprintf(fp, "V\t%d_%d\t%d_%d\t%e\n", i, j, i+1, j, status->vgradient.max_1D[brc_idx]);
//      }
//  }
//
//  //GND
//  for(i=0; i<nr; i++){
//      for(j=0; j<nc-1; j++){
//          brc_idx = nbr + i*(nc-1) + j;
//          fprintf(fp, "G\t%d_%d\t%d_%d\t%e\n", i, j, i, j+1, status->vgradient.max_1D[brc_idx]);
//      }
//  }
//  for(i=0; i<nr-1; i++){
//      for(j=0; j<nc; j++){
//          brc_idx = nbr + (nc-1)*nr + i*nc + j;
//          fprintf(fp, "G\t%d_%d\t%d_%d\t%e\n", i, j, i+1, j, status->vgradient.max_1D[brc_idx]);
//      }
//  }
//
//  if(fp != stdout && fp != stderr)
//    fclose(fp);	
//}
void draw_single_gif(model_t *model, status_t *status, int draw_counter, int mode)
{
  int i, j, l, dum;
  int cur_idx;
  char str[STR_SIZE];
  char posfix[STR_SIZE];
  char file1[STR_SIZE], file2[STR_SIZE];
  FILE *fp1, *fp2;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nvp = model->c4->vdd_num;
  double vdd = model->config.vdd;
  double upr_ratio = model->config.legend_upr;
  double lwr_ratio = model->config.legend_lwr;
  double upr_cur   = model->config.legend_curupr;
  fp1 = fopen ("temp1.dat", "w");
  if (!fp1) {
      sprintf(str,"error: %s could not be opened for writing\n", "temp1.dat");
      fatal(str);
  }
  if(3 == model->config.animation){
      fp2 = fopen ("temp2.dat", "w");
      if (!fp2) {
          sprintf(str,"error: %s could not be opened for writing\n", "temp2.dat");
          fatal(str);
      }
  }
  if(TRANSIENT == mode){
      if(3 == model->config.animation){
          fatal("Do not support current plot for transient yet!\n");
      }
      if(!model->config.PDN_pkgLC)
        fatal("Do not support plotting without pkg yet!\n");
      for(i = 0; i < nr; i++)
        for(j = 0; j < nc; j++){
            fprintf(fp1, "%d\t%d\t%lf\n",j, nr-i-1, 
                    model->last_trans[nvp+i*nc+j]);
        }
  }
  else if(STEADY == mode){
      if(3 == model->config.animation){
          fatal("No longer support steady-state on-chip current plot");
      }
      else{
          l = 0;
          for(i = 0; i < nr; i++)
            for(j = 0; j < nc; j++){
                cur_idx = l*nr*nc + i*nc + j;
                fprintf(fp1, "%d\t%d\t%lf\n",j, nr-i-1, model->last_steady[cur_idx]);
            }
      }
  }
  else
    fatal("Function Call error in single_draw_gif");
  fclose(fp1);	
  if(3 == model->config.animation)
    fclose(fp2);	
  fp1 = fopen ("temp1.gpi", "w");
  if (!fp1) {
      sprintf(str,"error: %s could not be opened for writing\n", "temp1.gpi");
      fatal(str);
  }
  if(3 == model->config.animation){
      fp2 = fopen ("temp2.gpi", "w");
      if (!fp2) {
          sprintf(str,"error: %s could not be opened for writing\n", "temp2.gpi");
          fatal(str);
      }
  }
  int_to_str(draw_counter, 8, posfix);
  sprintf(file1,"frame_%s.1.gif", posfix);
  sprintf(file2,"frame_%s.2.gif", posfix);
  if(1 == model->config.animation){
      fprintf(fp1, "set style rectangle back fc lt -3 fillstyle  solid 1.00 border -1\n");
      fprintf(fp1, "unset key\n");
      fprintf(fp1, "set view map\n");
      fprintf(fp1, "set xtics border in scale 0,0 mirror norotate  offset character 0, 0, 0\n");
      fprintf(fp1, "set ytics border in scale 0,0 mirror norotate  offset character 0, 0, 0\n");
      fprintf(fp1, "set xrange [ 0 : %d ];\n", nc);
      fprintf(fp1, "set yrange [ 0 : %d ];\n", nr);
      fprintf(fp1, "set ylabel  offset character 0, 0, 0 font \"\" textcolor lt -1 rotate by 90\n");
      fprintf(fp1, "set cblabel \"Voltage\" \n");
      fprintf(fp1, "set cblabel  offset character 0, 0, 0 font \"\" textcolor lt -1 rotate by 90\n");
      fprintf(fp1, "set cbrange [ %lf : %lf ] noreverse nowriteback\n", vdd*(1-lwr_ratio), vdd*(1+upr_ratio));
      fprintf(fp1, "set palette rgbformulae 21, 22, 23 \n");
      fprintf(fp1, "set term gif\n");
      fprintf(fp1, "set output \"%s\"\n", file1);
      fprintf(fp1, "plot \"temp1.dat\" using 1:2:3 with image\n");
  }
  else if(2 == model->config.animation){
      fprintf(fp1, "set view 60, 30, 0.85\n");
      fprintf(fp1, "set contour base\n");
      fprintf(fp1, "set dgrid3d %d %d\n", nc, nr);
      fprintf(fp1, "set hidden3d\n");
      fprintf(fp1, "set cntrparam levels auto 10\n");
      fprintf(fp1, "unset key\n");
      fprintf(fp1, "unset xtics\n");
      fprintf(fp1, "unset ytics\n");
      fprintf(fp1, "unset ztics\n");
      fprintf(fp1, "set xrange [ 0 : %d ];\n", nc);
      fprintf(fp1, "set yrange [ 0 : %d ];\n", nr);
      fprintf(fp1, "set zrange [ %lf : %lf ];\n", vdd*(1-lwr_ratio), vdd*(1+upr_ratio));
      fprintf(fp1, "set term gif\n");
      fprintf(fp1, "set output \"%s\"\n", file1);
      fprintf(fp1, "splot \"temp1.dat\" using 1:2:3 with lines\n");
  }
  else if(3 == model->config.animation){
      fprintf(fp1, "set style rectangle back fc lt -3 fillstyle  solid 1.00 border -1\n");
      fprintf(fp1, "unset key\n");
      fprintf(fp1, "set view map\n");
      fprintf(fp1, "set xtics border in scale 0,0 mirror norotate  offset character 0, 0, 0\n");
      fprintf(fp1, "set ytics border in scale 0,0 mirror norotate  offset character 0, 0, 0\n");
      fprintf(fp1, "set xrange [ 0 : %d ];\n", nc);
      fprintf(fp1, "set yrange [ 0 : %d ];\n", nr);
      fprintf(fp1, "set ylabel  offset character 0, 0, 0 font \"\" textcolor lt -1 rotate by 90\n");
      fprintf(fp1, "set cblabel \"Current\" \n");
      fprintf(fp1, "set cblabel  offset character 0, 0, 0 font \"\" textcolor lt -1 rotate by 90\n");
      fprintf(fp1, "set cbrange [ 0 : %lf ] noreverse nowriteback\n", upr_cur);
      fprintf(fp1, "set palette rgbformulae 21, 22, 23 \n");
      fprintf(fp1, "set term gif\n");
      fprintf(fp1, "set output \"%s\"\n", file1);
      fprintf(fp1, "plot \"temp1.dat\" using 1:2:3 with image\n");
      fprintf(fp2, "set style rectangle back fc lt -3 fillstyle  solid 1.00 border -1\n");
      fprintf(fp2, "unset key\n");
      fprintf(fp2, "set view map\n");
      fprintf(fp2, "set xtics border in scale 0,0 mirror norotate  offset character 0, 0, 0\n");
      fprintf(fp2, "set ytics border in scale 0,0 mirror norotate  offset character 0, 0, 0\n");
      fprintf(fp2, "set xrange [ 0 : %d ];\n", nc);
      fprintf(fp2, "set yrange [ 0 : %d ];\n", nr);
      fprintf(fp2, "set ylabel  offset character 0, 0, 0 font \"\" textcolor lt -1 rotate by 90\n");
      fprintf(fp2, "set cblabel \"Current\" \n");
      fprintf(fp2, "set cblabel  offset character 0, 0, 0 font \"\" textcolor lt -1 rotate by 90\n");
      fprintf(fp2, "set cbrange [ 0 : %lf ] noreverse nowriteback\n", upr_cur);
      fprintf(fp2, "set palette rgbformulae 21, 22, 23 \n");
      fprintf(fp2, "set term gif\n");
      fprintf(fp2, "set output \"%s\"\n", file2);
      fprintf(fp2, "plot \"temp2.dat\" using 1:2:3 with image\n");
  }
  fclose(fp1);	
  if(3 == model->config.animation)
    fclose(fp2);	
  dum = system("gnuplot temp1.gpi");
  dum = remove("temp1.dat");
  dum = remove("temp1.gpi");
  if(3 == model->config.animation){
      dum = system("gnuplot temp2.gpi");
      dum = remove("temp2.dat");
      dum = remove("temp2.gpi");
  }
}
void create_animation(int draw_counter, int animation)
{
  int i, dum;
  int delay;
  char file1[STR_SIZE], file2[STR_SIZE];
  char cmd[STR_SIZE], posfix[STR_SIZE];
  delay = 10;
  sprintf(cmd,"gifsicle --delay=%d --loop frame_*.1.gif > anim.1.gif", delay);
  dum = system(cmd);
  for(i=0; i<draw_counter; i++){
      int_to_str(i, 8, posfix);
      sprintf(file1,"frame_%s.1.gif", posfix);
      dum = remove(file1);
  }
  if(3 == animation){
      sprintf(cmd,"gifsicle --delay=%d --loop frame_*.2.gif > anim.2.gif", delay);
      dum = system(cmd);
      for(i=0; i<draw_counter; i++){
          int_to_str(i, 8, posfix);
          sprintf(file2,"frame_%s.2.gif", posfix);
          dum = remove(file2);
      }
  }
}
void dump_tsv_cur(model_t *model, status_t *status, char *file)
{
  int l, i, j;
  char str[STR_SIZE];
  FILE *fp;
  /* shortcuts */
  int nl = model->n_layers;
  int nr = model->rows;
  int nc = model->cols;
  int vs = model->config.v_stacking;
  int **vloc = model->c4->vdd_loc;
  int ntsv = 0;
  for(l=0; l<nl-1; l++){
      ntsv += model->layers[l].tsv.num_gnd;
      ntsv += model->layers[l].tsv.num_vdd;
  }
  if (!strcasecmp(file, "stdout"))
    fp = stdout;
  else if (!strcasecmp(file, "stderr"))
    fp = stderr;
  else 	
    fp = fopen (file, "w");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for writing\n", file);
      fatal(str);
  }
  for(i=0; i<ntsv; i++)
    fprintf(fp, "%e\n", status->TSVcur[i]);
  if(vs){
      fprintf(fp, "\n");
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++)
          for(l=0; l<nl-1; l++)
            if (vloc[i][j] & PGPAD){
                fprintf(fp, "%e\n", status->vdd_cur[i][j]);
            }
  }
  if(fp != stdout && fp != stderr)
    fclose(fp);	
}
</document_content>
</document>
<document index="13">
<source>PDN_analyze.h</source>
<document_content>
#ifndef __PDN_ANALYZE_H_
#define __PDN_ANALYZE_H_
#include "PDN_sim.h"
// sensor location mark
#define SENSOR          1
/* PDN model's per node stats */
typedef struct node_stats_t_st
{
  int **counter_2D;
  double **max_2D;
  double **prev_2D;
  double **integral_2D;
  int *counter_1D;
  double *max_1D;
  double *integral_1D;
}node_stats_t;
typedef struct status_st 
{
  int trans_counter;
  int draw_counter;
  double maxdroop;
  double *layer_maxdroop;
  double *maxIR;
  double PDN_power;
  double *TSVcur;
  double *maxTSVcur;
  double sumcur;
  double curIc, avgIc, dIc;
  double curVc, avgVc;
  double vio_area_ratio;
  double pkgDrop;
  double prevIc;
  double prevVc;
	/* pad current	*/
	double **vdd_cur;
	double **gnd_cur;
  double maxcur_vdd, maxcur_gnd;
  double max_pad_dense;
  int    curIth; //# of pads that current exceed threshold
  int    curIth_vdd, curIth_gnd;
	/* sensor location */
  int **sensor_loc;
  double **sensor_noise;
	/* For averaging results per cycle */
  double *cycle_avg;
	/* voltage stats holder */
  node_stats_t gridstats;
  node_stats_t blkstats;
  node_stats_t corestats;
	/* grid voltage gradient record */
  node_stats_t vgradient;
}status_t;
/* Init */
status_t *alloc_status(model_t *model);
void populate_status(model_t *model, status_t *status);
void free_status(model_t *model, status_t *status);
/* Analyze data in PDN */
void PDN_steady_analyze(model_t *model, status_t *status);
void PDN_trans_analyze(model_t *model, status_t *status);
void print_step_singlenode(model_t *model, FILE *fp, int pi, int pj);
void print_status_singlenode(model_t *model, status_t *status, FILE *fp, int pi, int pj);
void print_trans_analyze(model_t *model, status_t *status, FILE *fp);
void print_trans_header(model_t *model, status_t *status, FILE *fp);
void print_steady_analyze(model_t *model, status_t *status);
void get_pad_current(model_t *model, status_t *status);
void get_TSV_current(model_t *model, status_t *status);
double get_steady_PDN_power(model_t *model);
void get_maxIR(model_t *model, double *maxIR);
void onchipV_analyze_2D(model_t *model, status_t *status);
void onchipV_analyze_3D(model_t *model, status_t *status);
void perstep_droop_3D(model_t *model, FILE *fp);
void trans_vgradient_analyze(model_t *model, status_t *status);
/* voltage sensing */
void parse_sensor_loc(model_t *model, status_t *status, char *file);
/* dump data */
void dump_files(model_t *model, status_t *status, int mode);
void dump_PDN_config(model_t *model, FILE *fp);
void dump_grid_drop(model_t *model, char *file);
void dump_violation(model_t *model, status_t *status, char *file);
void dump_trans_vgradient(model_t *model,  status_t *status, char *file);
void dump_tsv_cur(model_t *model, status_t *status, char *file);
/* Animation */
void draw_single_gif(model_t *model, status_t *status, int draw_counter, int mode);
void create_animation(int draw_counter, int animation);
#endif
</document_content>
</document>
<document index="14">
<source>PDN_sim.c</source>
<document_content>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <math.h>
#include <assert.h>
/* Lib for SuperLU */
#include "slu_ddefs.h"
#include "PDN_sim.h"
#include "flp.h"
#include "util.h"
#include "pad.h"
/* default PDN configuration parameters	*/
PDN_config_t default_PDN_config(void)
{
  PDN_config_t config;
  config.run_PDN = 0; 
  config.PDN_padconfig     = 1;
  config.padloc_format     = 1;
  config.reserve_io        = 0;
  config.PDN_grid_intv     = 5;
  config.PDN_pkgLC         = 1;
  config.PDN_gridL         = 1;
  config.vgradient_analyse = 0;
  config.PDN_padpitch      = 285e-6;
  config.PDN_padD          = 130e-6;
  config.PDN_padR          = 10e-3;
  config.vdd = 1;
  config.gnd = 0;
  config.proc_clock_freq = 3.7e9;
  config.PDN_step_percycle = 5;
  config.ptrace_sampling_intvl = 1;
  config.PDN_ptrace_warmup  = 0;
  config.PDN_decap_dense  = 12;
  config.PDN_decap_ratio  = 0.3;
  config.PDN_decap_unifm  = 0;
  config.PDN_padL   = 72e-12;
  config.PDN_pkg_sL = 120e-12;
  config.PDN_pkg_sR = 1e-3;
  config.PDN_pkg_C  = 26e-6;
  config.PDN_pkg_pR = 0.54e-3;
  config.PDN_pkg_pL = 5.61e-12;
  config.PDN_pkg_scale = 1;
  config.v_stacking      = 0;
  config.TSV_config      = 1;
  config.TSV_R           = 46.85e-3;
  config.TSV_L           = 34.262e-12;
  strcpy(config.layer_file_3D, NULLFILE);
  strcpy(config.IVR_loc_file, NULLFILE);
  config.SC_freq = 50e6;
  config.SC_totcap = 8e-9;
  config.SC_Rontop = 1.052;
  config.SC_Ronbtm = 1.17;
  config.PDN_multi_dom   = 0; 
  config.animation       = 0; 
  config.frame_intv      = 5; 
  config.legend_lwr      = 0.05; 
  config.legend_upr      = 0.05; 
  config.legend_curupr   = 0.02; 
  config.PDN_sin_pattern = 0; 
  config.PDN_sin_totstep = 10000; 
  config.PDN_sin_freq    = 100e6; 
  strcpy(config.mlayer_spec_file, NULLFILE);
  strcpy(config.padloc_file_in, NULLFILE);
  strcpy(config.padloc_file_out, NULLFILE);
  strcpy(config.vio_file, NULLFILE);
  strcpy(config.node_viotrace_file, NULLFILE);
  strcpy(config.trans_vgradient_file, NULLFILE);
  strcpy(config.senloc_file, NULLFILE);
  strcpy(config.padcur_file, NULLFILE);
  strcpy(config.tsvcur_file, NULLFILE);
  strcpy(config.gridvol_file, NULLFILE);
  config.MC_pads      = 80; 
  config.IO_dense     = 0.8; 
  config.PDN_cur_dense= 8.5e7; 
  config.PDN_noise_th = 5; 
  return config;
}
/* 
 * parse a table of name-value string pairs and add the configuration
 * parameters to 'config'
 */
void PDN_config_add_from_strs(PDN_config_t *config, str_pair *table, int size)
{
  int idx;
  if ((idx = get_str_index(table, size, "run_PDN")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->run_PDN) != 1)
      fatal("invalid format for configuration  parameter run_PDN\n");
  if ((idx = get_str_index(table, size, "PDN_padconfig")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->PDN_padconfig) != 1)
      fatal("invalid format for configuration  parameter PDN_padconfig\n");
  if ((idx = get_str_index(table, size, "padloc_format")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->padloc_format) != 1)
      fatal("invalid format for configuration  parameter padloc_format\n");
  if ((idx = get_str_index(table, size, "reserve_io")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->reserve_io) != 1)
      fatal("invalid format for configuration  parameter reserve_io\n");
  if ((idx = get_str_index(table, size, "PDN_grid_intv")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->PDN_grid_intv) != 1)
      fatal("invalid format for configuration  parameter PDN_grid_intv\n");
  if ((idx = get_str_index(table, size, "PDN_pkgLC")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->PDN_pkgLC) != 1)
      fatal("invalid format for configuration  parameter PDN_pkgLC\n");
  if ((idx = get_str_index(table, size, "PDN_gridL")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->PDN_gridL) != 1)
      fatal("invalid format for configuration  parameter PDN_gridL\n");
  if ((idx = get_str_index(table, size, "vgradient_analyse")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->vgradient_analyse) != 1)
      fatal("invalid format for configuration  parameter vgradient_analyse\n");
  if ((idx = get_str_index(table, size, "PDN_padpitch")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_padpitch) != 1)
      fatal("invalid format for configuration  parameter PDN_padpitch\n");
  if ((idx = get_str_index(table, size, "PDN_padD")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_padD) != 1)
      fatal("invalid format for configuration  parameter PDN_padD\n");
  if ((idx = get_str_index(table, size, "PDN_padR")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_padR) != 1)
      fatal("invalid format for configuration  parameter PDN_padR\n");
  if ((idx = get_str_index(table, size, "vdd")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->vdd) != 1)
      fatal("invalid format for configuration  parameter vdd\n");
  if ((idx = get_str_index(table, size, "gnd")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->gnd) != 1)
      fatal("invalid format for configuration  parameter gnd\n");
  if ((idx = get_str_index(table, size, "padloc_file_in")) >= 0)
    if(sscanf(table[idx].value, "%s", config->padloc_file_in) != 1)
      fatal("invalid format for configuration  parameter padloc_file_in\n");
  if ((idx = get_str_index(table, size, "padloc_file_out")) >= 0)
    if(sscanf(table[idx].value, "%s", config->padloc_file_out) != 1)
      fatal("invalid format for configuration  parameter padloc_file_out\n");
  if ((idx = get_str_index(table, size, "vio_file")) >= 0)
    if(sscanf(table[idx].value, "%s", config->vio_file) != 1)
      fatal("invalid format for configuration  parameter vio_file\n");
  if ((idx = get_str_index(table, size, "node_viotrace_file")) >= 0)
    if(sscanf(table[idx].value, "%s", config->node_viotrace_file) != 1)
      fatal("invalid format for configuration  parameter node_viotrace_file\n");
  if ((idx = get_str_index(table, size, "trans_vgradient_file")) >= 0)
    if(sscanf(table[idx].value, "%s", config->trans_vgradient_file) != 1)
      fatal("invalid format for configuration  parameter trans_vgradient_file\n");
  if ((idx = get_str_index(table, size, "senloc_file")) >= 0)
    if(sscanf(table[idx].value, "%s", config->senloc_file) != 1)
      fatal("invalid format for configuration  parameter senloc_file\n");
  if ((idx = get_str_index(table, size, "mlayer_spec_file")) >= 0)
    if(sscanf(table[idx].value, "%s", config->mlayer_spec_file) != 1)
      fatal("invalid format for configuration  parameter mlayer_spec_file\n");
  if ((idx = get_str_index(table, size, "layer_file_3D")) >= 0)
    if(sscanf(table[idx].value, "%s", config->layer_file_3D) != 1)
      fatal("invalid format for configuration  parameter layer_file_3D\n");
  if ((idx = get_str_index(table, size, "v_stacking")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->v_stacking) != 1)
      fatal("invalid format for configuration  parameter v_stacking\n");
  if ((idx = get_str_index(table, size, "TSV_config")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->TSV_config) != 1)
      fatal("invalid format for configuration  parameter TSV_config\n");
  if ((idx = get_str_index(table, size, "TSV_R")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->TSV_R) != 1)
      fatal("invalid format for configuration  parameter TSV_R\n");
  if ((idx = get_str_index(table, size, "TSV_L")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->TSV_L) != 1)
      fatal("invalid format for configuration  parameter TSV_L\n");
  if ((idx = get_str_index(table, size, "IVR_loc_file")) >= 0)
    if(sscanf(table[idx].value, "%s", config->IVR_loc_file) != 1)
      fatal("invalid format for configuration  parameter IVR_loc_file\n");
  if ((idx = get_str_index(table, size, "padcur_file")) >= 0)
    if(sscanf(table[idx].value, "%s", config->padcur_file) != 1)
      fatal("invalid format for configuration  parameter padcur_file\n");
  if ((idx = get_str_index(table, size, "tsvcur_file")) >= 0)
    if(sscanf(table[idx].value, "%s", config->tsvcur_file) != 1)
      fatal("invalid format for configuration  parameter tsvcur_file\n");
  if ((idx = get_str_index(table, size, "gridvol_file")) >= 0)
    if(sscanf(table[idx].value, "%s", config->gridvol_file) != 1)
      fatal("invalid format for configuration  parameter gridvol_file\n");
  if ((idx = get_str_index(table, size, "PDN_cur_dense")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_cur_dense) != 1)
      fatal("invalid format for configuration  parameter PDN_cur_dense\n");
  if ((idx = get_str_index(table, size, "PDN_multi_dom")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->PDN_multi_dom) != 1)
      fatal("invalid format for configuration  parameter PDN_multi_dom\n");
  if ((idx = get_str_index(table, size, "animation")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->animation) != 1)
      fatal("invalid format for configuration  parameter animation\n");
  if ((idx = get_str_index(table, size, "frame_intv")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->frame_intv) != 1)
      fatal("invalid format for configuration  parameter frame_intv\n");
  if ((idx = get_str_index(table, size, "legend_lwr")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->legend_lwr) != 1)
      fatal("invalid format for configuration  parameter legend_lwr\n");
  if ((idx = get_str_index(table, size, "legend_upr")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->legend_upr) != 1)
      fatal("invalid format for configuration  parameter legend_upr\n");
  if ((idx = get_str_index(table, size, "legend_curupr")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->legend_curupr) != 1)
      fatal("invalid format for configuration  parameter legend_curupr\n");
  if ((idx = get_str_index(table, size, "PDN_sin_pattern")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->PDN_sin_pattern) != 1)
      fatal("invalid format for configuration  parameter PDN_sin_pattern\n");
  if ((idx = get_str_index(table, size, "PDN_sin_totstep")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->PDN_sin_totstep) != 1)
      fatal("invalid format for configuration  parameter PDN_sin_totstep\n");
  if ((idx = get_str_index(table, size, "PDN_sin_freq")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_sin_freq) != 1)
      fatal("invalid format for configuration  parameter PDN_sin_freq\n");
  if ((idx = get_str_index(table, size, "PDN_noise_th")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_noise_th) != 1)
      fatal("invalid format for configuration  parameter PDN_noise_th\n");
  if ((idx = get_str_index(table, size, "MC_pads")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->MC_pads) != 1)
      fatal("invalid format for configuration  parameter MC_pads\n");
  if ((idx = get_str_index(table, size, "IO_dense")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->IO_dense) != 1)
      fatal("invalid format for configuration  parameter IO_dense\n");
  if ((idx = get_str_index(table, size, "PDN_step_percycle")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->PDN_step_percycle) != 1)
      fatal("invalid format for configuration  parameter PDN_step_percycle\n");
  if ((idx = get_str_index(table, size, "proc_clock_freq")) >= 0)
    if(sscanf(table[idx].value, "%le", &config->proc_clock_freq) != 1)
      fatal("invalid format for configuration  parameter proc_clock_freq\n");
  if ((idx = get_str_index(table, size, "ptrace_sampling_intvl")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->ptrace_sampling_intvl) != 1)
      fatal("invalid format for configuration  parameter ptrace_sampling_intvl\n");
  if ((idx = get_str_index(table, size, "PDN_ptrace_warmup")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->PDN_ptrace_warmup) != 1)
      fatal("invalid format for configuration  parameter PDN_ptrace_warmup\n");
  if ((idx = get_str_index(table, size, "PDN_decap_dense")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_decap_dense) != 1)
      fatal("invalid format for configuration  parameter PDN_decap_dense\n");
  if ((idx = get_str_index(table, size, "PDN_decap_ratio")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_decap_ratio) != 1)
      fatal("invalid format for configuration  parameter PDN_decap_ratio\n");
  if ((idx = get_str_index(table, size, "PDN_decap_unifm")) >= 0)
    if(sscanf(table[idx].value, "%d", &config->PDN_decap_unifm) != 1)
      fatal("invalid format for configuration  parameter PDN_decap_unifm\n");
  if ((idx = get_str_index(table, size, "PDN_padL")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_padL) != 1)
      fatal("invalid format for configuration  parameter PDN_padL\n");
  if ((idx = get_str_index(table, size, "PDN_pkg_sL")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_pkg_sL) != 1)
      fatal("invalid format for configuration  parameter PDN_pkg_sL\n");
  if ((idx = get_str_index(table, size, "PDN_pkg_sR")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_pkg_sR) != 1)
      fatal("invalid format for configuration  parameter PDN_pkg_sR\n");
  if ((idx = get_str_index(table, size, "PDN_pkg_C")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_pkg_C) != 1)
      fatal("invalid format for configuration  parameter PDN_pkg_C\n");
  if ((idx = get_str_index(table, size, "PDN_pkg_pR")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_pkg_pR) != 1)
      fatal("invalid format for configuration  parameter PDN_pkg_pR\n");
  if ((idx = get_str_index(table, size, "PDN_pkg_pL")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_pkg_pL) != 1)
      fatal("invalid format for configuration  parameter PDN_pkg_pL\n");
  if ((idx = get_str_index(table, size, "PDN_pkg_scale")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->PDN_pkg_scale) != 1)
      fatal("invalid format for configuration  parameter PDN_pkg_scale\n");
  if ((idx = get_str_index(table, size, "SC_freq")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->SC_freq) != 1)
      fatal("invalid format for configuration  parameter SC_freq\n");
  if ((idx = get_str_index(table, size, "SC_totcap")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->SC_totcap) != 1)
      fatal("invalid format for configuration  parameter SC_totcap\n");
  if ((idx = get_str_index(table, size, "SC_Rontop")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->SC_Rontop) != 1)
      fatal("invalid format for configuration  parameter SC_Rontop\n");
  if ((idx = get_str_index(table, size, "SC_Ronbtm")) >= 0)
    if(sscanf(table[idx].value, "%lf", &config->SC_Ronbtm) != 1)
      fatal("invalid format for configuration  parameter SC_Ronbtm\n");
  if (config->PDN_grid_intv < 1)
    fatal("PDN grid intv option should not be zero or negative!!\n");
  if (config->run_PDN < 0 || config->run_PDN > 2 )
    fatal("run_PDN should be 0, 1 or 2\n");
  if (config->PDN_padD <= 0)
    fatal("PDN pad diameter should be greater than 0\n");
  if (config->PDN_padR <= 0)
    fatal("PDN pad resistivity should be greater than 0\n");
  if (config->PDN_pkgLC != 0 && config->PDN_pkgLC != 1)
    fatal("PDN_pkgLC shoud be either 0 or 1\n");
  if (config->PDN_gridL != 0 && config->PDN_gridL != 1)
    fatal("PDN_gridL shoud be either 0 or 1\n");
  if (config->vgradient_analyse != 0 && config->vgradient_analyse != 1)
    fatal("vgradient_analyse shoud be either 0 or 1\n");
  if (config->PDN_padconfig < 0 || config->PDN_padconfig >= PADCONFIGS)
    fatal("Invalid PDN_padconfig input!\n");
  if (config->TSV_config < 0 || config->TSV_config >= TSVCONFIGS)
    fatal("Invalid TSV_config input!\n");
  if (config->TSV_R < 0)
    fatal("TSV_R should be larger than 0!\n");
  if (config->TSV_L < 0)
    fatal("TSV_L should be larger than 0!\n");
  if (config->v_stacking < 0 || config->v_stacking > 1)
    fatal("Invalid v_stacking input!\n");
  if (config->padloc_format < 0 || config->padloc_format > 3)
    fatal("Invalid padloc_format input!\n");
  if (config->reserve_io < 0 || config->reserve_io > 3)
    fatal("reserve_io should be 1/0!\n");
  if (config->PDN_cur_dense <= 0 )
    fatal("PDN_cur_dense should be larger than 0\n");
  if (config->PDN_multi_dom < -1)
    fatal("PDN_multi_dom should be greater than -1\n");
  if (config->PDN_decap_unifm < 0)
    fatal("PDN_decap_unifm should be greater than or equal to 0\n");
  if (config->animation < 0 || config->animation > 3)
    fatal("animation should be either 0 or 1\n");
  if (config->frame_intv < 0)
    fatal("frame_intv should be greater than 0\n");
  if (config->PDN_sin_pattern < 0 || config->PDN_sin_pattern > 1)
    fatal("PDN_sin_pattern should be either 0 or 1\n");
  if (config->PDN_sin_totstep < 0)
    fatal("PDN_sin_totstep should be larger than 0 \n");
  if (config->PDN_sin_freq < 0)
    fatal("PDN_sin_freq should be greater than 0\n");
  if (config->vdd < config->gnd)
    fatal("vdd should be larger than gnd\n");
  if (config->PDN_noise_th < 0)
    fatal("PDN_noise_th should be greater than 0!\n");
  if (config->MC_pads < 0)
    fatal("MC_pads should be equal or larger than 0!\n");
  if (config->IO_dense <= 0 || config->IO_dense > 1)
    fatal("IO_dense should be between 0 and 1 (!=0)!\n");
  if (config->ptrace_sampling_intvl <= 0)
    fatal("PDN ptrace interval should be greater than 0\n");
  if (config->PDN_step_percycle<= 0)
    fatal("PDN transient timestep should be greater than 0\n");
  if (config->proc_clock_freq<= 0)
    fatal("PDN clock freq should be greater than 0\n");
  if (config->PDN_ptrace_warmup < 0)
    fatal("PDN warm up time should be larger than 0\n");
  if (config->PDN_decap_dense <= 0)
    fatal("PDN decap density should be greater than 0\n");
  if (config->PDN_decap_ratio <= 0 || config->PDN_decap_ratio > 1)
    fatal("PDN decap ratio should within (0,1] \n");
  if (config->PDN_padL <= 0)
    fatal("PDN pad L should be greater than 0\n");
  if (config->PDN_pkg_sL <= 0)
    fatal("PDN package L should be greater than 0\n");
  if (config->PDN_pkg_sR < 0)
    fatal("PDN package R should be greater than 0\n");
  if (config->PDN_pkg_C <= 0)
    fatal("PDN package C should be greater than 0\n");
  if (config->PDN_pkg_pR <= 0)
    fatal("PDN package parallel R should be greater than 0\n");
  if (config->PDN_pkg_pL <= 0)
    fatal("PDN package parallel L should be greater than 0\n");
  if (config->PDN_pkg_scale <= 0)
    fatal("PDN package scale should be greater than 0\n");
  if (config->SC_freq <= 0)
    fatal("SC frequency should be greater than 0\n");
  if (config->SC_totcap <= 0)
    fatal("SC total cap should be greater than 0\n");
  if (config->SC_Rontop <= 0)
    fatal("SC Ron_top should be greater than 0\n");
  if (config->SC_Ronbtm <= 0)
    fatal("SC Ron_btm should be greater than 0\n");
}
/* constructor also initilize parameters	*/ 
model_t *alloc_model(PDN_config_t *config, PDN_flp_t *flp_default)
{
  int i;
  int pad_grid_col, pad_grid_row;
  model_t *model;
  model = (model_t *) calloc (1, sizeof(model_t));
  if (!model)
    fatal("memory allocation error\n");
  model->config = *config;
  model->width = PDN_get_total_width(flp_default);
  model->height = PDN_get_total_height(flp_default);
  pad_grid_col = floor(model->width / (model->config.PDN_padpitch));
  pad_grid_row = floor(model->height / (model->config.PDN_padpitch));
  if(!pad_grid_row | !pad_grid_col)
    fatal("Pad pithch is lager than chip scale, please fix!\n");
  model->rows = model->config.PDN_grid_intv * (pad_grid_row - 1) + 1;
  model->cols = model->config.PDN_grid_intv * (pad_grid_col - 1) + 1;
  // Sanity check on problem size
  // Force exit if grid size is too large
  if((model->rows < 0) || (model->cols < 0))
    fatal("On-chip grid size calculation overflow! Check your floorplan unit (Should all in meter, not mm or um).\n");
  if((pad_grid_col == 1) && (pad_grid_row == 1))
    fatal("This design only has one C4 pad! Please double-check your floorplan and/or C4 pad pitch\n");
  if((model->rows > MAX_DIM) || (model->cols > MAX_DIM))
    fatal("Problem size exceeding limit!\nCheck your floorplan unit (Should all in meter, not mm or um)\nIf you do want to specify a problem that large, please override this assertion in function alloc_model\n");
  /* set C4 pads */
  model->c4 = alloc_C4_PDN(model, pad_grid_col, pad_grid_row);
  if(strcmp(model->config.layer_file_3D, NULLFILE))
    model->is_3D = TRUE;
  else
    model->is_3D = FALSE;
  /* get layer information	*/
  alloc_layers_PDN(model, flp_default);
  if(model->config.v_stacking)
    model->sc_converter = alloc_IVR(model);
  /* count the total no. of blocks */
  model->total_n_blocks = 0;
  for(i=0; i<model->n_layers; i++){
      model->total_n_blocks += model->layers[i].flp->n_units;
  }
  /* allocate internal state	*/
  /* Two extra nodes for package, each layer has two grid */
  model->last_steady = dvector(2*model->rows*model->cols*model->n_layers + PDN_STEADY_EXTRA);
  model->last_power = dvector(model->rows*model->cols*model->n_layers);
  return model;
}
PDN_metal_t alloc_metal_layers(int n_metal)
{
  PDN_metal_t metal_layers;
  metal_layers.n_metal = n_metal;
  metal_layers.geo     = (metal_geo_t *) calloc (n_metal, sizeof(metal_geo_t));
  metal_layers.gridRL  = (metal_gridRL_t *) calloc (n_metal, sizeof(metal_gridRL_t));
  return metal_layers;
}
void set_current_limit(model_t *model)
{
  double padD, padR;
  double dense;
  padD = model->config.PDN_padD;
  padR = padD / 2;
  dense= model->config.PDN_cur_dense;
  model->c4->Ith = dense * PI * padR * padR;
}
void alloc_layers_PDN(model_t *model, PDN_flp_t *flp_default)
{
  int i;
	FILE *fp = NULL;
	char str[STR_SIZE];
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  if (model->is_3D){
		if (!strcasecmp(model->config.layer_file_3D, "stdin"))
			fp = stdin;
		else
			fp = fopen (model->config.layer_file_3D, "r");
		if (!fp) {
			sprintf(str, "error opening lcf file %s\n", model->config.layer_file_3D);
			fatal(str);
		}
  }
  /* compute the no. of layers	*/
  if (model->is_3D){
      model->n_layers = count_significant_lines(fp);
      if (model->n_layers % LCF_3D_NPARAMS)
        fatal("wrong no. of lines in layer file\n");
      model->n_layers /= LCF_3D_NPARAMS;
  }
  else
    model->n_layers = 1;
  /* allocate initial memory */
  model->layers = (PDN_layer_t *) calloc (model->n_layers, sizeof(PDN_layer_t));
  if (!model->layers)
    fatal("memory allocation error\n");
	/* populate layers */
  if (model->is_3D){
		parse_layer_file_PDN(model, fp);
		warning("3D layer configuration file specified. overriding default floorplan with those in lcf file, but requires default flp and flps in lcf file have same width and height...\n");
  }
  else
    populate_single_layer_PDN(model, flp_default);
  /* allocate cap and set bgmap*/
  for(i=0; i<model->n_layers; i++){
      model->layers[i].cap_c = dmatrix(nr, nc);
      zero_dvector(model->layers[i].cap_c[0], nr*nc);
      set_bgmap_PDN(model, &model->layers[i]);
  }
  if (model->is_3D && fp != stdin)
    fclose(fp);
}
IVR_t *alloc_IVR(model_t *model)
{
  IVR_t *ivr;
  ivr = (IVR_t *) calloc (1, sizeof(IVR_t));
  ivr->loc = imatrix(model->rows, model->cols);
  zero_ivector(ivr->loc[0], model->rows*model->cols);
  return ivr;
}
void populate_IVR(model_t *model)
{
  int i, j;
  int counter = 0;
  int nr = model->rows;
  int nc = model->cols;
  IVR_t *v = model->sc_converter;
  if(strcmp(model->config.IVR_loc_file, NULLFILE))
    parse_IVR_loc(model, model->config.IVR_loc_file);
  for(i=0; i<nr; i++)
    for(j=0; j<nc; j++) {
        if(IVRLOC == v->loc[i][j])
          counter++;
    }
  v->num_IVR = counter;
  v->freq = 2*2*model->config.SC_freq;
}
void populate_single_layer_PDN(model_t *model, PDN_flp_t *flp_default)
{
  int num_layer;
  FILE *fp = NULL;
  char str[STR_SIZE];
  if(strcmp(model->config.mlayer_spec_file, NULLFILE)){
      fp = fopen(model->config.mlayer_spec_file, "r");
      if(!fp) {
          sprintf(str, "error opening mlayer_spec file %s\n", model->config.mlayer_spec_file);
          fatal(str);
      }
      num_layer = count_significant_lines(fp);
      if (num_layer % MLCF_NPARAMS)
        fatal("wrong no. of lines in metal layer file\n");
      num_layer /= MLCF_NPARAMS;
      fclose(fp);
  }
  else
    num_layer = DEFAULT_MLAYERS;
  model->layers[0].no = 0;
  model->layers[0].flp = flp_default;
  model->layers[0].metal_layers = alloc_metal_layers(num_layer);
  model->layers[0].b2gmap = new_b2gmap_PDN(model->rows, model->cols);
  if(strcmp(model->config.mlayer_spec_file, NULLFILE))
    parse_metal_layer_file(model, model->config.mlayer_spec_file, 0);
  else
    populate_default_mlayers(model, 0);
}
void populate_default_mlayers(model_t *model, int layer)
{
  model->layers[0].metal_layers.geo[0].pitch = 30e-6;
  model->layers[0].metal_layers.geo[0].width = 10e-6;
  model->layers[0].metal_layers.geo[0].thick = 3.5e-6;
  model->layers[0].metal_layers.geo[0].rho   = 1.68e-8;
  model->layers[0].metal_layers.geo[0].direc = MLCF_X;
  model->layers[0].metal_layers.geo[1].pitch = 30e-6;
  model->layers[0].metal_layers.geo[1].width = 10e-6;
  model->layers[0].metal_layers.geo[1].thick = 3.5e-6;
  model->layers[0].metal_layers.geo[1].rho   = 1.68e-8;
  model->layers[0].metal_layers.geo[1].direc = MLCF_Y;
  model->layers[0].metal_layers.geo[2].pitch = 810e-9;
  model->layers[0].metal_layers.geo[2].width = 400e-9;
  model->layers[0].metal_layers.geo[2].thick = 720e-9;
  model->layers[0].metal_layers.geo[2].rho   = 1.68e-8;
  model->layers[0].metal_layers.geo[2].direc = MLCF_X;
  model->layers[0].metal_layers.geo[3].pitch = 810e-9;
  model->layers[0].metal_layers.geo[3].width = 400e-9;
  model->layers[0].metal_layers.geo[3].thick = 720e-9;
  model->layers[0].metal_layers.geo[3].rho   = 1.68e-8;
  model->layers[0].metal_layers.geo[3].direc = MLCF_Y;
}
void populate_R_model_PDN(model_t *model)
{
  int i, l;
  int metal_grid_col, metal_grid_row;
  double pitch, width, thick, rho;
  int direc;
  /* short cuts */
  int nl = model->n_layers;
  double cw = model->width;
  double ch = model->height;
  double nr = model->rows;
  double nc = model->cols;
  int vs = model->config.v_stacking;
  /* layer specific resistances	
   * R = rho * lenth / Cross-sectional area
   */
  for(l=0; l<nl; l++)
    for(i=0; i<model->layers[l].metal_layers.n_metal; i++){
        pitch = model->layers[l].metal_layers.geo[i].pitch;
        width = model->layers[l].metal_layers.geo[i].width;
        thick = model->layers[l].metal_layers.geo[i].thick;
        rho   = model->layers[l].metal_layers.geo[i].rho;
        direc = model->layers[l].metal_layers.geo[i].direc;
        metal_grid_col = floor(cw/(2*pitch));
        metal_grid_row = floor(ch/(2*pitch));
        if(MLCF_X == direc){
            model->layers[l].metal_layers.gridRL[i].r = 
              (1/(nc-1))*(nr/metal_grid_row) * (rho*cw/(width*thick));
        }
        else{
            model->layers[l].metal_layers.gridRL[i].r = 
              (1/(nr-1))*(nc/metal_grid_col) * (rho*ch/(width*thick));
        }
    }
  // TSV resistance
  if(model->is_3D){
      for(l=0; l<nl; l++){
          model->layers[l].tsv.r = model->config.TSV_R;
      }
  }
  // C4 resistance
  model->c4->pad_r = model->config.PDN_padR; 
  // IVR resistance
  if(vs){
      model->sc_converter->R_drop = 0.46;
      model->sc_converter->Ron_top = 2*model->config.SC_Rontop;
      model->sc_converter->Ron_bottom = 2*model->config.SC_Ronbtm;
  }
  // scale pkg parameter for mtdmn "block" model
  model->config.PDN_pkg_sR *= model->config.PDN_pkg_scale; 
}
void populate_LC_model_PDN(model_t *model)
{
  int i, j, l, d;
  double w, t, s, p;
  double mgc, mgr;
  int decap_count_hot = 0;
  int decap_count_cold = 0;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int vs = model->config.v_stacking;
  double cw = model->width;
  double ch = model->height;
  double tot_decap, tot_ldcap, decap_percell_hot, decap_percell_cold, ldcap_percell;
  /* package LC's	*/
  // scale pkg parameter for mtdmn "block" model
  model->config.PDN_pkg_sL *= model->config.PDN_pkg_scale; 
  model->config.PDN_pkg_C  /= model->config.PDN_pkg_scale; 
  model->config.PDN_pkg_pR *= model->config.PDN_pkg_scale; 
  model->config.PDN_pkg_pL *= model->config.PDN_pkg_scale; 
  /* Total load cap is estimated from equation W = alpha*f*C*V2 */
  tot_ldcap = 16.4e-8 / model->config.PDN_pkg_scale;
  //tot_ldcap = 5e-8 / model->config.PDN_pkg_scale;
  ldcap_percell = (2*tot_ldcap) / (nr*nc); // all cell has load cap, x2 for two grid
  /* Total decap is calculated based on user input */
  tot_decap = model->config.PDN_decap_dense * \
              model->config.PDN_decap_ratio * \
              model->height * model->width * \
              (1.0e-9 / 1.0e-6);
  for(l=0; l<nl; l++)
    for(i=0; i<nr; i++)
      for(j=0; j<nc; j++){
          if(decap_under_blk(model, (i*nc+j), l))
            decap_count_hot++;
          else
            decap_count_cold++;
      }
  if (model->config.PDN_decap_unifm > 0){
          decap_percell_hot = (2*tot_decap*LOCAL_CAP_RATIO ) / (decap_count_hot);
          decap_percell_cold = (2*tot_decap*(1-LOCAL_CAP_RATIO)) / (decap_count_cold);
  }
  /* layer specific capacitances	*/
  for(l=0; l<nl; l++){
      // Place all decap around designated area
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++) {
            if(0 == model->config.PDN_decap_unifm){
                if(model->is_3D)
                  model->layers[l].cap_c[i][j] = (tot_decap+tot_ldcap)/(nr*nc);
                else
                  model->layers[l].cap_c[i][j] = (2*(tot_decap+tot_ldcap))/(nr*nc);
            }
            else{
                if(decap_under_blk(model, (i*nc+j), l)){
                    model->layers[l].cap_c[i][j] = decap_percell_hot + ldcap_percell;
                }
                else{
                    model->layers[l].cap_c[i][j] = decap_percell_cold + ldcap_percell;
                }
            }
        }
  }
  // TSV LC
  if(model->is_3D){
      for(l=0; l<nl; l++){
          model->layers[l].tsv.l = model->config.TSV_L;
      }
  }
  /* IVR C */
  if(vs){
      model->sc_converter->c = model->config.SC_totcap/2;
  }
  /* pad L */
  model->c4->pad_l = model->config.PDN_padL;
  /* on-chip L */
  for(l=0; l<nl; l++)
    for(i=0; i<model->layers[l].metal_layers.n_metal; i++) {
        p  = model->layers[l].metal_layers.geo[i].pitch;
        w  = model->layers[l].metal_layers.geo[i].width;
        t  = model->layers[l].metal_layers.geo[i].thick;
        s  = model->layers[l].metal_layers.geo[i].pitch - 
          model->layers[l].metal_layers.geo[i].width;
        d  = model->layers[l].metal_layers.geo[i].direc;
        mgc = floor(cw/(2*p));
        mgr = floor(ch/(2*p));
        if(MLCF_X == d){
            model->layers[l].metal_layers.gridRL[i].l = 
              (cw/(nc-1))*(nr/mgr)*(1/PI)*VAPER*(1.5+log(2/PI)+log((w+s)/(w+t)));
        }
        else{
            model->layers[l].metal_layers.gridRL[i].l = 
              (ch/(nr-1))*(nc/mgc)*(1/PI)*VAPER*(1.5+log(2/PI)+log((w+s)/(w+t)));
        }
    }
}
int decap_under_blk(model_t *model, int idx, int layer)
{
  int i,j;
  int nc = model->cols;
  char *name;
  blist_t *ptr;
  if(0 == model->config.PDN_decap_unifm)
    return 1;
  j = idx % nc;
  i = (int) floor(idx/nc);
  ptr = model->layers[layer].b2gmap[i][j];
  name = model->layers[layer].flp->units[ptr->idx].name;
  // A quick and dirty way to do identify places to put decap
  if((name[0] == 'A' &&
      name[1] == 'L' &&
      name[2] == 'U')){
      return 1;
  }
  else if((name[0] == 'R' &&
           name[1] == 'O' &&
           name[2] == 'B')){
      return 1;
  }
  else if((name[0] == 'I' &&
           name[1] == 'n' &&
           name[2] == 't' &&
           name[3] == 'I' &&
           name[4] == 'W') &&
          model->config.PDN_decap_unifm > 1){
      return 1;
  }
  else if((name[0] == 'I' &&
           name[1] == 'n' &&
           name[2] == 't' &&
           name[3] == 'R' &&
           name[4] == 'F') &&
          model->config.PDN_decap_unifm > 1){
      return 1;
  }
  else if((name[0] == 'F' &&
           name[1] == 'P' &&
           name[2] == 'U') &&
          model->config.PDN_decap_unifm > 2){
      return 1;
  }
  else if((name[0] == 'C' &&
           name[1] == 'p' &&
           name[2] == 'l' &&
           name[3] == 'A' &&
           name[4] == 'L' &&
           name[5] == 'U') &&
          model->config.PDN_decap_unifm > 2){
      return 1;
  }
  else
    return 0;
}
double get_onchip_cap(model_t *model, int idx, int layer)
{
  int i,j;
  int nc = model->cols;
  j = idx % nc;
  i = (int) floor(idx/nc);
  return model->layers[layer].cap_c[i][j];
}
void steady_state_PDN(model_t *model, double *power)
{
  if(model->config.v_stacking)
    steady_state_PDN_vs(model, power);
  else
    steady_state_PDN_regular(model, power);
}
void steady_state_PDN_regular(model_t *model, double *power)
{
  model_vector_t *p;
  SuperMatrix A, L, U, B;
  double   *rhs;
  int      *perm_r; /* row permutations from partial pivoting */
  int      *perm_c; /* column permutation vector */
  int      info;
  superlu_options_t options;
  SuperLUStat_t stat;
  int          i;
  DNformat     *Astore;
  double       *dp;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  p = new_model_vector(model);
  /* map the block power numbers to the grid	*/
  PDN_xlate_vector_b2g(model, power, p);
  /* Calculate pkg vdd/gnd  */
  set_heuristic_vol_PDN_regular(model, model->last_steady, p);
  A = build_steady_grid_matrix(model);
  B = build_steady_rhs_vector(model, p, &rhs);
  if ( !(perm_r = intMalloc(2*nl*nr*nc)) ) fatal("Malloc fails for perm_r[].\n");
  if ( !(perm_c = intMalloc(2*nl*nr*nc)) ) fatal("Malloc fails for perm_c[].\n");
  /* Set the default input options. */
  set_default_options(&options);
  options.ColPerm = MMD_AT_PLUS_A;
  options.DiagPivotThresh = 0.01;
  options.SymmetricMode = YES;
  options.Equil = YES;
  /* Initialize the statistics variables. */
  StatInit(&stat);
  /* Solve the linear system. */
  dgssv(&options, &A, perm_c, perm_r, &L, &U, &B, &stat, &info);
  Astore = (DNformat *) B.Store;
  dp = (double *) Astore->nzval;
  //copy results back to last_steady
  for(i=0; i<2*nl*nr*nc; ++i){
      model->last_steady[i] = dp[i];
  }
  free_model_vector(p);
  SUPERLU_FREE (rhs);
  SUPERLU_FREE (perm_r);
  SUPERLU_FREE (perm_c);
  Destroy_CompCol_Matrix(&A);
  Destroy_SuperMatrix_Store(&B);
  Destroy_SuperNode_Matrix(&L);
  Destroy_CompCol_Matrix(&U);
  StatFree(&stat);
}
void steady_state_PDN_vs(model_t *model, double *power)
{
  model_vector_t *p;
  SuperMatrix A, L, U, B;
  double   *rhs;
  int      *perm_r; /* row permutations from partial pivoting */
  int      *perm_c; /* column permutation vector */
  int      info;
  superlu_options_t options;
  SuperLUStat_t stat;
  int          i;
  DNformat     *Astore;
  double       *dp;
  double       max_error, cur_error;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  p = new_model_vector(model);
  /* map the block power numbers to the grid	*/
  PDN_xlate_vector_b2g(model, power, p);
  /* Calculate pkg vdd/gnd  */
  set_heuristic_vol_PDN_vs(model, model->last_steady, p);
  A = build_steady_grid_matrix_vs(model, p);
  B = build_steady_rhs_vector_vs(model, &rhs);
  if ( !(perm_r = intMalloc(2*nl*nr*nc)) ) fatal("Malloc fails for perm_r[].\n");
  if ( !(perm_c = intMalloc(2*nl*nr*nc)) ) fatal("Malloc fails for perm_c[].\n");
  /* Set the default input options. */
  set_default_options(&options);
  options.ColPerm = MMD_AT_PLUS_A;
  options.DiagPivotThresh = 0.01;
  options.SymmetricMode = YES;
  options.Equil = YES;
  /* Initialize the statistics variables. */
  StatInit(&stat);
  /* Solve the linear system. */
  dgssv(&options, &A, perm_c, perm_r, &L, &U, &B, &stat, &info);
  Astore = (DNformat *) B.Store;
  dp = (double *) Astore->nzval;
  //copy results back to last_steady
  for(i=0; i<2*nl*nr*nc; ++i){
      model->last_steady[i] = dp[i];
  }
  StatFree(&stat);
  SUPERLU_FREE (rhs);
  free_model_vector(p);
  SUPERLU_FREE (perm_r);
  SUPERLU_FREE (perm_c);
  Destroy_CompCol_Matrix(&A);
  Destroy_SuperMatrix_Store(&B);
  Destroy_SuperNode_Matrix(&L);
  Destroy_CompCol_Matrix(&U);
}
/* translate power/voltage between block and grid vectors	*/
void PDN_xlate_vector_b2g(model_t *model, double *b, model_vector_t *g)
{
  int i, j, l, base = 0;
  double area;
  /* area of a single grid cell	*/
  area = (model->width * model->height) / (model->cols * model->rows);
  for(l=0; l<model->n_layers; l++){
      for(i=0; i<model->rows; i++)
        for(j=0; j<model->cols; j++) {
            /* for each grid cell, the power density / voltage are 
             * the average of the power densities / voltage of the 
             * blocks in it weighted by their occupancies
             */
            /* convert power density to power	*/ 
            g->cuboid[l][i][j] = blist_avg_PDN(model->layers[l].b2gmap[i][j], 
                                               model->layers[l].flp, &b[base]) * area;
        }
      base+= model->layers[l].flp->n_units;
  }
}
/* constructor	*/
model_vector_t *new_model_vector(model_t *model)
{
  model_vector_t *v;
  v = (model_vector_t *) calloc (1, sizeof(model_vector_t));
  if (!v)
    fatal("memory allocation error\n");
  v->cuboid = dcuboid_PDN(model->rows, model->cols, model->n_layers);
  return v;
}
/* create a linked list node and append it at the end	*/
void blist_append_PDN(blist_t *head, int idx, double occupancy)
{
  blist_t *tail = NULL;
  if(!head)
    fatal("blist_append_PDN called with empty list\n");
  /* traverse till the end	*/
  for(; head; head = head->next)
    tail = head;
  /* append */
  tail->next =  new_blist_PDN(idx, occupancy);
}
/* destructor	*/
void delete_b2gmap_PDN(blist_t ***b2gmap, int rows, int cols)
{
  int i, j;
  blist_t *ptr, *temp;
  /* free the linked list	*/
  for(i=0; i < rows; i++)
    for(j=0; j < cols; j++) {
        ptr = b2gmap[i][j];
        while(ptr) {
            temp = ptr->next;
            free(ptr);
            ptr = temp;
        }
    }
  /* free the array space	*/
  free(b2gmap[0]);
  free(b2gmap);
}
/* setup the block and grid mapping data structures	*/
void set_bgmap_PDN(model_t *model, PDN_layer_t *layer)
{
  /* i1, i2, j1 and j2 are indices of the boundary grid cells	*/
  int i, j, u, i1, i2, j1, j2;
  /* shortcuts for cell width(cw) and cell height(ch)	*/
  double cw = model->width / model->cols;
  double ch = model->height / model->rows;
  /* initialize	*/
  reset_b2gmap_PDN(model, layer);
  /* for each functional unit	*/
  for(u=0; u<layer->flp->n_units; u++) {
      /* shortcuts for unit boundaries	*/
      double lu = layer->flp->units[u].leftx;
      double ru = lu + layer->flp->units[u].width;
      double bu = layer->flp->units[u].bottomy;
      double tu = bu + layer->flp->units[u].height;
      /* top index (lesser row) = rows - ceil (topy / cell height)	*/
      i1 = model->rows - tolerant_ceil(tu/ch);
      /* bottom index (greater row) = rows - floor (bottomy / cell height)	*/
      i2 = model->rows - tolerant_floor(bu/ch);
      /* left index = floor (leftx / cell width)	*/
      j1 = tolerant_floor(lu/cw);
      /* right index = ceil (rightx / cell width)	*/
      j2 = tolerant_ceil(ru/cw);
      /* sanity check	*/
      if((i1 < 0) || (j1 < 0))
        fatal("negative grid cell start index!\n");
      if((i2 > model->rows) || (j2 > model->cols))
        fatal("grid cell end index out of bounds!\n");
      if((i1 >= i2) || (j1 >= j2))
        fatal("invalid floorplan spec or grid resolution\n");
      /* setup b2gmap	*/
      /* for each grid cell in this unit	*/
      for(i=i1; i<i2; i++)
        for(j=j1; j<j2; j++)
          /* grid cells fully overlapped by this unit	*/
          if ((i > i1) && (i < i2-1) && (j > j1) && (j < j2-1)) {
              /* first unit in the list	*/
              if (!layer->b2gmap[i][j])
                layer->b2gmap[i][j] = new_blist_PDN(u, 1.0);
              else {
                  /* this should not occur since the grid cell is 
                   * fully covered and hence, no other unit should 
                   * be sharing it
                   */
                  blist_append_PDN(layer->b2gmap[i][j], u, 0.0); // We ignore the second block
                  warning("overlap of functional blocks? ignoring the second one\n");
              }
              /* boundary grid cells partially overlapped by this unit	*/
          } else {
              /* shortcuts for cell boundaries	*/
              double lc = j * cw, rc = (j+1) * cw;
              double tc = model->height - i * ch;
              double bc = model->height - (i+1) * ch;
              /* shortcuts for overlap width and height	*/
              double oh = (MIN(tu, tc) - MAX(bu, bc));
              double ow = (MIN(ru, rc) - MAX(lu, lc));
              double occupancy;
              /* overlap tolerance	*/
              if (eq(oh/ch, 0))
                oh = 0;
              else if (eq(oh/ch, 1))
                oh = ch;
              if (eq(ow/cw, 0))
                ow = 0;
              else if (eq(ow/cw, 1))
                ow = cw;
              occupancy = (oh * ow) / (ch * cw);
              if (oh < 0 || ow < 0)
                fatal("negative overlap!\n");
              /* first unit in the list	*/
              if (!layer->b2gmap[i][j])
                layer->b2gmap[i][j] = new_blist_PDN(u, occupancy);
              else
                /* append at the end	*/
                blist_append_PDN(layer->b2gmap[i][j], u, occupancy);
          }
  }
  /* 
   * sanity check	
   test_b2gmap(model, layer);
   */
}
/* re-initialize */
void reset_b2gmap_PDN(model_t *model, PDN_layer_t *layer)
{
  int i, j;
  blist_t *ptr, *temp;
  /* free the linked list	*/
  for(i=0; i<model->rows; i++)
    for(j=0; j<model->cols; j++) {
        ptr = layer->b2gmap[i][j];
        while(ptr) {
            temp = ptr->next;
            free(ptr);
            ptr = temp;
        }
        layer->b2gmap[i][j] = NULL;
    }
}
/* a simple way to set initial voltage*/
void set_heuristic_vol_PDN_regular(model_t *model, double *temp, model_vector_t *power)
{
  int i, j, l;
  int idx;
  /* current sum of pads */
  double pad_sum = 0;
  double r_pkg_s = model->config.PDN_pkg_sR;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  for(l=0; l<nl; l++)
    for(i=0; i<nr; i++)
      for(j=0; j<nc; j++) {
          // VDD layer idx
          idx = l*nr*nc + i*nc + j ;
          temp[idx] = vdd;
          // GND layer idx
          idx = nl*nr*nc + l*nr*nc + i*nc + j ;
          temp[idx] = gnd;
          pad_sum += power->cuboid[l][i][j];
      }
  pad_sum /= (vdd-gnd);
  temp[2*nl*nc*nr+PKG_VDD] = vdd - pad_sum * r_pkg_s; 
  temp[2*nl*nc*nr+PKG_GND] = gnd + pad_sum * r_pkg_s;
}
void set_heuristic_vol_PDN_vs(model_t *model, double *temp, model_vector_t *power)
{
  int i, j, l;
  int idx;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  for(l=0; l<nl; l++)
    for(i=0; i<nr; i++)
      for(j=0; j<nc; j++) {
          // GND layer idx
          idx = 2*l*nr*nc + i*nc + j ;
          temp[idx] = l*vdd;
          // Vdd layer idx
          idx = (2*l+1)*nr*nc + i*nc + j ;
          temp[idx] = (l+1)*vdd;
      }
}
blist_t ***new_b2gmap_PDN(int rows, int cols)
{
  int i;
  blist_t ***b2gmap;
  b2gmap = (blist_t ***) calloc (rows, sizeof(blist_t **));
  b2gmap[0] = (blist_t **) calloc (rows * cols, sizeof(blist_t *));
  if (!b2gmap || !b2gmap[0])
    fatal("memory allocation error\n");
  for(i=1; i<rows; i++) 
    b2gmap[i] = b2gmap[0] + cols * i;
  return b2gmap;	
}
/* constructors	*/
blist_t *new_blist_PDN(int idx, double occupancy)
{
  blist_t *ptr = (blist_t *) calloc (1, sizeof(blist_t));
  if (!ptr)
    fatal("memory allocation error\n");
  ptr->idx = idx;
  ptr->occupancy = occupancy;
  ptr->next = NULL;
  return ptr;
}
/* compute the power/voltage average weighted by occupancies	*/
double blist_avg_PDN(blist_t *ptr, PDN_flp_t *flp, double *v)
{
  double  val = 0.0;
  for(; ptr; ptr = ptr->next) {
      val += ptr->occupancy * v[ptr->idx] / (flp->units[ptr->idx].width * 
                                             flp->units[ptr->idx].height);
  }		
  return val;		   
}
double ***dcuboid_PDN(int nr, int nc, int nl)
{
  int i, j;
  double ***m;
  /* 1-d array of pointers to the rows of the 2-d array below	*/
  m = (double ***) calloc (nl, sizeof(double **));
  assert(m != NULL);
  /* 2-d array of pointers denoting (layer, row)	*/
  m[0] = (double **) calloc (nl * nr, sizeof(double *));
  assert(m[0] != NULL);
  /* the actual 3-d data array	*/
  m[0][0] = (double *) calloc (nl * nr * nc, sizeof(double));
  assert(m[0][0] != NULL);
  /* remaining pointers of the 1-d pointer array	*/
  for(i=1; i<nl; i++)
    m[i] = m[0] + nr*i;
  /* remaining pointers of the 2-d pointer array	*/
  for(i=0; i<nl; i++)
    for(j=0; j<nr; j++)
      /* to reach the jth row in the ith layer, 
       * one has to cross i layers i.e., i*(nr*nc)
       * values first and then j rows i.e., j*nc 
       * values next
       */
      m[i][j] = m[0][0] + (nr*nc)*i + nc*j;
  return m;
}
PDN_C4_t *alloc_C4_PDN(model_t *model, int pad_grid_col, int pad_grid_row)
{
  PDN_C4_t *c4;
  c4 = (PDN_C4_t *) calloc (1, sizeof(PDN_C4_t));
  if (!c4)
    fatal("memory allocation error\n");
  c4->gnd_num = 0;
  c4->vdd_num = 0;
  c4->vdd_loc = imatrix(model->rows, model->cols);
  c4->gnd_loc = imatrix(model->rows, model->cols);
  zero_ivector(c4->vdd_loc[0], model->rows*model->cols);
  zero_ivector(c4->gnd_loc[0], model->rows*model->cols);
  c4->pad_grid_row = pad_grid_row;
  c4->pad_grid_col = pad_grid_col;
  c4->vdd_padidx = ivector(pad_grid_row * pad_grid_col);
  c4->gnd_padidx = ivector(pad_grid_row * pad_grid_col);
  return c4;
}
void populate_C4_PDN(model_t *model)
{
  int i, j, nr, nc;
  int pl;
  int rpg, cpg;//pad grid
  int r_cordt, c_cordt;//cordt for pad
  int itv_row, itv_col;
  int vdd_idx, gnd_idx;
  /* shortcuts */
  nr = model->rows;
  nc = model->cols;
  pl = model->config.PDN_padconfig;
  rpg = model->c4->pad_grid_row;
  cpg = model->c4->pad_grid_col;
  itv_row = (int)(nr - 1)/(rpg - 1);
  itv_col = (int)(nc - 1)/(cpg - 1);
  /* initalize */
  for(i=0; i<nr; i++){
      for(j=0; j<nc; j++){
          model->c4->gnd_loc[i][j] = UNDEF;
          model->c4->vdd_loc[i][j] = UNDEF;
      }
  }
  /* pad config */
  if (pl == CONFIG_CUS){
      parse_pad_loc(model, model->config.padloc_file_in);
  }
  else if (pl == CONFIG_ALL){
      // All seats are filled with pads
      for(i=0; i<rpg; i++) {
        for(j=0; j<cpg; j++){
            r_cordt = i * itv_row;
            c_cordt = j * itv_col;
            if ( (i%2) == (j%2) ){
                model->c4->vdd_loc[r_cordt][c_cordt] |= PGPAD;
            }
            else {
                model->c4->gnd_loc[r_cordt][c_cordt] |= PGPAD;
            }
        }
      }
  }
  else{
      fatal("Unexcepted pad configuration setup\n");
  }
  if(0 == model->config.reserve_io){
      mark_all(model, IORAN);
  }
  else if(1 == model->config.reserve_io){
      mark_pads(model, IOPAD);
      remove_pg_for_io(model);
  }
  else if(2 == model->config.reserve_io){
      mark_pads(model, IORAN);
  }
  set_current_limit(model);
  // Assign pad ID, map pad ID to grid index
  for(i=0; i<model->c4->pad_grid_row*model->c4->pad_grid_col; i++){
      model->c4->vdd_padidx[i] = -1;
      model->c4->gnd_padidx[i] = -1;
  }
  vdd_idx = 0;
  gnd_idx = 0;
  for(i=0; i<nr; i++)
    for(j=0; j<nc; j++){
        if (PGPAD & model->c4->vdd_loc[i][j]){
            model->c4->vdd_padidx[vdd_idx] = i*nc + j;
            vdd_idx++;
        }
        if (PGPAD & model->c4->gnd_loc[i][j]){
            model->c4->gnd_padidx[gnd_idx] = i*nc + j;
            gnd_idx++;
        }
    }
  // power and ground pad number
  model->c4->vdd_num = vdd_idx;
  model->c4->gnd_num = gnd_idx;
}
void populate_TSV_PDN(model_t *model)
{
  int i, j, l;
  /* shortcuts */
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int tl = model->config.TSV_config;
  /* initalize */
  for(l=0; l<nl; l++)
    for(i=0; i<nr; i++){
        for(j=0; j<nc; j++){
            model->layers[l].tsv.loc[i][j] = UNDEF;
        }
    }
  /* TSV config */
  if (tl == CONFIG_CUS){
      for(l=0; l<nl-1; l++)
        parse_tsv_loc(model, l);
  }
  else if (tl == CONFIG_ALL){
      for(l=0; l<nl-1; l++)
        for(i=0; i<nr; i++)
          for(j=0; j<nc; j++){
              if( (i%2) == (j%2) ){
                  model->layers[l].tsv.loc[i][j] = VDDTSV;
              }
              else{
                  model->layers[l].tsv.loc[i][j] = GNDTSV;
              }
          }
  }
  else{
      fatal("Unexcepted pad configuration setup\n");
  }
  //sanity check rules about TSV
  //we force all layers have same TSV distribution for now
  for(l=1; l<nl-1; l++)
    for(i=0; i<nr; i++)
      for(j=0; j<nc; j++){
          if(model->layers[0].tsv.loc[i][j] !=
             model->layers[l].tsv.loc[i][j])
            fatal("Different TSV distribution between layers detected!\n");
      }
  //count TSV num
  for(l=0; l<nl-1; l++){
      model->layers[l].tsv.num_vdd = 0;
      model->layers[l].tsv.num_gnd = 0;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            if(model->layers[l].tsv.loc[i][j] == VDDTSV){
                model->layers[l].tsv.num_vdd += 1;
            }
            else if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                model->layers[l].tsv.num_gnd += 1;
            }
        }
  }
}
void delete_model(model_t *model)
{
  free_layers_PDN(model);
  free_dvector(model->last_steady);
  free_dvector(model->last_trans);
  free_dvector(model->last_power);
  free_PDN_C4(model->c4);
  if(model->config.v_stacking)
    free_IVR(model->sc_converter);
  free(model);
}
void free_layers_PDN(model_t *model)
{
  int i;
  for(i=0; i<model->n_layers; i++){
      free_metal_layers(model->layers[i].metal_layers);
      if(model->is_3D){
          free_TSV(model->layers[i].tsv);
          PDN_free_flp(model->layers[i].flp);
      }
      free_dmatrix(model->layers[i].cap_c);
      delete_b2gmap_PDN(model->layers[i].b2gmap, model->rows, model->cols);
  }
  free(model->layers);
}
void free_TSV(PDN_TSV_t t)
{
  free_imatrix(t.loc);
}
void free_IVR(IVR_t *v)
{
  free_imatrix(v->loc);
  free(v);
}
void free_metal_layers(PDN_metal_t l)
{
  free(l.geo);
  free(l.gridRL);
}
/* free the C4 pads */
void free_PDN_C4(PDN_C4_t *p)
{
  free_imatrix(p->gnd_loc);
  free_imatrix(p->vdd_loc);
  free_ivector(p->vdd_padidx);
  free_ivector(p->gnd_padidx);
  free(p);
}
/* destructor	*/
void free_model_vector(model_vector_t *v)
{
  free_dcuboid(v->cuboid);
  free(v);
}
void compute_PDN_SLU(model_t *model, double *power, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U, int *perm_c, int *perm_r)
{
  SuperMatrix B;
  SuperLUStat_t stat;
  int info;
  model_vector_t *p;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int m = model->trans_matrix_dim;
  // L * Yn, stored in last_trans
  // with package, L = (E + J * delta_t / 2)
  SparseMatrix_mul_Vector(A, model->last_trans);
  p = new_model_vector(model);
  /* map the block power/temp numbers to the grid	*/
  PDN_xlate_vector_b2g(model, power, p);
  Finalize_rhs(model, p);
  dCreate_Dense_Matrix(&B, m, 1, model->last_trans, m, SLU_DN, SLU_D, SLU_GE);
  StatInit(&stat);
  dgstrs(NOTRANS, L, U, perm_c, perm_r, &B, &stat, &info);
  // save previous power trace for next computation
  copy_dvector(model->last_power, p->cuboid[0][0], nr*nc*nl);
  //We free B after set B's nzval ptr to NULL
  //Because last_trans is in B
  DNformat    *Xstore;
  Xstore = (DNformat *) B.Store;
  Xstore->nzval = NULL;
  Destroy_SuperMatrix_Store(&B);
  free_model_vector(p);
  StatFree(&stat);
}
int PDN_trans_matrix_dim(model_t *model)
{
  int m, l;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int np = model->c4->vdd_num + model->c4->gnd_num;
  int nml = model->layers[0].metal_layers.n_metal/2;
  int nbr = 2*nr*nc - nr - nc;
  int nvtsv = model->layers[0].tsv.num_vdd;
  int ngtsv = model->layers[0].tsv.num_gnd;
  int nIVR;
  if (!model->is_3D){
      m = 2*nr*nc + np;
      if(model->config.PDN_pkgLC)
        m += 2;
      if(model->config.PDN_gridL)
        m += 2*nbr*nml;
  }
  else{
      m = 2*nr*nc*nl + np;
      if(model->config.v_stacking){
          nIVR = model->sc_converter->num_IVR;
          m += ngtsv*(nl-1);
          m += nIVR*(nl-1)*4;
      }
      else{
          m += (nvtsv+ngtsv)*(nl-1);
      }
      if(model->config.PDN_pkgLC)
        m += 2;
  }
  return m;
}
int PadIdx_to_GridIdx(model_t *model, int idx, int layer)
{
  if(LAYER_VDD == layer)
    return model->c4->vdd_padidx[idx];
  else if(LAYER_GND == layer)
    return model->c4->gnd_padidx[idx];
  else
    fatal("Wrong arguemnt layer received by PadIdx_to_GridIdx!\n");
  return 0;
}
int GridIdx_to_PadIdx(model_t *model, int idx, int layer)
{
  int size = model->c4->pad_grid_row*model->c4->pad_grid_col;
  int i;
  if(LAYER_VDD == layer){
      for(i=0; i<size; i++){
          if(idx == model->c4->vdd_padidx[i])
            return i;
      }
  }
  else if(LAYER_GND == layer){
      for(i=0; i<size; i++){
          if(idx == model->c4->gnd_padidx[i])
            return i;
      }
  }
  else
    fatal("Wrong arguemnt layer received by GridIdx_to_PadIdx!\n");
  return -1;
}
char *GridIdx_to_UnitName(model_t *model, int idx, int layer)
{
  int i,j;
  int nc = model->cols;
  blist_t *ptr;
  j = idx % nc;
  i = (int) floor(idx/nc);
  ptr = model->layers[layer].b2gmap[i][j];
  return model->layers[layer].flp->units[ptr->idx].name;
}
int compare_domain(model_t *model, int idx, int offset)
{
  int ia,ja,ib,jb;
  int nc = model->cols;
  blist_t *ptra, *ptrb;
  int mtdmn  = model->config.PDN_multi_dom;
  if(!mtdmn)
    return 1;
  ja = idx % nc;
  ia = (int) floor(idx/nc);
  jb = (idx+offset) % nc;
  ib = (int) floor((idx+offset)/nc);
  ptra = model->layers[0].b2gmap[ia][ja];
  ptrb = model->layers[0].b2gmap[ib][jb];
  if(model->layers[0].flp->units[ptra->idx].domain == 
     model->layers[0].flp->units[ptrb->idx].domain)
    return 1;
  else
    return 0;
}
// when multidomain, return whether a grid branch exist
int does_branch_exist(model_t *model, int idx)
{
  int ia,ja,ib,jb;
  int nr = model->rows;
  int nc = model->cols;
  blist_t *ptra, *ptrb;
  int mtdmn  = model->config.PDN_multi_dom;
  if(!mtdmn)
    return 1;
  if(idx < ((nc-1)*nr)){
      ja = idx % (nc-1);
      ia = (int) floor(idx/(nc-1));
      jb = ja + 1;
      ib = ia;
  }
  else{
      ja = (idx-(nc-1)*nr) % nc;
      ia = (int) floor((idx-(nc-1)*nr)/nc);
      jb = ja;
      ib = ia + 1;
  }
  ptra = model->layers[0].b2gmap[ia][ja];
  ptrb = model->layers[0].b2gmap[ib][jb];
  if(model->layers[0].flp->units[ptra->idx].domain == 
     model->layers[0].flp->units[ptrb->idx].domain){
      return 1;
  }
  else{
      return 0;
  }
}
void set_flp_domain(PDN_flp_t *flp, PDN_config_t *config)
{
  int i;
  int core_id;
  int num_dom = 0;
  char *name;
  for(i=0; i<flp->n_units; i++){
      name = flp->units[i].name;
      core_id = get_core_id(name);
      if(core_id < 0){
          flp->units[i].domain = 0;
      }
      else{
          if(config->PDN_multi_dom > 0){
              // assumes that core id starts with 1
              flp->units[i].domain = floor((core_id-1) / config->PDN_multi_dom) + 1;
          }
          else if(-1 == config->PDN_multi_dom){
              // non-uniform domain size for 16 core
              if(core_id > 15)
                flp->units[i].domain = 5;
              else if(core_id > 14)
                flp->units[i].domain = 4;
              else if(core_id > 12)
                flp->units[i].domain = 3;
              else if(core_id > 8)
                flp->units[i].domain = 2;
              else
                flp->units[i].domain = 1;
          }
          else
            fatal("Unsupported multi_dom config");
      }
      if(flp->units[i].domain > num_dom)
        num_dom = flp->units[i].domain; 
  }
  /* # of conceptual domains, domains with same id 
   * are not guaranteed to connect together */
  flp->n_domain = num_dom + 1;
}
int get_core_id(char *blk_name)
{
  int core_id;
  int length = strlen(blk_name);
  // MC does not belong to any core
  if(blk_name[0] == 'M' &&
     blk_name[1] == 'C'){
      if(blk_name[length-2] <= '9' &&
         blk_name[length-2] >= '0')
        core_id = -1 * (10 * (blk_name[length-2]-'0') + (blk_name[length-1]-'0'));
      else
        core_id = -1 * (blk_name[length-1]-'0');
  }
  else{
      if(blk_name[length-2] <= '9' &&
         blk_name[length-2] >= '0')
        core_id = 10*(blk_name[length-2]-'0') + (blk_name[length-1]-'0');
      else
        core_id = (blk_name[length-1]-'0');
  }
  if(0 == core_id)
    fatal("Core ID should start with 1\n");
  if(core_id > MAX_CORE_NUM)
    fatal("Core id exceeds maximum value\n");
  return core_id;
}
/* parse the layer file open for reading	*/
void parse_layer_file_PDN(model_t *model, FILE *fp)
{
  char line[LINE_SIZE], *ptr;
  FILE *mfp = NULL;
  char str[STR_SIZE];
  int count, i = 0;
  int field = LCF_3D_SNO, ival;
  int num_layer;
  fseek(fp, 0, SEEK_SET);
  count = 0;
  while (!feof(fp) && count < (model->n_layers * LCF_3D_NPARAMS)) {
      fgets(line, LINE_SIZE, fp);
      if (feof(fp))
        break;
      /* ignore comments and empty lines	*/
      ptr = strtok(line, " \r\t\n");
      if (!ptr || ptr[0] == '#')
        continue;
      switch (field) 
        {
        case LCF_3D_SNO:
          if (sscanf(ptr, "%d", &ival) != 1)
            fatal("invalid layer number\n");
          if(ival >= model->n_layers || ival < 0)
            fatal("layer number must be >= 0 and < no. of layers\n");
          if (model->layers[ival].no != 0)
            fatal("layer numbers must be unique\n");
          i = ival;
          model->layers[i].no = ival;
          break;
        case LCF_3D_FLP:
          model->layers[i].flp = PDN_read_flp(ptr);
          if(!eq(model->width, PDN_get_total_width(model->layers[i].flp)) || 
             !eq(model->height, PDN_get_total_height(model->layers[i].flp)))
            fatal("width and height differ across layers\n");
          break;
        case LCF_3D_MLCF:
          mfp = fopen(ptr, "r");
          if(!mfp) {
              sprintf(str, "error opening mlcf file %s in lcf file\n", ptr);
              fatal(str);
          }
          num_layer = count_significant_lines(mfp);
          if (num_layer % MLCF_NPARAMS)
            fatal("wrong no. of lines in metal layer file\n");
          num_layer /= MLCF_NPARAMS;
          model->layers[i].metal_layers = alloc_metal_layers(num_layer);
          parse_metal_layer_file(model, ptr, i);
          fclose(mfp);
          break;
        case LCF_3D_TSVL:
          strcpy(model->layers[i].tsv.file, ptr);
          model->layers[i].tsv.loc = imatrix(model->rows, model->cols);
          zero_ivector(model->layers[i].tsv.loc[0], model->rows*model->cols);
          break;
        default:
          fatal("invalid field id\n");
          break;
        }
      field = (field + 1) % LCF_3D_NPARAMS;
      count++;
  }
  /* allocate the block-grid maps */
  for(i=0; i < model->n_layers; i++) {
      model->layers[i].b2gmap = new_b2gmap_PDN(model->rows, model->cols);
  }
}
/* parse the layer file open for reading	*/
void parse_metal_layer_file(model_t *model, char *file, int layer)
{
  FILE *fp;
  char str[LINE_SIZE], line[LINE_SIZE], *ptr;
  int count, i = 0, j, field = MLCF_SNO, ival;
  double dval;
  int n = model->layers[layer].metal_layers.n_metal;
  int *set_flag = ivector(n);
  zero_ivector(set_flag, n);
  fp = fopen (file, "r");
  if (!fp) {
      sprintf(str, "error opening mlcf file %s\n", file);
      fatal(str);
  }
  fseek(fp, 0, SEEK_SET);
  count = 0;
  while (!feof(fp) && count < (n * MLCF_NPARAMS)) {
      fgets(line, LINE_SIZE, fp);
      if (feof(fp))
        break;
      /* ignore comments and empty lines	*/
      ptr = strtok(line, " \r\t\n");
      if (!ptr || ptr[0] == '#')
        continue;
      switch (field) {
        case MLCF_SNO:
          if (sscanf(ptr, "%d", &ival) != 1)
            fatal("invalid layer number\n");
          if(ival >= n || ival < 0)
            fatal("layer number must be >= 0 and < no. of metal layers\n");
          if (set_flag[ival] == TRUE)
            fatal("layer numbers must be unique\n");
          i = ival;
          set_flag[i] = TRUE;
          break;
        case MLCF_PITCH:
          if (sscanf(ptr, "%lf", &dval) != 1)
            fatal("invalid pitch\n");
          model->layers[layer].metal_layers.geo[i].pitch = dval;
          break;
        case MLCF_WIDTH:
          if (sscanf(ptr, "%lf", &dval) != 1)
            fatal("invalid width\n");
          model->layers[layer].metal_layers.geo[i].width = dval;
          break;
        case MLCF_THICK:
          if (sscanf(ptr, "%lf", &dval) != 1)
            fatal("invalid thick\n");
          model->layers[layer].metal_layers.geo[i].thick = dval;
          break;
        case MLCF_RHO:
          if (sscanf(ptr, "%lf", &dval) != 1)
            fatal("invalid rho\n");
          model->layers[layer].metal_layers.geo[i].rho = dval;
          break;
        case MLCF_DIREC:
          if (sscanf(ptr, "%d", &ival) != 1)
            fatal("invalid direction\n");
          if ((MLCF_X != ival) && (MLCF_Y != ival))
            fatal("direction input should either 0 or 1\n");
          model->layers[layer].metal_layers.geo[i].direc = ival;
          break;
        default:
          fatal("invalid field id\n");
          break;
      }
      field = (field + 1) % MLCF_NPARAMS;
      count++;
  }
  fclose(fp);
  for(j=0; j<n; j++){
      if(set_flag[j] != TRUE){
          sprintf(str, "Metal layer %d was left uninitialized\n", j);
          fatal(str);
      }
  }
  free_ivector(set_flag);
  //sanity check
  //for simplicity, we force that n_metal must be even
  //and adjacent layers cannot be in the same direction
  //for now, we force that layer 0 must be x-direc
  if(n%2)
    fatal("Please specify even number of metal layers\n");
  for(i=0; i<n; i++){
      if(i%2 != model->layers[layer].metal_layers.geo[i].direc)
        fatal("Please make sure that layer 0 is x, 1 is y, etc. \n");
  }
}
void parse_tsv_loc(model_t *model, int layer)
{
  char str[LINE_SIZE], copy[LINE_SIZE]; 
  char s[STR_SIZE];
  char name[STR_SIZE];
  int grid_x, grid_y;
  char *ptr;
  FILE *fp;
  /* short cuts */  
  int nr = model->rows;
  int nc = model->cols;
  int **tloc = model->layers[layer].tsv.loc;
  if (!strcasecmp(model->layers[layer].tsv.file, "stdin"))
    fp = stdin;
  else
    fp = fopen (model->layers[layer].tsv.file, "r");
  if (!fp) {
      sprintf(s, "error opening tsvloc file %s\n", model->layers[layer].tsv.file);
      fatal(s);
  }
  fseek(fp, 0, SEEK_SET);
  while(!feof(fp)) {
      fgets(str, LINE_SIZE, fp);
      if (feof(fp))
        break;
      strcpy(copy, str);
      /* ignore comments and empty lines */
      ptr = strtok(str, " \r\t\n");
      if (!ptr || ptr[0] == '#')
        continue;
      if (sscanf(copy, "%s%d%d", name, &grid_x, &grid_y) == 3) {
          if ((grid_x >= model->cols) || (grid_y >= model->rows) ||
              (grid_x < 0) || (grid_y < 0)){
              printf("x = %d, y = %d\n", grid_x, grid_y);
              printf("grid_size = %d*%d\n", model->cols, model->rows);
              fatal("TSV location does not fit in current grid!\n");
          }
          if ((VDDTSV == tloc[nr - grid_y - 1][grid_x]) ||
              (GNDTSV == tloc[nr - grid_y - 1][grid_x]))
            warning("Duplication exists in tsv location file .tsvloc\n");
          if (!strcmp(name, "V")){
              tloc[nr - grid_y - 1][grid_x] = VDDTSV;
          }
          else if (!strcmp(name, "G")){
              tloc[nr - grid_y - 1][grid_x] = GNDTSV;
          }
          else
            fatal("TSV location is neither V(vdd) nor G(ground)\n");
      }
      else
        fatal("invalid tsv location file format\n");
  }
  if(fp != stdin)
    fclose(fp);
}
void parse_IVR_loc(model_t *model, char *file)
{
  char str[LINE_SIZE], copy[LINE_SIZE]; 
  char s[STR_SIZE];
  int grid_x, grid_y;
  char *ptr;
  FILE *fp;
  /* short cuts */  
  int nr = model->rows;
  int nc = model->cols;
  if (!strcasecmp(file, "stdin"))
    fp = stdin;
  else
    fp = fopen (file, "r");
  if (!fp) {
      sprintf(s, "error opening IVR file %s\n", file);
      fatal(s);
  }
  fseek(fp, 0, SEEK_SET);
  while(!feof(fp)) {
      fgets(str, LINE_SIZE, fp);
      if (feof(fp))
        break;
      strcpy(copy, str);
      /* ignore comments and empty lines */
      ptr = strtok(str, " \r\t\n");
      if (!ptr || ptr[0] == '#')
        continue;
      // parse index as metal grid
      if (sscanf(copy, "%d%d", &grid_x, &grid_y) == 2) {
          if ((grid_x >= nc) || (grid_y >= nr) || (grid_x < 0) || (grid_y < 0)){
              printf("x = %d, y = %d\n", grid_x, grid_y);
              printf("grid_size = %d*%d\n", nc, nr);
              fatal("IVR location does not fit in current grid!\n");
          }
          if (IVRLOC == model->sc_converter->loc[nr - grid_y - 1][grid_x])
            warning("Duplication exists in tsv location file\n");
          model->sc_converter->loc[nr - grid_y - 1][grid_x] = IVRLOC;
      }
      else
        fatal("invalid pad location file format\n");
  }
  if(fp != stdin)
    fclose(fp);
}
void switch_SCconverters(model_t *model, int counter, int intvl)
{
  int i, j, l;
  int ivr_counter = 0;
  int num_intvl;
  int grididx;
  int head_idx, foot_idx;
  int t1_idx, t2_idx; int b1_idx, b2_idx;
  double Vt1_p, Vt2_p; double Vb1_p, Vb2_p;
  double Vhead, Vfoot;
  int nl = model->n_layers;
  int nr = model->rows;
  int nc = model->cols;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  int ngtsv = model->layers[0].tsv.num_gnd;
  int ntsv = ngtsv*(nl-1);
  int **ivr_loc = model->sc_converter->loc;
  double *g = model->last_trans;
  if(!(counter % intvl)){
      num_intvl = counter / intvl;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            if(IVRLOC == ivr_loc[i][j]){
                grididx = i*nc + j;
                for(l=0; l<nl-1; l++){
                    t1_idx = nvp+ngp+nl*2*nr*nc+ntsv+4*ivr_counter+0;
                    t2_idx = nvp+ngp+nl*2*nr*nc+ntsv+4*ivr_counter+1;
                    b1_idx = nvp+ngp+nl*2*nr*nc+ntsv+4*ivr_counter+2;
                    b2_idx = nvp+ngp+nl*2*nr*nc+ntsv+4*ivr_counter+3;
                    head_idx = nvp+ngp+(l+1)*2*nr*nc+grididx;
                    foot_idx = nvp+ngp+l*2*nr*nc+nr*nc+grididx;
                    Vt1_p = g[t1_idx]; Vt2_p = g[t2_idx];
                    Vb1_p = g[b1_idx]; Vb2_p = g[b2_idx];
                    Vhead = g[head_idx]; Vfoot = g[foot_idx];
                    if(num_intvl % 2){
                        g[t1_idx] = Vhead + Vfoot - Vb1_p;
                        g[b1_idx] = Vhead + Vfoot - Vt1_p;
                    }
                    else{
                        g[t2_idx] = Vhead + Vfoot - Vb2_p;
                        g[b2_idx] = Vhead + Vfoot - Vt2_p;
                    }
                    ivr_counter++;
                }
            }
        }
  }
}
</document_content>
</document>
<document index="15">
<source>PDN_sim.h</source>
<document_content>
#ifndef __PDN_SIM_H_
#define __PDN_SIM_H_
#include "flp.h"
#include "slu_ddefs.h"
#define LAYER_VDD		    1
#define LAYER_GND	    	0
// location configurations
#define CONFIG_CUS  		0
#define CONFIG_ALL  		1
// Pad
#define PADCONFIGS  		2
#define PAD_NUM_UNKNOWN	0
#define PAD_NUM_KNOWN  	1
// TSV
#define TSVCONFIGS  		2
// IVR
#define IVRLOC  		    1
#define STEADY          0
#define TRANSIENT       1
// for steady state
#define PDN_STEADY_EXTRA 2
#define PKG_GND          0
#define PKG_VDD          1
// TSV location definition
#define VDDTSV           3
#define GNDTSV           5
#define VTHTSV           7
#define GTHTSV           9
#define DEFAULT_MLAYERS	4	
/* metal layer configuration file constants */
#define MLCF_NPARAMS		6	/* no. of parameters per layer	*/
#define MLCF_SNO				0	/* serial number */
#define MLCF_PITCH      1	/* metal pitch */
#define MLCF_WIDTH      2	/* metal width */
#define MLCF_THICK      3	/* metal thickness */
#define MLCF_RHO        4	/* metal resistivity */
#define MLCF_DIREC      5	/* metal layer direction*/
#define MLCF_X          0	/* Horizontal wire */
#define MLCF_Y          1	/* Vertical wire */
/* 3D layer configuration file constants */
#define LCF_3D_NPARAMS	4	/* no. of parameters per layer	*/
#define LCF_3D_SNO			0	/* serial number */
#define LCF_3D_FLP      1	/* floorplan file */
#define LCF_3D_MLCF     2	/* metal layer spec file */
#define LCF_3D_TSVL     3	/* TSV loc file */
// for non-uniform de-cap placement, portion of decaps located in hot area
#define LOCAL_CAP_RATIO  0.9
// maximum number of cores allowed
#define MAX_CORE_NUM     32
// maximum grid dimension
#define MAX_DIM	    	   1000
/* block list: block to grid mapping data structure.
 * list of blocks mapped to a grid cell	
 */
typedef struct blist_t_st
{
	/* index of the mapped block	*/
	int idx;
	/* ratio of this block's area within the grid cell 
	 * to the total area of the grid cell
	 */
	double occupancy;
	/* next block mapped to the same cell	*/
	struct blist_t_st *next;
}blist_t;
typedef struct PDN_C4_t_st 
{
	/* pad grid size	*/
	int pad_grid_col;
	int pad_grid_row;
	/* pad count	*/
	int vdd_num;
	int gnd_num;
	/* pad R and L	*/
  double pad_r;
  double pad_l;
	/* pad current limit */
  double Ith;
	/* pad location	*/
	/* bit mark, see PGPAD, IOPAD, IORAN */
	int **vdd_loc;
	int **gnd_loc;
  /* Array stores pad index */
  int *vdd_padidx;
  int *gnd_padidx;
}PDN_C4_t;
typedef struct metal_geo_t_st 
{
	double pitch;
	double width;
	double thick;
	double rho;
	int    direc;
}metal_geo_t;
typedef struct metal_gridRL_t_st 
{
	double r;	/* onchip resistors	*/
	double l;	/* onchip inductance	*/
}metal_gridRL_t;
typedef struct PDN_metal_t_st 
{
	int n_metal;
  metal_geo_t    *geo;
  metal_gridRL_t *gridRL;
}PDN_metal_t;
typedef struct IVR_t_st 
{
	int num_IVR;
  double R_drop; // static model
  double freq;
  double Ron_top;
  double Ron_bottom;
  double c;
  int **loc;
}IVR_t;
typedef struct PDN_TSV_t_st 
{
	double w;
	double h;
	double t;
  double r;
  double l;
  //double c;
  int num_vdd;
  int num_gnd;
	char file[STR_SIZE];
	int **loc; // TSVs connecting ith and i+1th layer
}PDN_TSV_t;
typedef struct PDN_layer_t_st 
{
	/* configuration parameters	*/
	int no;				  /* serial number	*/
	/* floorplan */
	PDN_flp_t *flp;
	/* metal layer information	*/
	PDN_metal_t metal_layers;
	/* TSV info */
  PDN_TSV_t tsv;
	/* On-Chip capacitance */
	double **cap_c;
	/* block-grid map - 2-d array of block lists	*/
	blist_t ***b2gmap;
}PDN_layer_t;
/* PDN config */
typedef struct PDN_config_t_st
{
  int run_PDN;
	int PDN_grid_intv;
	int PDN_padconfig;
	int padloc_format;
	double PDN_padpitch;
	double PDN_padD;
	double PDN_padR;
  int PDN_pkgLC;
  int PDN_gridL;
  int vgradient_analyse;
	double vdd;
	double gnd;
	double proc_clock_freq;
	int PDN_step_percycle;
	int ptrace_sampling_intvl;
	int PDN_ptrace_warmup;	
  double PDN_decap_dense;
  double PDN_decap_ratio;
  int PDN_decap_unifm;
  double PDN_padL;
  double PDN_pkg_sL;
  double PDN_pkg_sR;
  double PDN_pkg_C;
  double PDN_pkg_pR;
  double PDN_pkg_pL;
  double PDN_pkg_scale;
	int v_stacking;
	int TSV_config;
	double TSV_R;
	double TSV_L;
	char layer_file_3D[STR_SIZE];
	char IVR_loc_file[STR_SIZE];
  double SC_freq;
  double SC_totcap;
  double SC_Rontop;
  double SC_Ronbtm;
	char mlayer_spec_file[STR_SIZE];
	char padloc_file_in[STR_SIZE];
	char padloc_file_out[STR_SIZE];
	char padcur_file[STR_SIZE];
	char tsvcur_file[STR_SIZE];
	char gridvol_file[STR_SIZE];
	char vio_file[STR_SIZE];
	char trans_vgradient_file[STR_SIZE];
	char senloc_file[STR_SIZE];
	char node_viotrace_file[STR_SIZE];
	double PDN_cur_dense;
	double PDN_noise_th;
	int reserve_io;
  int MC_pads;
  double IO_dense;
  int    PDN_multi_dom;
  int    animation;
  int    frame_intv;
  double legend_lwr;
  double legend_upr;
  double legend_curupr;
  int    PDN_sin_pattern;
  int    PDN_sin_totstep;
  double PDN_sin_freq;
}PDN_config_t;
/* PDN model's internal vector datatype	*/
typedef struct model_vector_t_st
{
	/* array of 3-d grid of nodes	*/
	double ***cuboid;
}model_vector_t;
/* PDN model	*/
typedef struct model_t_st
{
	/* configuration */
	PDN_config_t config;
	/* dimensions	*/
	double width;
	double height;
	/* grid resolution	*/
	int rows;
	int cols;
	/* is PDN 3D */
	int is_3D;
	/* layer information	*/
	PDN_layer_t *layers;
	int n_layers;
	/* C4 Pads information	*/
	PDN_C4_t *c4;
	/* IVR information	*/
	IVR_t *sc_converter;
	/* sum total of the functional blocks of all floorplans	*/
	int total_n_blocks;
	/* internal state - most recently computed 
	 * steady state voltages
	 */
	double *last_steady;
	/* for trans compute */
  int trans_matrix_dim;
  double *last_trans;
  double *last_power;
}model_t;
/* config setup */
PDN_config_t default_PDN_config(void);
void PDN_config_add_from_strs(PDN_config_t *config, str_pair *table, int size);
/* allocate/initiate/destruct */
model_vector_t *new_model_vector(model_t *model);
model_t *alloc_model(PDN_config_t *config, PDN_flp_t *flp_default);
PDN_C4_t *alloc_C4_PDN(model_t *model, int pad_grid_col, int pad_grid_row);
IVR_t *alloc_IVR(model_t *model);
double ***dcuboid_PDN(int nr, int nc, int nl);
void populate_R_model_PDN(model_t *model);
void populate_LC_model_PDN(model_t *model);
void populate_C4_PDN(model_t *model);
void populate_TSV_PDN(model_t *model);
void populate_IVR(model_t *model);
void alloc_layers_PDN(model_t *model, PDN_flp_t *flp_default);
PDN_metal_t alloc_metal_layers(int n_metal);
void populate_single_layer_PDN(model_t *model, PDN_flp_t *flp_default);
void populate_default_mlayers(model_t *model, int layer);
void parse_layer_file_PDN(model_t *model, FILE *fp);
void parse_tsv_loc(model_t *model, int layer);
void parse_IVR_loc(model_t *model, char *file);
void delete_model(model_t *model);
void set_current_limit(model_t *model);
void free_layers_PDN(model_t *model);
void free_metal_layers(PDN_metal_t l);
void free_TSV(PDN_TSV_t t);
void free_IVR(IVR_t *v);
void free_PDN_C4(PDN_C4_t *p);
void free_model_vector(model_vector_t *v);
/* block, grid and flp */
void PDN_xlate_vector_b2g(model_t *model, double *b, model_vector_t *g);
void set_bgmap_PDN(model_t *model, PDN_layer_t *layer);
void reset_b2gmap_PDN(model_t *model, PDN_layer_t *layer);
blist_t ***new_b2gmap_PDN(int rows, int cols);
blist_t *new_blist_PDN(int idx, double occupancy);
double blist_avg_PDN(blist_t *ptr, PDN_flp_t *flp, double *v);
void blist_append_PDN(blist_t *head, int idx, double occupancy);
void delete_b2gmap_PDN(blist_t ***b2gmap, int rows, int cols);
/* Multi branch */
void parse_metal_layer_file(model_t *model, char *file, int layer);
/* decap distribution */
int decap_under_blk(model_t *model, int idx, int layer);
double get_onchip_cap(model_t *model, int idx, int layer);
/* Steady state */
void steady_state_PDN(model_t *model, double *power);
void steady_state_PDN_regular(model_t *model, double *power);
void steady_state_PDN_vs(model_t *model, double *power);
SuperMatrix build_steady_grid_matrix(model_t *model);
SuperMatrix build_steady_rhs_vector(model_t *model, model_vector_t *power, double **rhs);
SuperMatrix build_steady_grid_matrix_vs(model_t *model, model_vector_t *power);
SuperMatrix build_steady_rhs_vector_vs(model_t *model, double **rhs);
void set_heuristic_vol_PDN_regular(model_t *model, double *temp, model_vector_t *power);
void set_heuristic_vol_PDN_vs(model_t *model, double *temp, model_vector_t *power);
void compute_pkg_vol(model_t *model, model_vector_t *temp, model_vector_t *power);
/* Transient state */
int PDN_trans_matrix_dim(model_t *model);
void PDN_init_trans_vector(model_t *model, double *g);
void trans_SLU_init(model_t *model, double *power, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U, int *perm_c, int *perm_r);
void trans_SLU_init_nogridL(model_t *model, double *power, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U, int *perm_c, int *perm_r);
void trans_matrix_build_3D(model_t *model, double *power, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U, int **perm_c, int **perm_r);
void compute_PDN_SLU(model_t *model, double *power, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U, int *perm_c, int *perm_r);
void Finalize_rhs(model_t *model, model_vector_t *power);
/* Matrix Operation */
int PadIdx_to_GridIdx(model_t *model, int idx, int layer);
int GridIdx_to_PadIdx(model_t *model, int idx, int layer);
char *GridIdx_to_UnitName(model_t *model, int idx, int layer);
/* Domain */
int compare_domain(model_t *model, int idx, int offset);
int does_branch_exist(model_t *model, int idx);
void set_flp_domain(PDN_flp_t *flp, PDN_config_t *config);
int get_core_id(char *blk_name);
/* SC converters */
void switch_SCconverters(model_t *model, int counter, int intvl);
#endif
</document_content>
</document>
<document index="16">
<source>README-2.0</source>
<document_content>
VoltSpot-2.0 Changes
-------------------------
Contact: Mircea Stan, mircea@virginia.edu
For more information and a list of related publications, 
visit http://lava.cs.virginia.edu/VoltSpot/.
1. New in VoltSpot 2.0
	a) An extension for 3D-ICs' PDN simulation. Both steady-state
  and transient mode are supported. TSVs are modeled as RL pairs.
	b) Support the voltage-stacked PDN structure for 3D-IC.
  Switched-capacitor converters are included in both steady-state
  and transient models.
2. Modifications from the previous version 
	a) When dumping/parsing padlocation files, VoltSpot 1.0 assumes that
  the y-axis coordinate starts from 1. rev2.0 changed this and it assumes
  that all coordinates starts with 0.
	b) Trimmed down the file size of PDN_sim.c by tacking the matrix construction
  part out as a separate file, matrix.c
	c) Bug fixes
</document_content>
</document>
<document index="17">
<source>README_archive/README-1.0</source>
<document_content>
 
VoltSpot source code has the following files:
0. Makefile - for building VoltSpot
1. voltspot.c, voltspot.h - top level module.
   - Parse cmd line, parse flp file, allocate model data structure,
     read power file, pass power trace to PDN simulation/analysis module,
     output results, release memory.
2. PDN_sim.h and PDN_sim.c - the core voltage/current model module. 
	 - Construct matrices describing the modling circuit, solve the static 
     equations with direct LU decomposition or transient ODEs with implicit 
     trapezoidal numerical method (plus direct LU decomposition).
	 - Main functions: PDN_steady_SLU(...) and compute_PDN_SLU(...)
3. PDN_analyze.h and PDN_analyze.c - the results analysis module. 
	 - Analyse PDN's current/voltage status
	 - Main functions: PDN_steady_analyze(...) and PDN_trans_analyze(...)
4. pad.h and pad.c - for C4 pads manipulation
	 - Parse/dump pad location specification files. Process geometric info.
5. flp.h and flp.c  - the floorplanning module. 
	 - Read the floorplan description of the processor from a file
	   (example.flp) and provide the area and adjacency information required by
	   PDN_sim.c through function calls. 
6. util.h and util.c - miscellaneous utilities for printing error messages,
finding max of two numbers, array construction/destruction etc.
 
</document_content>
</document>
<document index="18">
<source>example.flp</source>
<document_content>
# Line Format: <unit-name>\t<width>\t<height>\t<left-x>\t<bottom-y>
# all dimensions are in meters
# comment lines begin with a '#'
# comments and empty lines are ignored
MC1	0.0107638	0.000586879	0	0.0101769
FPU1	0.00245284	0.00228849	0.00292907	0.00788844
ALU1	0.00292907	0.00116224	8.88178e-19	0.0090147
IntRF1	0.000816866	0.000496292	0.0021122	0.00851841
CplALU1	0.000816866	0.000347291	0.0021122	0.00788844
FlpRF1	0.000816866	0.000282674	0.0021122	0.00823574
ROB1	0.00078864	0.00112626	1.44329e-18	0.00788844
IntIW1	0.00132356	0.000809966	0.00078864	0.00820474
FlpIW1	0.00132356	0.00031629	0.00078864	0.00788844
IntRAT1	0.00131936	0.000545465	0.00084577	0.00734298
FL1	7.11392e-05	0.000545465	6.10623e-19	0.00734298
FlpRAT1	0.000774631	0.000545465	7.11392e-05	0.00734298
Dtlb1	0.00176342	0.000194825	0.000401711	0.00542805
Itlb1	0.000401711	0.000194825	1.11022e-18	0.00542805
InstDec1	0.00167306	0.00133815	0.000492069	0.00600483
BTB1	0.00110251	0.00038196	0.00106262	0.00562287
InstBuf1	8.78282e-05	0.00038196	0.000492069	0.00562287
BrP1	0.00048272	0.00038196	0.000579897	0.00562287
ICache1	0.000492069	0.00172011	6.66134e-19	0.00562287
StQ1	0.00258163	0.000544255	0.00280028	0.00734419
LdQ1	0.000635156	0.000544255	0.00216513	0.00734419
DCache1	0.00321678	0.00191614	0.00216513	0.00542805
NoC1	0.00538191	0.000175968	0	0.00525208
L2_1	0.00538191	0.00525208	0	0
FPU2	0.00245284	0.00228849	0.00538191	0.00788844
ALU2	0.00292907	0.00116224	0.00783475	0.0090147
IntRF2	0.000816866	0.000496292	0.00783475	0.00851841
CplALU2	0.000816866	0.000347291	0.00783475	0.00788844
FlpRF2	0.000816866	0.000282674	0.00783475	0.00823574
ROB2	0.00078864	0.00112626	0.00997518	0.00788844
IntIW2	0.00132356	0.000809966	0.00865161	0.00820474
FlpIW2	0.00132356	0.00031629	0.00865161	0.00788844
IntRAT2	0.00131936	0.000545465	0.00859869	0.00734298
FL2	7.11392e-05	0.000545465	0.0106927	0.00734298
FlpRAT2	0.000774631	0.000545465	0.00991805	0.00734298
Dtlb2	0.00176342	0.000194825	0.00859869	0.00542805
Itlb2	0.000401711	0.000194825	0.0103621	0.00542805
InstDec2	0.00167306	0.00133815	0.00859869	0.00600483
BTB2	0.00110251	0.00038196	0.00859869	0.00562287
InstBuf2	8.78282e-05	0.00038196	0.0101839	0.00562287
BrP2	0.00048272	0.00038196	0.0097012	0.00562287
ICache2	0.000492069	0.00172011	0.0102717	0.00562287
StQ2	0.00258163	0.000544255	0.00538191	0.00734419
LdQ2	0.000635156	0.000544255	0.00796354	0.00734419
DCache2	0.00321678	0.00191614	0.00538191	0.00542805
NoC2	0.00538191	0.000175968	0.00538191	0.00525208
L2_2	0.00538191	0.00525208	0.00538191	0
</document_content>
</document>
<document index="19">
<source>example.mlcf</source>
<document_content>
#Lines starting with # are used for commenting
#Blank lines are also ignored
#File Format:
#<Layer Number> start from 0
#<metal pitch     in m>
#<metal width     in m>
#<metal thickness in m>
#<metal Resistivity>
#<Direction 0/1 (x/y or h/v)>
#Example
#0
#30e-6
#10e-6
#3.5e-6
#1.68e-8 
#0
# Please make sure that:
# 1. adjacent metal layers have different direction
# 2. metal layer 0 is horizontal (0)
0
30e-6
10e-6
3.5e-6
1.68e-8 
0
1
30e-6
10e-6
3.5e-6
1.68e-8 
1
2
810e-9
400e-9
720e-9
1.68e-8 
0
3
810e-9
400e-9
720e-9
1.68e-8 
1
</document_content>
</document>
<document index="20">
<source>example.ptrace</source>
<document_content>
ICache1	BTB1	BrP1	InstBuf1	InstDec1	IntRAT1	FlpRAT1	FL1	DCache1	LdQ1	StQ1	Itlb1	Dtlb1	IntRF1	FlpRF1	IntIW1	FlpIW1	ROB1	ALU1	FPU1	CplALU1	ICache2	BTB2	BrP2	InstBuf2	InstDec2	IntRAT2	FlpRAT2	FL2	DCache2	LdQ2	StQ2	Itlb2	Dtlb2	IntRF2	FlpRF2	IntIW2	FlpIW2	ROB2	ALU2	FPU2	CplALU2	NoC1	NoC2	L2_1	L2_2	MC1	
0.041317	0.024366	0.078987	0.000862	0.325606	0.711282	0.011022	0.076530	0.368112	0.137571	0.680707	0.006080	0.018045	0.030626	0.017987	0.082269	0.032778	0.668003	2.438289	1.330769	0.167462	0.041317	0.024366	0.014261	0.047923	0.657421	1.036382	0.240651	0.086399	0.368112	0.005238	0.053879	0.006080	0.018045	0.058305	0.033752	0.305777	0.194535	0.535456	2.670714	1.714015	0.186831	0	0	0.936133	0.936133	0.273052	
......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......    ......        ......    ......         
0.041317	0.024366	0.014261	0.047923	0.657421	0.015959	0.011022	0.000472	0.368112	0.005238	0.053879	0.006080	0.018045	0.042738	0.003355	0.164650	0.139425	0.280928	1.864196	0.975065	0.149485	0.284873	0.114701	0.078987	0.000862	0.325606	0.467952	0.011022	0.053814	0.368112	0.005238	0.053879	0.122272	0.018045	0.037242	0.021755	0.099764	0.039610	0.351707	2.135473	2.497484	0.172091	0	0	0.936133	0.936133	0.273052	
</document_content>
</document>
<document index="21">
<source>example.senloc</source>
<document_content>
# Line Format: <sensor_location_s>\t<sensor_location_y>
# location uses virtual coordinate system
# comment lines begin with a '#'
# comments and empty lines are ignored
18 18
18 36
36 18
36 36
</document_content>
</document>
<document index="22">
<source>example.vgrid.padloc</source>
<document_content>
# Lines starting with # are used for commenting
# Blank lines are also ignored
# Line Format: <Vdd_or_Ground>\t<x-location>\t<y-location>
# The location could either use pad-grid's or virtual-grid's coordinate system
# Use options -padloc_format to specify which coordinate system is used
V	4	72
G	6	72
V	12	72
G	14	72
... ... ...
V	68	0
G	70	0
V	72	0
</document_content>
</document>
<document index="23">
<source>flp.c</source>
<document_content>
#include <stdio.h>
#include <string.h>
#include <string.h>
#ifdef _MSC_VER
#define strcasecmp    _stricmp
#define strncasecmp   _strnicmp
#else
#include <strings.h>
#endif
#include <stdlib.h>
#include <math.h>
#include "flp.h"
#include "util.h"
/* translate the floorplan to new origin (x,y)	*/
void PDN_flp_translate(PDN_flp_t *flp, double x, double y)
{
	int i;
	double minx = flp->units[0].leftx;
	double miny = flp->units[0].bottomy;
	for (i=1; i < flp->n_units; i++) {
		if (minx > flp->units[i].leftx)
			minx = flp->units[i].leftx;
		if (miny > flp->units[i].bottomy)
			miny = flp->units[i].bottomy;
	}
	for (i=0; i < flp->n_units; i++) {
		flp->units[i].leftx += (x - minx);
		flp->units[i].bottomy += (y - miny);
	}
}
/* scale the floorplan by a factor 'factor'	*/
//void flp_scale(PDN_flp_t *flp, double factor)
//{
//	int i;
//	double minx = flp->units[0].leftx;
//	double miny = flp->units[0].bottomy;
//
//	for (i=1; i < flp->n_units; i++) {
//		if (minx > flp->units[i].leftx)
//			minx = flp->units[i].leftx;
//		if (miny > flp->units[i].bottomy)
//			miny = flp->units[i].bottomy;
//	}
//	for(i=0; i < flp->n_units; i++) {
//		flp->units[i].leftx = (flp->units[i].leftx - minx) * factor + minx;
//		flp->units[i].bottomy = (flp->units[i].bottomy - miny) * factor + miny;
//		flp->units[i].width *= factor;
//		flp->units[i].height *= factor;
//	}
//}
/* 
 * change the orientation of the floorplan by
 * rotating and/or flipping. the target orientation
 * is specified in 'target'. 'width', 'height', 'xorig'
 * and 'yorig' are those of 'flp' respectively.
 */
//void flp_change_orient(PDN_flp_t *flp, double xorig, double yorig,
//					   double width, double height, orient_t target)
//{
//	int i;
//
//	for(i=0; i < flp->n_units; i++) {
//		double leftx, bottomy, rightx, topy;
//		/* all co-ordinate calculations are 
//		 * done assuming (0,0) as the center. 
//		 * so, shift accordingly
//		 */
//		leftx = flp->units[i].leftx  - (xorig + width / 2.0);
//		bottomy = flp->units[i].bottomy - (yorig + height / 2.0);
//		rightx = leftx + flp->units[i].width;
//		topy = bottomy + flp->units[i].height;
//		/* when changing orientation, leftx and 
//		 * bottomy of a rectangle could change
//		 * to one of the other three corners. 
//		 * also, signs of the co-ordinates
//		 * change according to the rotation
//		 * or reflection. Further x & y are
//		 * swapped for rotations that are
//		 * odd multiples of 90 degrees
//		 */
//		switch(target) {
//			case ROT_0:
//					flp->units[i].leftx = leftx;
//					flp->units[i].bottomy = bottomy;
//					break;
//			case ROT_90:
//					flp->units[i].leftx = -topy;
//					flp->units[i].bottomy = leftx;
//					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
//					break;
//			case ROT_180:
//					flp->units[i].leftx = -rightx;
//					flp->units[i].bottomy = -topy;
//					break;
//			case ROT_270:
//					flp->units[i].leftx = bottomy;
//					flp->units[i].bottomy = -rightx;
//					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
//					break;
//			case FLIP_0:
//					flp->units[i].leftx = -rightx;
//					flp->units[i].bottomy = bottomy;
//					break;
//			case FLIP_90:
//					flp->units[i].leftx = bottomy;
//					flp->units[i].bottomy = leftx;
//					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
//					break;
//			case FLIP_180:
//					flp->units[i].leftx = leftx;
//					flp->units[i].bottomy = -topy;
//					break;
//			case FLIP_270:
//					flp->units[i].leftx = -topy;
//					flp->units[i].bottomy = -rightx;
//					swap_dval(&(flp->units[i].width), &(flp->units[i].height));
//					break;
//			default:
//					fatal("unknown orientation\n");
//					break;
//		}
//		/* translate back to original origin	*/
//		flp->units[i].leftx += (xorig + width / 2.0);
//		flp->units[i].bottomy += (yorig + height / 2.0);
//	}
//}
/* 
 * find the number of units from the 
 * floorplan file
 */
int PDN_flp_count_units(FILE *fp)
{
    char str1[LINE_SIZE], str2[LINE_SIZE];
	char name[STR_SIZE];
	double leftx, bottomy, width, height;
	char *ptr;
    int count = 0;
	fseek(fp, 0, SEEK_SET);
	while(!feof(fp)) {
		fgets(str1, LINE_SIZE, fp);
		strcpy(str2, str1);
		
		/* ignore comments and empty lines	*/
		ptr = strtok(str1, " \r\t\n");
		if (!ptr || ptr[0] == '#')
			continue;
		/* functional block placement information	*/
		if (sscanf(str2, "%s%lf%lf%lf%lf", name, &leftx, &bottomy,
		  		   &width, &height) == 5)
			count++;
		if (feof(fp))
			break;
	}
	return count;
}
PDN_flp_t *PDN_flp_alloc_init_mem(int count)
{
	int i;
	PDN_flp_t *flp;
	flp = (PDN_flp_t *) calloc (1, sizeof(PDN_flp_t));
	if(!flp)
		fatal("memory allocation error\n");
	flp->units = (PDN_unit_t *) calloc(count, sizeof(PDN_unit_t));
	//flp->wire_density = (double **) calloc(count, sizeof(double *));
	//if (!flp->units || !flp->wire_density)
	if (!flp->units)
		fatal("memory allocation error\n");
	flp->n_units = count;
	//for (i=0; i < count; i++) {
	//  flp->wire_density[i] = (double *) calloc(count, sizeof(double));
	//  if (!flp->wire_density[i])
	//  	fatal("memory allocation error\n");
	//}
	return flp;
}
/* populate block information	*/
void PDN_flp_populate_blks(PDN_flp_t *flp, FILE *fp)
{
	int i=0;
	char str[LINE_SIZE], copy[LINE_SIZE]; 
	char name1[STR_SIZE], name2[STR_SIZE];
	double width, height, leftx, bottomy;
	//double wire_density;
	char *ptr;
	fseek(fp, 0, SEEK_SET);
	while(!feof(fp)) {		/* second pass	*/
		fgets(str, LINE_SIZE, fp);
		if (feof(fp))
			break;
		strcpy(copy, str);
		/* ignore comments and empty lines	*/
		ptr = strtok(str, " \r\t\n");
		if (!ptr || ptr[0] == '#')
			continue;
		if (sscanf(copy, "%s%lf%lf%lf%lf", name1, &width, &height, 
				   &leftx, &bottomy) == 5) {
			strcpy(flp->units[i].name, name1);
			flp->units[i].width = width;
			flp->units[i].height = height;
			flp->units[i].leftx = leftx;
			flp->units[i].bottomy = bottomy;
			i++;
			/* skip connectivity info	*/
    } else// if (sscanf(copy, "%s%s%lf", name1, name2, &wire_density) != 3) 
      fatal("invalid floorplan file format\n");
	}
	if (i != flp->n_units)
	  fatal("mismatch of number of units\n");
}
/* populate connectivity info	*/
//void flp_populate_connects(PDN_flp_t *flp, FILE *fp)
//{
//	char str1[LINE_SIZE], str2[LINE_SIZE]; 
//	char name1[STR_SIZE], name2[STR_SIZE];
//	/* dummy fields	*/
//	double f1, f2, f3, f4, f5, f6;
//	double wire_density;
//	char *ptr;
//	int x, y, temp;
//
//	/* initialize wire_density	*/
//	for(x=0; x < flp->n_units; x++)
//		for(y=0; y < flp->n_units; y++)
//			flp->wire_density[x][y] = 0.0;
//
//	fseek(fp, 0, SEEK_SET);
//	while(!feof(fp)) {
//		fgets(str1, LINE_SIZE, fp);
//		if (feof(fp))
//			break;
//		strcpy(str2, str1);
//
//		/* ignore comments and empty lines	*/
//		ptr = strtok(str1, " \r\t\n");
//		if (!ptr || ptr[0] == '#')
//			continue;
//
//		/* lines with unit positions	*/
//		if (sscanf(str2, "%s%lf%lf%lf%lf%lf%lf", name1, &f1, &f2, &f3, &f4, &f5, &f6) == 7 ||
//		  	/* flp_desc like lines. ignore them	*/
//		  	sscanf(str2, "%s%lf%lf%lf%d", name1, &f1, &f2, &f3, &temp) == 5)
//			continue;
//
//		 /* lines with connectivity info	*/
//		else if (sscanf(str2, "%s%s%lf", name1, name2, &wire_density) == 3) {
//			x = PDN_get_blk_index(flp, name1);
//			y = PDN_get_blk_index(flp, name2);
//
//			if (x == y)
//				fatal("block connected to itself?\n");
//
//			if (!flp->wire_density[x][y] && !flp->wire_density[y][x])
//				flp->wire_density[x][y] = flp->wire_density[y][x] = wire_density;
//			else if((flp->wire_density[x][y] != flp->wire_density[y][x]) ||
//			        (flp->wire_density[x][y] != wire_density)) {
//				sprintf(str2, "wrong connectivity information for blocks %s and %s\n", 
//				        name1, name2);
//				fatal(str2);
//			}
//		} else 
//		  	fatal("invalid floorplan file format\n");
//	} /* end while	*/
//}
PDN_flp_t *PDN_read_flp(char *file)
{
	char str[STR_SIZE];
	FILE *fp;
	PDN_flp_t *flp;
	int count, i, j;
	if (!strcasecmp(file, "stdin"))
		fp = stdin;
	else
		fp = fopen (file, "r");
	if (!fp) {
		sprintf(str, "error opening file %s\n", file);
		fatal(str);
	}
	/* 1st pass - find n_units	*/
	count = PDN_flp_count_units(fp);
	if(!count)
		fatal("no units specified in the floorplan file\n");
	/* allocate initial memory */
	flp = PDN_flp_alloc_init_mem(count);
	/* 2nd pass - populate block info	*/
  PDN_flp_populate_blks(flp, fp);
  //for (i=0; i < flp->n_units; i++)
  //  for (j=0; j < flp->n_units; j++)
  //    flp->wire_density[i][j] = 1.0;
  if(fp != stdin)
    fclose(fp);	
  /* make sure the origin is (0,0)	*/
  PDN_flp_translate(flp, 0, 0);	
  return flp;
}
//void dump_flp(PDN_flp_t *flp, char *file, int dump_connects)
//{
//	char str[STR_SIZE];
//	int i, j;
//	FILE *fp;
//
//	if (!strcasecmp(file, "stdout"))
//		fp = stdout;
//	else if (!strcasecmp(file, "stderr"))
//		fp = stderr;
//	else 	
//		fp = fopen (file, "w");
//
//	if (!fp) {
//		sprintf(str, "error opening file %s\n", file);
//		fatal(str);
//	}
//	/* functional unit placement info	*/
//	for(i=0; i < flp->n_units; i++)  {
//		fprintf(fp, "%s\t%.11f\t%.11f\t%.11f\t%.11f\n",
//				flp->units[i].name, flp->units[i].width, flp->units[i].height,
//				flp->units[i].leftx, flp->units[i].bottomy);
//	}
//
//	if (dump_connects) {
//		fprintf(fp, "\n");
//		/* connectivity information	*/
//		for(i=1; i < flp->n_units; i++)
//			for(j=0; j < i; j++)
//				if (flp->wire_density[i][j])
//					fprintf(fp, "%s\t%s\t%.3f\n", flp->units[i].name,
//							flp->units[j].name, flp->wire_density[i][j]);
//	}
//	
//	if(fp != stdout && fp != stderr)
//		fclose(fp);
//}
void PDN_free_flp(PDN_flp_t *flp)
{
  int i;
  //for (i=0; i < flp->n_units + compacted; i++) {
  //    free(flp->wire_density[i]);
  //}
  free(flp->units);
  //free(flp->wire_density);
  free(flp);
}
//void print_flp_fig (PDN_flp_t *flp)
//{
//	int i;
//	double leftx, bottomy, rightx, topy;
//
//	fprintf(stdout, "FIG starts\n");
//	for (i=0; i< flp->n_units; i++) {
//		leftx = flp->units[i].leftx;
//		bottomy = flp->units[i].bottomy;
//		rightx = flp->units[i].leftx + flp->units[i].width;
//		topy = flp->units[i].bottomy + flp->units[i].height;
//		fprintf(stdout, "%.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f\n", 
//			    leftx, bottomy, leftx, topy, rightx, topy, rightx, bottomy, 
//				leftx, bottomy);
//		fprintf(stdout, "%s\n", flp->units[i].name);
//	}
//	fprintf(stdout, "FIG ends\n");
//}
/* debug print	*/
//void print_flp (PDN_flp_t *flp)
//{
//	int i, j;
//
//	fprintf(stdout, "printing floorplan information for %d blocks\n", flp->n_units);
//	fprintf(stdout, "name\tarea\twidth\theight\tleftx\tbottomy\trightx\ttopy\n");
//	for (i=0; i< flp->n_units; i++) {
//		double area, width, height, leftx, bottomy, rightx, topy;
//		char *name;
//		name = flp->units[i].name;
//		width = flp->units[i].width;
//		height = flp->units[i].height;
//		area = width * height;
//		leftx = flp->units[i].leftx;
//		bottomy = flp->units[i].bottomy;
//		rightx = flp->units[i].leftx + flp->units[i].width;
//		topy = flp->units[i].bottomy + flp->units[i].height;
//		fprintf(stdout, "%s\t%lg\t%lg\t%lg\t%lg\t%lg\t%lg\t%lg\n", 
//			    name, area, width, height, leftx, bottomy, rightx, topy);
//	}
//	fprintf(stdout, "printing connections:\n");
//	for (i=0; i< flp->n_units; i++)
//		for (j=i+1; j < flp->n_units; j++)
//			if (flp->wire_density[i][j])
//				fprintf(stdout, "%s\t%s\t%lg\n", flp->units[i].name, 
//						flp->units[j].name, flp->wire_density[i][j]);
//}
int PDN_get_blk_index(PDN_flp_t *flp, char *name)
{
  int i;
  char msg[STR_SIZE];
  if (!flp)
    fatal("null pointer in PDN_get_blk_index\n");
  for (i = 0; i < flp->n_units; i++) {
      if (!strcasecmp(name, flp->units[i].name)) {
          return i;
      }
  }
  sprintf(msg, "block %s not found\n", name);
  fatal(msg);
  return -1;
}
//int is_horiz_adj(PDN_flp_t *flp, int i, int j)
//{
//	double x1, x2, x3, x4;
//	double y1, y2, y3, y4;
//
//	if (i == j) 
//		return FALSE;
//
//	x1 = flp->units[i].leftx;
//	x2 = x1 + flp->units[i].width;
//	x3 = flp->units[j].leftx;
//	x4 = x3 + flp->units[j].width;
//
//	y1 = flp->units[i].bottomy;
//	y2 = y1 + flp->units[i].height;
//	y3 = flp->units[j].bottomy;
//	y4 = y3 + flp->units[j].height;
//
//	/* diagonally adjacent => not adjacent */
//	if (eq(x2,x3) && eq(y2,y3))
//		return FALSE;
//	if (eq(x1,x4) && eq(y1,y4))
//		return FALSE;
//	if (eq(x2,x3) && eq(y1,y4))
//		return FALSE;
//	if (eq(x1,x4) && eq(y2,y3))
//		return FALSE;
//
//	if (eq(x1,x4) || eq(x2,x3))
//		if ((y3 >= y1 && y3 <= y2) || (y4 >= y1 && y4 <= y2) ||
//		    (y1 >= y3 && y1 <= y4) || (y2 >= y3 && y2 <= y4))
//			return TRUE;
//
//	return FALSE;
//}
//int is_vert_adj (PDN_flp_t *flp, int i, int j)
//{
//	double x1, x2, x3, x4;
//	double y1, y2, y3, y4;
//
//	if (i == j)
//		return FALSE;
//
//	x1 = flp->units[i].leftx;
//	x2 = x1 + flp->units[i].width;
//	x3 = flp->units[j].leftx;
//	x4 = x3 + flp->units[j].width;
//
//	y1 = flp->units[i].bottomy;
//	y2 = y1 + flp->units[i].height;
//	y3 = flp->units[j].bottomy;
//	y4 = y3 + flp->units[j].height;
//
//	/* diagonally adjacent => not adjacent */
//	if (eq(x2,x3) && eq(y2,y3))
//		return FALSE;
//	if (eq(x1,x4) && eq(y1,y4))
//		return FALSE;
//	if (eq(x2,x3) && eq(y1,y4))
//		return FALSE;
//	if (eq(x1,x4) && eq(y2,y3))
//		return FALSE;
//
//	if (eq(y1,y4) || eq(y2,y3))
//		if ((x3 >= x1 && x3 <= x2) || (x4 >= x1 && x4 <= x2) ||
//		    (x1 >= x3 && x1 <= x4) || (x2 >= x3 && x2 <= x4))
//			return TRUE;
//
//	return FALSE;
//}
//double get_shared_len(PDN_flp_t *flp, int i, int j)
//{
//	double p11, p12, p21, p22;
//	p11 = p12 = p21 = p22 = 0.0;
//
//	if (i==j) 
//		return FALSE;
//
//	if (is_horiz_adj(flp, i, j)) {
//		p11 = flp->units[i].bottomy;
//		p12 = p11 + flp->units[i].height;
//		p21 = flp->units[j].bottomy;
//		p22 = p21 + flp->units[j].height;
//	}
//
//	if (is_vert_adj(flp, i, j)) {
//		p11 = flp->units[i].leftx;
//		p12 = p11 + flp->units[i].width;
//		p21 = flp->units[j].leftx;
//		p22 = p21 + flp->units[j].width;
//	}
//
//	return (MIN(p12, p22) - MAX(p11, p21));
//}
double PDN_get_total_width(PDN_flp_t *flp)
{	
  int i;
  double min_x = flp->units[0].leftx;
  double max_x = flp->units[0].leftx + flp->units[0].width;
  for (i=1; i < flp->n_units; i++) {
      if (flp->units[i].leftx < min_x)
        min_x = flp->units[i].leftx;
      if (flp->units[i].leftx + flp->units[i].width > max_x)
        max_x = flp->units[i].leftx + flp->units[i].width;
  }
  return (max_x - min_x);
}
double PDN_get_total_height(PDN_flp_t *flp)
{	
  int i;
  double min_y = flp->units[0].bottomy;
  double max_y = flp->units[0].bottomy + flp->units[0].height;
  for (i=1; i < flp->n_units; i++) {
      if (flp->units[i].bottomy < min_y)
        min_y = flp->units[i].bottomy;
      if (flp->units[i].bottomy + flp->units[i].height > max_y)
        max_y = flp->units[i].bottomy + flp->units[i].height;
  }
  return (max_y - min_y);
}
//double get_minx(PDN_flp_t *flp)
//{
//	int i;
//	double min_x = flp->units[0].leftx;
//	
//	for (i=1; i < flp->n_units; i++)
//		if (flp->units[i].leftx < min_x)
//			min_x = flp->units[i].leftx;
//
//	return min_x;
//}
//double get_miny(PDN_flp_t *flp)
//{
//	int i;
//	double min_y = flp->units[0].bottomy;
//	
//	for (i=1; i < flp->n_units; i++)
//		if (flp->units[i].bottomy < min_y)
//			min_y = flp->units[i].bottomy;
//
//	return min_y;
//}
/* precondition: L2 should have been wrapped around	*/
//double get_core_width(PDN_flp_t *flp, char *l2_label)
//{
//	int i;
//	double min_x = LARGENUM;
//	double max_x = -LARGENUM;
//	
//	for (i=0; i < flp->n_units; i++) {
//		/* core is that part of the chip excluding the l2 and rim	*/
//		if (strstr(flp->units[i].name, l2_label) != flp->units[i].name &&
//			strstr(flp->units[i].name, RIM_PREFIX) != flp->units[i].name) {
//			if (flp->units[i].leftx < min_x)
//				min_x = flp->units[i].leftx;
//			if (flp->units[i].leftx + flp->units[i].width > max_x)
//				max_x = flp->units[i].leftx + flp->units[i].width;
//		}		
//	}
//
//	return (max_x - min_x);
//}
/* precondition: L2 should have been wrapped around	*/
//double get_core_height(PDN_flp_t *flp, char *l2_label)
//{	
//	int i;
//	double min_y = LARGENUM;
//	double max_y = -LARGENUM;
//	
//	for (i=0; i < flp->n_units; i++) {
//		/* core is that part of the chip excluding the l2 and rim	*/
//		if (strstr(flp->units[i].name, l2_label) != flp->units[i].name &&
//			strstr(flp->units[i].name, RIM_PREFIX) != flp->units[i].name) {
//			if (flp->units[i].bottomy < min_y)
//				min_y = flp->units[i].bottomy;
//			if (flp->units[i].bottomy + flp->units[i].height > max_y)
//				max_y = flp->units[i].bottomy + flp->units[i].height;
//		}		
//	}
//
//	return (max_y - min_y);
//}
//double get_total_area(PDN_flp_t *flp)
//{
//	int i;
//	double area = 0.0;
//	for(i=0; i < flp->n_units; i++)
//		area += flp->units[i].width * flp->units[i].height;
//	return area;	
//}
//double get_core_area(PDN_flp_t *flp, char *l2_label)
//{
//	int i;
//	double area = 0.0;
//	for(i=0; i < flp->n_units; i++)
//		if (strstr(flp->units[i].name, l2_label) != flp->units[i].name &&
//			strstr(flp->units[i].name, RIM_PREFIX) != flp->units[i].name)
//			area += flp->units[i].width * flp->units[i].height;
//	return area;		
//}
/* excluding the dead blocks	*/
//double get_core_occupied_area(PDN_flp_t *flp, char *l2_label)
//{
//	int i, num;
//	double dead_area = 0.0;
//	for(i=0; i < flp->n_units; i++) {
//		/* 
//		 * there can be a max of n-1 dead blocks where n is the
//		 * number of non-dead blocks (since each cut, vertical
//		 * or horizontal, can correspond to a maximum of one
//		 * dead block
//		 */
//		if ((sscanf(flp->units[i].name, DEAD_PREFIX"%d", &num) == 1) &&
//			(num < (flp->n_units-1) / 2))
//			dead_area += flp->units[i].width * flp->units[i].height;
//	}		
//	return get_core_area(flp, l2_label) - dead_area;	
//}
//double get_manhattan_dist(PDN_flp_t *flp, int i, int j)
//{
//	double x1 = flp->units[i].leftx + flp->units[i].width / 2.0;
//	double y1 = flp->units[i].bottomy + flp->units[i].height / 2.0;
//	double x2 = flp->units[j].leftx + flp->units[j].width / 2.0;
//	double y2 = flp->units[j].bottomy + flp->units[j].height / 2.0;
//	return (fabs(x2-x1) + fabs(y2-y1));
//}
</document_content>
</document>
<document index="24">
<source>flp.h</source>
<document_content>
#ifndef __FLP_H_
#define __FLP_H_
#include "util.h"
#define MAX_UNITS		8192
/* 
 * chip edge has true dead space, which is 
 * modeled by the following blocks
 */
#define RIM_LEFT		1
#define RIM_RIGHT		2
#define RIM_TOP			4
#define RIM_BOTTOM		8
#define RIM_PREFIX		"RIM"
#define RIM_LEFT_STR	RIM_PREFIX"_left"
#define RIM_RIGHT_STR	RIM_PREFIX"_right"
#define RIM_TOP_STR		RIM_PREFIX"_top"
#define RIM_BOTTOM_STR	RIM_PREFIX"_bottom"
/* prefix denoting dead block	*/
#define DEAD_PREFIX		"_"
/* flags denoting orientation	*/
/* rotated orientations	*/
#define	ROT_0		0x01	/* normal	*/
#define	ROT_90		0x02	/* 90 degrees anticlockwise */
#define	ROT_180		0x04	/* 180 degrees anticlockwise */
#define	ROT_270		0x08	/* 270 degrees anticlockwise */
/* flipped + rotated orientations	*/
#define	FLIP_0		0x10	/* flip about y axis of ROT_0	*/
#define	FLIP_90		0x20	/* flip about y axis of ROT_90	*/
#define	FLIP_180	0x40	/* flip about y axis of ROT_180	*/
#define	FLIP_270	0x80	/* flip about y axis of ROT_270	*/
#define ORIENTS_N	8		/* total no. of orientations	*/
#define ORIENT_NDEF	0xDF	/* undefined orientation	*/
/* type for holding the above flags	*/
//typedef unsigned char orient_t;
/* placed functional unit */
typedef struct PDN_unit_t_st
{
	char name[STR_SIZE];
	int    domain; // For multi-domain PDN
	double width;
	double height;
	double leftx;
	double bottomy;
}PDN_unit_t;
/* floorplan data structure	*/
typedef struct PDN_flp_t_st
{
	PDN_unit_t *units;
	int n_units;
  int n_domain;
  /* density of wires between units	*/
  //double **wire_density;
} PDN_flp_t;
/* skip floorplanning and read floorplan directly from file */
PDN_flp_t *PDN_read_flp(char *file);
/* 
 * print the floorplan in a FIG like format 
 * that can be read by tofig.pl to produce 
 * an xfig output 
 */
//void print_flp_fig (PDN_flp_t *flp);
///* debug print	*/
//void print_flp (PDN_flp_t *flp);
///* translate the floorplan to new origin (x,y)	*/
void PDN_flp_translate(PDN_flp_t *flp, double x, double y);
///* scale the floorplan by a factor 'factor'	*/
//void flp_scale(PDN_flp_t *flp, double factor);
/* 
 * change the orientation of the floorplan by
 * rotating and/or flipping. the target orientation
 * is specified in 'target'. 'width', 'height', 'xorig'
 * and 'yorig' are those of 'flp' respectively.
 */
//void flp_change_orient(PDN_flp_t *flp, double xorig, double yorig,
//					   double width, double height, orient_t target);
/* dump the floorplan onto a file	*/
//void dump_flp(PDN_flp_t *flp, char *file, int dump_connects);
/* memory uninitialization	*/
void PDN_free_flp(PDN_flp_t *flp);
/* placed floorplan access routines	*/
///* get unit index from its name	*/
int PDN_get_blk_index(PDN_flp_t *flp, char *name);
///* are the units horizontally adjacent?	*/
//int is_horiz_adj(PDN_flp_t *flp, int i, int j);
///* are the units vertically adjacent?	*/
//int is_vert_adj (PDN_flp_t *flp, int i, int j);
///* shared length between units	*/
//double get_shared_len(PDN_flp_t *flp, int i, int j);
///* total chip width	*/
double PDN_get_total_width(PDN_flp_t *flp);
///* total chip height */
double PDN_get_total_height(PDN_flp_t *flp);
///* x and y origins	*/
//double get_minx(PDN_flp_t *flp);
//double get_miny(PDN_flp_t *flp);
///* precondition: L2 should have been wrapped around	*/
//double get_core_width(PDN_flp_t *flp, char *l2_label);
///* precondition: L2 should have been wrapped around	*/
//double get_core_height(PDN_flp_t *flp, char *l2_label);
///* other queries	*/
//double get_manhattan_dist(PDN_flp_t *flp, int i, int j);
//double get_total_area(PDN_flp_t *flp);
//double get_core_area(PDN_flp_t *flp, char *l2_label);
//double get_core_occupied_area(PDN_flp_t *flp, char *l2_label);
#endif
</document_content>
</document>
<document index="25">
<source>matrix.c</source>
<document_content>
#include <stdio.h>
#include <stdlib.h>
/* Lib for SuperLU */
#include "slu_ddefs.h"
#include "PDN_sim.h"
#include "util.h"
#include "pad.h"
SuperMatrix build_steady_grid_matrix(model_t *model)
{
  SuperMatrix A;
  double   *a;
  int      *asub, *xa;
  double   *cooV;
  int      *cooX, *cooY;
  int      i, j, l, m, n, nnz;
  int      direc;
  double   dia_val;
  int      curidx, grididx;
  int      xoffset, yoffset;
  int      has_pad;
  int      *padloc;
  int      num_tsv;
  double   Rx, Ry, Rv;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  double Rp = model->c4->pad_r;
  int is_3D = model->is_3D;
  int mtdmn  = model->config.PDN_multi_dom;
  //count the total number of TSVs
  num_tsv = 0;
  if(is_3D){
      for(l=0; l<nl-1; l++){
          num_tsv += model->layers[l].tsv.num_vdd;
          num_tsv += model->layers[l].tsv.num_gnd;
      }
  }
  /* Initialize matrix A. */
  /* Layout: L0v L1v ... Ln-1v L0g L1g ... Ln-1g  */
  m = n = 2 * nl * nc * nr;
  /* Num of non-zeros
   * Five diagonal, c*r, c*(r-1), (c-1)*r, c*(r-1), (c-1)*r
   */
  nnz = 5*nr*nc- 2*(nr+nc);
  nnz *= nl;
  nnz *= 2;  // both Vdd and Gnd
  nnz += 2*num_tsv;
  if ( !(cooV = doubleMalloc(nnz)) ) fatal("Malloc fails for cooV[].\n");
  if ( !(cooX = intMalloc(nnz)) ) fatal("Malloc fails for cooX[].\n");
  if ( !(cooY = intMalloc(nnz)) ) fatal("Malloc fails for cooY[].\n");
  if ( !(a = doubleMalloc(nnz)) ) fatal("Malloc fails for a[].\n");
  if ( !(asub = intMalloc(nnz)) ) fatal("Malloc fails for asub[].\n");
  if ( !(xa = intMalloc(n+1)) ) fatal("Malloc fails for xa[].\n");
  curidx = 0;
  /* VDD grid diagonal block */
  padloc = model->c4->vdd_loc[0];
  for(l=0; l<nl; l++){
      //calculate grid R
      Rx = 0; Ry = 0;
      for(i=0; i<model->layers[l].metal_layers.n_metal; i++){
          direc = model->layers[l].metal_layers.geo[i].direc;
          if(MLCF_X == direc)
            Rx += 1/model->layers[l].metal_layers.gridRL[i].r;
          else
            Ry += 1/model->layers[l].metal_layers.gridRL[i].r;
      }
      Rx = 1/Rx; Ry = 1/Ry;
      Rv = model->layers[l].tsv.r; //assume uniform TSV R
      xoffset = l*nr*nc;
      yoffset = l*nr*nc;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            if((0 == l) && (PGPAD & padloc[grididx]))
              has_pad = 1;
            else
              has_pad = 0;
            dia_val = 0;
            if(0 == grididx){//top left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if((nc-1) == grididx ){//top right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if((nr*nc-nc) == grididx){//bottom left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if((nr*nc-1) == grididx){//bottom right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if((grididx > 0) && (grididx < nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if(0 == (grididx%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if(0 == ((grididx+1)%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else{
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;}
                else{cooV[curidx] = 0; curidx++;}
            }
            if(is_3D){
                if((l<nl-1) && (VDDTSV == model->layers[l].tsv.loc[i][j])){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nr*nc+yoffset;
                    cooV[curidx] = -1/Rv; curidx++; dia_val += 1/Rv;
                }
                if((l>0) && (VDDTSV == model->layers[l-1].tsv.loc[i][j])){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nr*nc+yoffset;
                    cooV[curidx] = -1/Rv; curidx++; dia_val += 1/Rv;
                }
            }
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = has_pad ? (dia_val+1/Rp) : dia_val; curidx++;
        }
  }
  /* GND grid diagonal block */
  padloc = model->c4->gnd_loc[0];
  for(l=0; l<nl; l++){
      //calculate grid R
      Rx = 0; Ry = 0;
      for(i=0; i<model->layers[l].metal_layers.n_metal; i++){
          direc = model->layers[l].metal_layers.geo[i].direc;
          if(MLCF_X == direc)
            Rx += 1/model->layers[l].metal_layers.gridRL[i].r;
          else
            Ry += 1/model->layers[l].metal_layers.gridRL[i].r;
      }
      Rx = 1/Rx; Ry = 1/Ry;
      Rv = model->layers[l].tsv.r; //assume uniform TSV R
      xoffset = nl*nr*nc + l*nr*nc;
      yoffset = nl*nr*nc + l*nr*nc;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            dia_val = 0;
            if(0 == grididx){//top left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if((nc-1) == grididx ){//top right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if((nr*nc-nc) == grididx){//bottom left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if((nr*nc-1) == grididx){//bottom right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if((grididx > 0) && (grididx < nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if(0 == (grididx%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
            }
            else if(0 == ((grididx+1)%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
            }
            else{
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
            }
            if(is_3D){
                if((l<nl-1) && (GNDTSV == model->layers[l].tsv.loc[i][j])){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nr*nc+yoffset;
                    cooV[curidx] = -1/Rv; curidx++; dia_val += 1/Rv;
                }
                if((l>0) && (GNDTSV == model->layers[l-1].tsv.loc[i][j])){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nr*nc+yoffset;
                    cooV[curidx] = -1/Rv; curidx++; dia_val += 1/Rv;
                }
            }
            // bumps
            if((0 == l) && (PGPAD & padloc[grididx]))
              dia_val += 1/Rp; 
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = dia_val; curidx++;
        }
  }
  if(curidx != nnz)
    fatal("Steady-state Matrix build error: less elements than nnz\n");
  coo2csc(n, nnz, cooX, cooY, cooV, asub, xa, a);
  /* Create matrix A in the format expected by SuperLU. */
  dCreate_CompCol_Matrix(&A, m, n, nnz, a, asub, xa, SLU_NC, SLU_D, SLU_GE);
  free(cooV);
  free(cooX);
  free(cooY);
  return A;
}
SuperMatrix build_steady_rhs_vector(model_t *model, model_vector_t *power, double **rhs)
{
  SuperMatrix B;
  int      idx, nrhs;
  int      i, j, l;
  int      **loc;
  double   pkg_vdd, pkg_gnd;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int m  = 2 * nl * nr * nc;
  double Rp = model->c4->pad_r;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  pkg_vdd = model->last_steady[2*nl*nr*nc + PKG_VDD];
  pkg_gnd = model->last_steady[2*nl*nr*nc + PKG_GND];
  nrhs = 1;
  if ( !(*rhs = doubleMalloc(m*nrhs)) ) fatal("Malloc fails for rhs[].\n");
  //VDD layer
  for(l=0; l<nl; l++)
    for(i=0; i<nr; i++)
      for(j=0; j<nc; j++) {
          idx = l*nr*nc + i*nc + j ;
          loc = model->c4->vdd_loc;
          if((0 == l) && (PGPAD & loc[i][j])) // Bottom layer connecting to C4 pads
            (*rhs)[idx] = pkg_vdd/Rp - power->cuboid[l][i][j]/(vdd-gnd);
          else// I = P/v
            (*rhs)[idx] = -power->cuboid[l][i][j]/(vdd-gnd);
      }
  //GND layer
  for(l=0; l<nl; l++)
    for(i=0; i<nr; i++)
      for(j=0; j<nc; j++) {
          idx = nl*nr*nc + l*nr*nc + i*nc + j ;
          loc = model->c4->gnd_loc;
          if((0 == l) && (PGPAD & loc[i][j])) // Bottom layer connecting to C4 pads
            (*rhs)[idx] = pkg_gnd/Rp + power->cuboid[l][i][j]/(vdd-gnd);
          else// I = P/v
            (*rhs)[idx] = power->cuboid[l][i][j]/(vdd-gnd);
      }
  dCreate_Dense_Matrix(&B, m, nrhs, *rhs, m, SLU_DN, SLU_D, SLU_GE);
  return B;
}
SuperMatrix build_steady_grid_matrix_vs(model_t *model, model_vector_t *power)
{
  SuperMatrix A;
  double   *a;
  int      *asub, *xa;
  double   *cooV;
  int      *cooX, *cooY;
  int      i, j, k, l, m, n, nnz;
  int      cur_layer;
  int      direc;
  double   dia_val;
  int      curidx, grididx;
  int      xoffset, yoffset;
  int      num_tsv;
  double   Rx, Ry, Rp, Rv, Rivr, Rload;
  /* shortcuts	*/
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int *padloc_v = model->c4->vdd_loc[0];
  int *padloc_g = model->c4->gnd_loc[0];
  int *ivrloc = model->sc_converter->loc[0];
  int num_ivr = model->sc_converter->num_IVR;
  double vdd = model->config.vdd - model->config.gnd;
  // Count the total number of TSVs
  // Only using gnd TSVs to connect layers.
  // Vdd TSVs are used for top layer supply, but only the ones connected to bumps are populated
  num_tsv = 0;
  for(l=0; l<nl-1; l++)
    num_tsv += model->layers[l].tsv.num_gnd;
  /* Initialize matrix A. */
  /* Layout: L0g L0v L1g L1v ... Ln-1g Ln-1v */
  m = n = 2 * nl * nc * nr;
  /* Num of non-zeros
   * Five diagonal, c*r, c*(r-1), (c-1)*r, c*(r-1), (c-1)*r
   */
  nnz = 5*nr*nc- 2*(nr+nc);
  nnz *= nl;
  nnz *= 2;  // both Vdd and Gnd
  nnz += 2*num_tsv;
  nnz += 2*nl*nr*nc; // load resistors
  nnz += 2*(nl-2)*num_ivr; // for IVRs
  if ( !(cooV = doubleMalloc(nnz)) ) fatal("Malloc fails for cooV[].\n");
  if ( !(cooX = intMalloc(nnz)) ) fatal("Malloc fails for cooX[].\n");
  if ( !(cooY = intMalloc(nnz)) ) fatal("Malloc fails for cooY[].\n");
  if ( !(a = doubleMalloc(nnz)) ) fatal("Malloc fails for a[].\n");
  if ( !(asub = intMalloc(nnz)) ) fatal("Malloc fails for asub[].\n");
  if ( !(xa = intMalloc(n+1)) ) fatal("Malloc fails for xa[].\n");
  curidx = 0;
  for(l=0; l<2*nl; l++){
      //calculate grid R
      cur_layer = l >> 1;
      Rx = 0; Ry = 0;
      for(i=0; i<model->layers[cur_layer].metal_layers.n_metal; i++){
          direc = model->layers[cur_layer].metal_layers.geo[i].direc;
          if(MLCF_X == direc)
            Rx += 1/model->layers[cur_layer].metal_layers.gridRL[i].r;
          else
            Ry += 1/model->layers[cur_layer].metal_layers.gridRL[i].r;
      }
      Rx = 1/Rx; Ry = 1/Ry;
      Rv = model->layers[cur_layer].tsv.r; //assume uniform TSV R
      Rp = model->c4->pad_r;
      Rivr = model->sc_converter->R_drop;
      if((2*nl-1) == l)
        for(k=0; k<nl-1; k++)
          Rp += model->layers[k].tsv.r;
      xoffset = l*nr*nc;
      yoffset = l*nr*nc;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            if (power->cuboid[cur_layer][i][j] > 0)
              Rload = vdd*vdd/power->cuboid[cur_layer][i][j];
            else
              Rload = LARGEINT;
            dia_val = 0;
            if(0 == grididx){//top left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if((nc-1) == grididx ){//top right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if((nr*nc-nc) == grididx){//bottom left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if((nr*nc-1) == grididx){//bottom right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if((grididx > 0) && (grididx < nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
            }
            else if(0 == (grididx%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
            }
            else if(0 == ((grididx+1)%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
            }
            else{
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = -1/Ry; curidx++; dia_val += 1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = -1/Rx; curidx++; dia_val += 1/Rx;
            }
            if(l%2){//Vdd net
                // Load resistor
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nr*nc+yoffset;
                cooV[curidx] = -1/Rload; curidx++; dia_val += 1/Rload;
                // TSV
                if((cur_layer<nl-1) && (GNDTSV == model->layers[cur_layer].tsv.loc[i][j])){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nr*nc+yoffset;
                    cooV[curidx] = -1/Rv; curidx++; dia_val += 1/Rv;
                }
            }
            else{//Gnd net
                // Load resistor
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nr*nc+yoffset;
                cooV[curidx] = -1/Rload; curidx++; dia_val += 1/Rload;
                // TSV
                if((cur_layer>0) && (GNDTSV == model->layers[cur_layer-1].tsv.loc[i][j])){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nr*nc+yoffset;
                    cooV[curidx] = -1/Rv; curidx++; dia_val += 1/Rv;
                }
            }
            //add pads
            if(((0 == l) && (PGPAD & padloc_g[grididx])) || 
               ((2*nl-1 == l) && (PGPAD & padloc_v[grididx])))
              dia_val += 1/Rp;
            //add IVRs
            // head/foot room model
            if((l%2) && (cur_layer<nl-1) && (IVRLOC == ivrloc[grididx])){
                dia_val += 1/Rivr;
                if(cur_layer>0){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-2*nr*nc+yoffset;
                    cooV[curidx] = -1/(2*Rivr); curidx++;
                }
                if(cur_layer<nl-2){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+2*nr*nc+yoffset;
                    cooV[curidx] = -1/(2*Rivr); curidx++;
                }
            }
            // ideal voltage (l*Vdd) model
            //if((0 == l%2) && (l>0) && (IVRLOC == ivrloc[grididx]))
            //  dia_val += 1/Rivr;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = dia_val; curidx++;
        }
  }
  if(curidx != nnz)
    fatal("Steady-state Matrix build error: less elements than nnz\n");
  coo2csc(n, nnz, cooX, cooY, cooV, asub, xa, a);
  /* Create matrix A in the format expected by SuperLU. */
  dCreate_CompCol_Matrix(&A, m, n, nnz, a, asub, xa, SLU_NC, SLU_D, SLU_GE);
  free(cooV);
  free(cooX);
  free(cooY);
  return A;
}
SuperMatrix build_steady_rhs_vector_vs(model_t *model, double **rhs)
{
  SuperMatrix B;
  int      idx, nrhs;
  int      i, j, l, k;
  double   Rp, Rivr;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int m  = 2 * nl * nr * nc;
  int **padloc_v = model->c4->vdd_loc;
  int **padloc_g = model->c4->gnd_loc;
  int **ivrloc = model->sc_converter->loc;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  double *v = model->last_steady;
  nrhs = 1;
  if ( !(*rhs = doubleMalloc(m*nrhs)) ) fatal("Malloc fails for rhs[].\n");
  for(l=0; l<2*nl; l++){
      Rp = model->c4->pad_r;
      Rivr = model->sc_converter->R_drop;
      if((2*nl-1) == l)
        for(k=0; k<nl-1; k++)
          Rp += model->layers[k].tsv.r;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++) {
            idx = l*nr*nc + i*nc + j ;
            if((0 == l) && (PGPAD & padloc_g[i][j]))
              (*rhs)[idx] = gnd/Rp;
            else if((2*nl-1 == l) && (PGPAD & padloc_v[i][j]))
              (*rhs)[idx] = nl*vdd/Rp; // Stacking voltage multiplication
            else if((1==l) && (IVRLOC == ivrloc[i][j])){
                (*rhs)[idx] = 0;
            }
            else if((2*nl-3==l) && (IVRLOC == ivrloc[i][j])){
                (*rhs)[idx] += nl*vdd/(2*Rivr);
            }
            //else if((0 == l%2) && (l>0) && (IVRLOC == ivrloc[i][j]))
            //    (*rhs)[idx] = (l/2)*vdd/Rivr;
            else
              (*rhs)[idx] = 0;
        }
  }
  dCreate_Dense_Matrix(&B, m, nrhs, *rhs, m, SLU_DN, SLU_D, SLU_GE);
  return B;
}
void trans_SLU_init(model_t *model, double *power, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U, int *perm_c, int *perm_r)
{
  SuperMatrix B, Z;
  double   *a, *b, *rhs;
  int      *asub, *xa, *bsub, *xb;
  double   *cooV;
  int      *cooX, *cooY;
  int      info, i, j, l, m, n, nnz;
  int      tmp_i, tmp_j;
  int      xoffset, yoffset;
  int      grididx, curidx;
  superlu_options_t options;
  SuperLUStat_t stat;
  model_vector_t *p;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  int nml = model->layers[0].metal_layers.n_metal/2;
  int mtdmn  = model->config.PDN_multi_dom;
  double Rp  = model->c4->pad_r;
  double Lp  = model->c4->pad_l;
  double Rsp = model->config.PDN_pkg_sR;
  double Lsp = model->config.PDN_pkg_sL;
  double Rpp = model->config.PDN_pkg_pR;
  double Lpp = model->config.PDN_pkg_pL;
  double Cpp = model->config.PDN_pkg_C;
  double delta_t = 1/(model->config.proc_clock_freq*model->config.PDN_step_percycle);
  double Cg;
  metal_gridRL_t *g = model->layers[0].metal_layers.gridRL;
  /* Intermediate values */
  double iA = 1 / (nvp*Lsp/Lp + 1);
  double iB = 1 / (ngp*Lsp/Lp + 1);
  double iM = 1 / ((iA+iB)*Lsp + Lpp);
  double iN = iM * ((iA+iB)*Rsp + Rpp);
  double iP = Lsp / Lp;
  double iQ = Rsp / Lp;
  double iS = Rsp - iP*Rp;
  double iT = Rp / Lp;
  int nbr = 2*nr*nc - nr - nc;
  p = new_model_vector(model);
  /* map the block power/temp numbers to the grid	*/
  PDN_xlate_vector_b2g(model, power, p);
  copy_dvector(model->last_power, p->cuboid[0][0], nr*nc*nl);
  /* Initialize matrix A. */
  m = n = model->trans_matrix_dim;
  /* Num of non-zeros
   * Matrix for onchipI/onchipI:              5*(2*nr*nc-nr-nc)*mlayers*2
   * two diagnal block of zeros for grid V:   nr * nc + nr * nc
   * two dense block for pads:                nvp * nvp, ngp * ngp
   * pad<->grid side blocks:                  2 * nvp, 2 * ngp
   * row for Vc (extra 0 in diaganal):        1 + 1
   * row for Ic:                              2*nvp + 2*ngp + 2
   * col for Ic:                              nvp + ngp
   */
  nnz = 2*5*nbr*nml; 
  nnz += 2*nr*nc;
  nnz += nvp*nvp + ngp*ngp;
  nnz += 2*(nvp+ngp);
  if(model->config.PDN_pkgLC){
      nnz += 2*nvp + 2*ngp + 2;
      nnz += nvp + ngp + 2;
  }
  if ( !(cooV = doubleMalloc(nnz)) ) fatal("Malloc fails for cooV[].\n");
  if ( !(cooX = intMalloc(nnz)) ) fatal("Malloc fails for cooX[].\n");
  if ( !(cooY = intMalloc(nnz)) ) fatal("Malloc fails for cooY[].\n");
  // Create A
  if ( !(a = doubleMalloc(nnz)) ) fatal("Malloc fails for a[].\n");
  if ( !(asub = intMalloc(nnz)) ) fatal("Malloc fails for asub[].\n");
  if ( !(xa = intMalloc(n+1)) ) fatal("Malloc fails for xa[].\n");
  curidx = 0;
  /* Vdd pad dense block */
  xoffset = 0;
  yoffset = 0;
  for(i=0; i<nvp; i++)
    for(j=0; j<nvp; j++){
        cooX[curidx] = i + xoffset;
        cooY[curidx] = j + yoffset;
        if(i == j)
          cooV[curidx] = -iQ - iT;
        else
          cooV[curidx] = -iQ;
        curidx++;
    }
  /* Gnd pad dense block */
  xoffset = nvp + nr*nc + nbr*nml;
  yoffset = nvp + nr*nc + nbr*nml;
  for(i=0; i<ngp; i++)
    for(j=0; j<ngp; j++){
        cooX[curidx] = i + xoffset;
        cooY[curidx] = j + yoffset;
        if(i == j)
          cooV[curidx] = -iQ - iT;
        else
          cooV[curidx] = -iQ;
        curidx++;
    }
  /* Vdd grid voltage diagonal block */
  xoffset = nvp;
  yoffset = nvp;
  for(i=0; i<(nr*nc); i++){
      cooX[curidx] = i+xoffset; cooY[curidx] = i+yoffset;
      cooV[curidx] = 0;
      curidx++;
  }
  /* Gnd grid voltage diagonal block */
  xoffset = nvp + nr*nc + nbr*nml + ngp;
  yoffset = nvp + nr*nc + nbr*nml + ngp;
  for(i=0; i<(nr*nc); i++){
      cooX[curidx] = i+xoffset; cooY[curidx] = i+yoffset;
      cooV[curidx] = 0;
      curidx++;
  }
  /* Vdd grid current diagonal block */
  for(l=0; l<nml; l++){
      xoffset = nvp + nr*nc + nbr*l;
      yoffset = nvp + nr*nc + nbr*l;
      for(i=0; i<nbr; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = i+yoffset;
          if((!mtdmn) || does_branch_exist(model, i)){
              if(i < ((nc-1)*nr))
                cooV[curidx] = -g[2*l].r/g[2*l].l;
              else{
                  cooV[curidx] = -g[2*l+1].r/g[2*l+1].l;
              }
          }
          else{
              cooV[curidx] = 0;
          }
          curidx++;
      }
  }
  /* Gnd grid current diagonal block */
  for(l=0; l<nml; l++){
      xoffset = nvp + nr*nc + nbr*nml + ngp + nr*nc + nbr*l;
      yoffset = nvp + nr*nc + nbr*nml + ngp + nr*nc + nbr*l;
      for(i=0; i<nbr; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = i+yoffset;
          if(i < ((nc-1)*nr))
            cooV[curidx] = -g[2*l].r/g[2*l].l;
          else{
              cooV[curidx] = -g[2*l+1].r/g[2*l+1].l;
          }
          curidx++;
      }
  }
  /* Vdd grid - current block */
  for(l=0; l<nml; l++){
      xoffset = nvp;
      yoffset = nvp + nr*nc + nbr*l;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            Cg = get_onchip_cap(model, grididx, 0);
            if(0 == grididx){//top left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if((nc-1) == grididx ){//top right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if((nr*nc-nc) == grididx){//bottom left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if((nr*nc-1) == grididx){//bottom right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if((grididx > 0) && (grididx < nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+((nc-1)*nr)+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if(0 == (grididx%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else if(0 == ((grididx+1)%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
            }
            else{
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -nc)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, nc)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, -1)){
                    cooV[curidx] = 1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                if((!mtdmn) || compare_domain(model, grididx, 1)){
                    cooV[curidx] = -1/Cg; curidx++;}
                else{cooV[curidx] = 0; curidx++;}
            }
        }
  }
  /* Gnd grid - current block */
  for(l=0; l<nml; l++){
      xoffset = nvp + nr*nc + nbr*nml + ngp;
      yoffset = nvp + nr*nc + nbr*nml + ngp + nr*nc + nbr*l;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            Cg = get_onchip_cap(model, grididx, 0);
            if(0 == grididx){//top left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
            }
            else if((nc-1) == grididx ){//top right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
            }
            else if((nr*nc-nc) == grididx){//bottom left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
            }
            else if((nr*nc-1) == grididx){//bottom right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
            }
            else if((grididx > 0) && (grididx < nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+((nc-1)*nr)+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
            }
            else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
            }
            else if(0 == (grididx%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
            }
            else if(0 == ((grididx+1)%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
            }
            else{
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                cooV[curidx] = 1/Cg; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                cooV[curidx] = -1/Cg; curidx++;
            }
        }
  }
  /* Vdd current - voltage block */
  for(l=0; l<nml; l++){
      xoffset = nvp + nr*nc + nbr*l;
      yoffset = nvp;
      for(i=0; i<nbr; i++){
          if(i<((nc-1)*nr)){
              tmp_j = i % (nc-1);
              tmp_i = (int) floor(i/(nc-1));
              grididx = tmp_i*nc + tmp_j;
              cooX[curidx] = i+xoffset; cooY[curidx] = grididx+yoffset;
              if((!mtdmn) || does_branch_exist(model, i)){
                  cooV[curidx] = 1/g[2*l].l; curidx++;}
              else{cooV[curidx] = 0; curidx++;}
              cooX[curidx] = i+xoffset; cooY[curidx] = grididx+1+yoffset;
              if((!mtdmn) || does_branch_exist(model, i)){
                  cooV[curidx] = -1/g[2*l].l; curidx++;}
              else{cooV[curidx] = 0; curidx++;}
          }
          else{
              cooX[curidx] = i+xoffset; cooY[curidx] = i-nr*(nc-1)+yoffset;
              if((!mtdmn) || does_branch_exist(model, i)){
                  cooV[curidx] = 1/g[2*l+1].l; curidx++;}
              else{cooV[curidx] = 0; curidx++;}
              cooX[curidx] = i+xoffset; cooY[curidx] = i-nr*(nc-1)+nc+yoffset;
              if((!mtdmn) || does_branch_exist(model, i)){
                  cooV[curidx] = -1/g[2*l+1].l; curidx++;}
              else{cooV[curidx] = 0; curidx++;}
          }
      }
  }
  /* Gnd current - voltage block */
  for(l=0; l<nml; l++){
      xoffset = nvp + nr*nc + nbr*nml + ngp + nr*nc + nbr*l;
      yoffset = nvp + nr*nc + nbr*nml + ngp;
      for(i=0; i<nbr; i++){
          if(i<((nc-1)*nr)){
              tmp_j = i % (nc-1);
              tmp_i = (int) floor(i/(nc-1));
              grididx = tmp_i*nc + tmp_j;
              cooX[curidx] = i+xoffset; cooY[curidx] = grididx+yoffset;
              cooV[curidx] = 1/g[2*l].l; curidx++;
              cooX[curidx] = i+xoffset; cooY[curidx] = grididx+1+yoffset;
              cooV[curidx] = -1/g[2*l].l; curidx++;
          }
          else{
              cooX[curidx] = i+xoffset; cooY[curidx] = i-nr*(nc-1)+yoffset;
              cooV[curidx] = 1/g[2*l+1].l; curidx++;
              cooX[curidx] = i+xoffset; cooY[curidx] = i-nr*(nc-1)+nc+yoffset;
              cooV[curidx] = -1/g[2*l+1].l; curidx++;
          }
      }
  }
  /* VDD pad two sparse block */
  xoffset = 0;
  yoffset = 0;
  for(i=0; i<nvp; i++){
      grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
      if(-1 == grididx)
        fatal("Cannot find grid index for VDD pad\n");
      Cg = get_onchip_cap(model, grididx, 0);
      cooX[curidx] = grididx+nvp+xoffset; cooY[curidx] = i+yoffset;
      cooV[curidx] = 1/Cg; curidx++;
      cooX[curidx] = i+xoffset; cooY[curidx] = grididx+nvp+yoffset;
      cooV[curidx] = -1/Lp; curidx++;
  }
  /* GND pad two sparse block */
  xoffset = nvp + nr*nc + nbr*nml;
  yoffset = nvp + nr*nc + nbr*nml;
  for(i=0; i<ngp; i++){
      grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
      if(-1 == grididx)
        fatal("Cannot find grid index for GND pad\n");
      Cg = get_onchip_cap(model, grididx, 0);
      cooX[curidx] = grididx+ngp+xoffset; cooY[curidx] = i+yoffset;
      cooV[curidx] = -1/Cg; curidx++;
      cooX[curidx] = i+xoffset; cooY[curidx] = grididx+ngp+yoffset;
      cooV[curidx] = 1/Lp; curidx++;
  }
  if(model->config.PDN_pkgLC){
      /* Bottom row, VDD part */
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      yoffset = 0;
      for(i=0; i<nvp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = -iM*iA*iS; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = xoffset; cooY[curidx] = grididx+nvp+yoffset;
          cooV[curidx] = iM*iA*iP; curidx++;
      }
      /* Bottom row, GND part */
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      yoffset = nvp + nr*nc + nbr*nml;
      for(i=0; i<ngp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = -iM*iB*iS; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = xoffset; cooY[curidx] = grididx+ngp+yoffset;
          cooV[curidx] = -iM*iB*iP; curidx++;
      }
      /* Right col, VDD part */
      xoffset = 0;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      for(i=0; i<nvp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iQ; curidx++;
      }
      /* Right col, GND part */
      xoffset = nvp + nr*nc + nbr*nml;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      for(i=0; i<ngp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iQ; curidx++;
      }
      /* Individual points */
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = -iN; curidx++;
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = -iM; curidx++;
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 1/Cpp; curidx++;
  }
  if(curidx < nnz)
    fatal("COO Matrix has less elements than nnz!\n");
  else if(curidx > nnz)
    fatal("COO Matrix has more elements than nnz!\n");
  coo2csc(n, nnz, cooX, cooY, cooV, asub, xa, a);
  /* Create matrix A in the format expected by SuperLU. */
  dCreate_CompCol_Matrix(A, m, n, nnz, a, asub, xa, SLU_NC, SLU_D, SLU_GE);
  if(model->config.PDN_pkgLC){
      // Create B
      if ( !(b = doubleMalloc(nnz)) ) fatal("Malloc fails for b[].\n");
      if ( !(bsub = intMalloc(nnz)) ) fatal("Malloc fails for bsub[].\n");
      if ( !(xb = intMalloc(n+1)) ) fatal("Malloc fails for xb[].\n");
      curidx = 0;
      /* Vdd pad dense block */
      xoffset = 0;
      yoffset = 0;
      for(i=0; i<nvp; i++)
        for(j=0; j<nvp; j++){
            cooX[curidx] = i + xoffset;
            cooY[curidx] = j + yoffset;
            cooV[curidx] = -iP;
            curidx++;
        }
      /* Gnd pad dense block */
      xoffset = nvp + nr*nc + nbr*nml;
      yoffset = nvp + nr*nc + nbr*nml;
      for(i=0; i<ngp; i++)
        for(j=0; j<ngp; j++){
            cooX[curidx] = i + xoffset;
            cooY[curidx] = j + yoffset;
            cooV[curidx] = -iP;
            curidx++;
        }
      /* Vdd grid voltage diagonal block */
      xoffset = nvp;
      yoffset = nvp;
      for(i=0; i<(nr*nc); i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0;
          curidx++;
      }
      /* Gnd grid voltage diagonal block */
      xoffset = nvp + nr*nc + nbr*nml + ngp;
      yoffset = nvp + nr*nc + nbr*nml + ngp;
      for(i=0; i<(nr*nc); i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0;
          curidx++;
      }
      /* Vdd grid current diagonal block */
      for(l=0; l<nml; l++){
          xoffset = nvp + nr*nc + nbr*l;
          yoffset = nvp + nr*nc + nbr*l;
          for(i=0; i<nbr; i++){
              cooX[curidx] = i+xoffset; cooY[curidx] = i+yoffset;
              cooV[curidx] = 0;
              curidx++;
          }
      }
      /* Gnd grid current diagonal block */
      for(l=0; l<nml; l++){
          xoffset = nvp + nr*nc + nbr*nml + ngp + nr*nc + nbr*l;
          yoffset = nvp + nr*nc + nbr*nml + ngp + nr*nc + nbr*l;
          for(i=0; i<nbr; i++){
              cooX[curidx] = i+xoffset; cooY[curidx] = i+yoffset;
              cooV[curidx] = 0;
              curidx++;
          }
      }
      /* Vdd grid - current block */
      for(l=0; l<nml; l++){
          xoffset = nvp;
          yoffset = nvp + nr*nc + nbr*l;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(0 == grididx){//top left corner
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if((nc-1) == grididx ){//top right corner
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if((nr*nc-nc) == grididx){//bottom left corner
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if((nr*nc-1) == grididx){//bottom right corner
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if((grididx > 0) && (grididx < nc-1)){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+((nc-1)*nr)+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if(0 == (grididx%nc)){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if(0 == ((grididx+1)%nc)){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else{
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
            }
      }
      /* Gnd grid - current block */
      for(l=0; l<nml; l++){
          xoffset = nvp + nr*nc + nbr*nml + ngp;
          yoffset = nvp + nr*nc + nbr*nml + ngp + nr*nc + nbr*l;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(0 == grididx){//top left corner
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if((nc-1) == grididx ){//top right corner
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if((nr*nc-nc) == grididx){//bottom left corner
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if((nr*nc-1) == grididx){//bottom right corner
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if((grididx > 0) && (grididx < nc-1)){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+((nc-1)*nr)+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if(0 == (grididx%nc)){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else if(0 == ((grididx+1)%nc)){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
                else{
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+(i-1)*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = (nc-1)*nr+i*nc+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j-1+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = i*(nc-1)+j+yoffset;
                    cooV[curidx] = 0; curidx++;
                }
            }
      }
      /* Vdd current - voltage block */
      for(l=0; l<nml; l++){
          xoffset = nvp + nr*nc + nbr*l;
          yoffset = nvp;
          for(i=0; i<nbr; i++){
              if(i<((nc-1)*nr)){
                  tmp_j = i % (nc-1);
                  tmp_i = (int) floor(i/(nc-1));
                  grididx = tmp_i*nc + tmp_j;
                  cooX[curidx] = i+xoffset; cooY[curidx] = grididx+yoffset;
                  cooV[curidx] = 0; curidx++;
                  cooX[curidx] = i+xoffset; cooY[curidx] = grididx+1+yoffset;
                  cooV[curidx] = 0; curidx++;
              }
              else{
                  cooX[curidx] = i+xoffset; cooY[curidx] = i-nr*(nc-1)+yoffset;
                  cooV[curidx] = 0; curidx++;
                  cooX[curidx] = i+xoffset; cooY[curidx] = i-nr*(nc-1)+nc+yoffset;
                  cooV[curidx] = 0; curidx++;
              }
          }
      }
      /* Gnd current - voltage block */
      for(l=0; l<nml; l++){
          xoffset = nvp + nr*nc + nbr*nml + ngp + nr*nc + nbr*l;
          yoffset = nvp + nr*nc + nbr*nml + ngp;
          for(i=0; i<nbr; i++){
              if(i<((nc-1)*nr)){
                  tmp_j = i % (nc-1);
                  tmp_i = (int) floor(i/(nc-1));
                  grididx = tmp_i*nc + tmp_j;
                  cooX[curidx] = i+xoffset; cooY[curidx] = grididx+yoffset;
                  cooV[curidx] = 0; curidx++;
                  cooX[curidx] = i+xoffset; cooY[curidx] = grididx+1+yoffset;
                  cooV[curidx] = 0; curidx++;
              }
              else{
                  cooX[curidx] = i+xoffset; cooY[curidx] = i-nr*(nc-1)+yoffset;
                  cooV[curidx] = 0; curidx++;
                  cooX[curidx] = i+xoffset; cooY[curidx] = i-nr*(nc-1)+nc+yoffset;
                  cooV[curidx] = 0; curidx++;
              }
          }
      }
      /* VDD pad two sparse block */
      xoffset = 0;
      yoffset = 0;
      for(i=0; i<nvp; i++){
          grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = grididx+nvp+xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          cooX[curidx] = i+xoffset; cooY[curidx] = grididx+nvp+yoffset;
          cooV[curidx] = 0; curidx++;
      }
      /* GND pad two sparse block */
      xoffset = nvp + nr*nc + nbr*nml;
      yoffset = nvp + nr*nc + nbr*nml;
      for(i=0; i<ngp; i++){
          grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
          if(-1 == grididx)
            fatal("Cannot find grid index for GND pad\n");
          cooX[curidx] = grididx+ngp+xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          cooX[curidx] = i+xoffset; cooY[curidx] = grididx+ngp+yoffset;
          cooV[curidx] = 0; curidx++;
      }
      /* Bottom row, VDD part */
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      yoffset = 0;
      for(i=0; i<nvp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = xoffset; cooY[curidx] = grididx+nvp+yoffset;
          cooV[curidx] = 0; curidx++;
      }
      /* Bottom row, GND part */
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      yoffset = nvp + nr*nc + nbr*nml;
      for(i=0; i<ngp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = xoffset; cooY[curidx] = grididx+ngp+yoffset;
          cooV[curidx] = 0; curidx++;
      }
      /* Right col, VDD part */
      xoffset = 0;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      for(i=0; i<nvp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iP; curidx++;
      }
      /* Right col, GND part */
      xoffset = nvp + nr*nc + nbr*nml;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      for(i=0; i<ngp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iP; curidx++;
      }
      /* Individual points */
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml;
      yoffset = nvp + 2*nr*nc + ngp + 2*nbr*nml + 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      if(curidx < nnz)
        fatal("COO Matrix has less elements than nnz!\n");
      else if(curidx > nnz)
        fatal("COO Matrix has more elements than nnz!\n");
      coo2csc(n, nnz, cooX, cooY, cooV, bsub, xb, b);
      dCreate_CompCol_Matrix(&B, m, n, nnz, b, bsub, xb, SLU_NC, SLU_D, SLU_GE);
  }
  // E - B - delta_t*A/2 for pkgLC
  // E - delta_t*A/2 for no pkgLC
  SparseMatrix_mul_SingleNum(A, -delta_t/2);
  if(model->config.PDN_pkgLC)
    SparseMatrix_add(A, &B, -1);
  SparseMatrix_add_Iden(A, 1);
  if ( !(rhs = doubleMalloc(m)) ) fatal("Malloc fails for rhs[].\n");
  for(i=0; i<m; ++i) rhs[i] = 1;
  dCreate_Dense_Matrix(&Z, m, 1, rhs, m, SLU_DN, SLU_D, SLU_GE);
  /* Set the default input options. */
  set_default_options(&options);
  options.ColPerm = MMD_AT_PLUS_A;
  options.DiagPivotThresh = 0.01;
  options.SymmetricMode = NO;
  options.Equil = YES;
  /* Initialize the statistics variables. */
  StatInit(&stat);
  /* Solve the linear system. */
  dgssv(&options, A, perm_c, perm_r, L, U, &Z, &stat, &info);
  // Create RHS
  // E - B + (delta_t/2)*J for pkgLC
  // E + (delta_t/2)*J for no pkgLC
  SparseMatrix_mul_SingleNum(A, -1);
  if(model->config.PDN_pkgLC)
    SparseMatrix_add(A, &B, -2);
  SparseMatrix_add_Iden(A, 2);
  /* De-allocate storage */
  SUPERLU_FREE (rhs);
  Destroy_SuperMatrix_Store(&Z);
  if(model->config.PDN_pkgLC)
    Destroy_CompCol_Matrix(&B);
  StatFree(&stat);
  free_model_vector(p);
  free(cooV);
  free(cooX);
  free(cooY);
}
void trans_SLU_init_nogridL(model_t *model, double *power, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U, int *perm_c, int *perm_r)
{
  SuperMatrix B, Z;
  double   *a, *b, *rhs;
  int      *asub, *xa, *bsub, *xb;
  double   *cooV;
  int      *cooX, *cooY;
  double   dia_val;
  int      info, i, j, m, n, nnz;
  int      direc;
  int      xoffset, yoffset;
  int      grididx, curidx;
  superlu_options_t options;
  SuperLUStat_t stat;
  model_vector_t *p;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  int mtdmn  = model->config.PDN_multi_dom;
  double Rp  = model->c4->pad_r;
  double Lp  = model->c4->pad_l;
  double Rx  = 0; double Ry  = 0;
  double Rsp = model->config.PDN_pkg_sR;
  double Lsp = model->config.PDN_pkg_sL;
  double Rpp = model->config.PDN_pkg_pR;
  double Lpp = model->config.PDN_pkg_pL;
  double Cpp = model->config.PDN_pkg_C;
  double delta_t = 1/(model->config.proc_clock_freq*model->config.PDN_step_percycle);
  double Cg;
  //calculate grid R
  for(i=0; i<model->layers[0].metal_layers.n_metal; i++){
      direc = model->layers[0].metal_layers.geo[i].direc;
      if(MLCF_X == direc)
        Rx += 1/model->layers[0].metal_layers.gridRL[i].r;
      else
        Ry += 1/model->layers[0].metal_layers.gridRL[i].r;
  }
  Rx = 1/Rx;
  Ry = 1/Ry;
  /* Intermediate values */
  double iA = 1 / (nvp*Lsp/Lp + 1);
  double iB = 1 / (ngp*Lsp/Lp + 1);
  double iM = 1 / ((iA+iB)*Lsp + Lpp);
  double iN = iM * ((iA+iB)*Rsp + Rpp);
  double iP = Lsp / Lp;
  double iQ = Rsp / Lp;
  double iS = Rsp - iP*Rp;
  double iT = Rp / Lp;
  p = new_model_vector(model);
  /* map the block power/temp numbers to the grid	*/
  PDN_xlate_vector_b2g(model, power, p);
  copy_dvector(model->last_power, p->cuboid[0][0], nr*nc*nl);
  /* Initialize matrix A. */
  m = n = model->trans_matrix_dim;
  /* Num of non-zeros
   * Five diagonal of both vdd and gnd plane: c*r, c*(r-1), (c-1)*r, c*(r-1), (c-1)*r
   * two dense block for pads:                nvp * nvp, ngp * ngp
   * pad<->grid side blocks:                  2 * nvp, 2 * ngp
   * row for Vc (extra 0 in diaganal):        1 + 1
   * row for Ic:                              2*nvp + 2*ngp + 2
   * col for Ic:                              nvp + ngp
   */
  nnz = 2*(5*nr*nc - 2*(nr+nc)); 
  nnz += nvp*nvp + ngp*ngp;
  nnz += 2*(nvp+ngp);
  if(model->config.PDN_pkgLC){
      nnz += 2*nvp + 2*ngp + 2;
      nnz += nvp + ngp + 2;
  }
  if ( !(cooV = doubleMalloc(nnz)) ) fatal("Malloc fails for cooV[].\n");
  if ( !(cooX = intMalloc(nnz)) ) fatal("Malloc fails for cooX[].\n");
  if ( !(cooY = intMalloc(nnz)) ) fatal("Malloc fails for cooY[].\n");
  // Create A
  if ( !(a = doubleMalloc(nnz)) ) fatal("Malloc fails for a[].\n");
  if ( !(asub = intMalloc(nnz)) ) fatal("Malloc fails for asub[].\n");
  if ( !(xa = intMalloc(n+1)) ) fatal("Malloc fails for xa[].\n");
  curidx = 0;
  /* Vdd pad dense block */
  xoffset = 0;
  yoffset = 0;
  for(i=0; i<nvp; i++)
    for(j=0; j<nvp; j++){
        cooX[curidx] = i + xoffset;
        cooY[curidx] = j + yoffset;
        if(i == j)
          cooV[curidx] = -iQ - iT;
        else
          cooV[curidx] = -iQ;
        curidx++;
    }
  /* Gnd pad dense block */
  xoffset = nvp + nr*nc;
  yoffset = nvp + nr*nc;
  for(i=0; i<ngp; i++)
    for(j=0; j<ngp; j++){
        cooX[curidx] = i + xoffset;
        cooY[curidx] = j + yoffset;
        if(i == j)
          cooV[curidx] = -iQ - iT;
        else
          cooV[curidx] = -iQ;
        curidx++;
    }
  /* Vdd grid diagonal block */
  xoffset = nvp;
  yoffset = nvp;
  for(i=0; i<nr; i++)
    for(j=0; j<nc; j++){
        grididx = i*nc + j;
        Cg = get_onchip_cap(model, grididx, 0);
        dia_val = 0;
        if(0 == grididx){//top left corner
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, 1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if((nc-1) == grididx ){//top right corner
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if((nr*nc-nc) == grididx){//bottom left corner
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, 1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if((nr*nc-1) == grididx){//bottom right corner
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if((grididx > 0) && (grididx < nc-1)){
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, 1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, 1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if(0 == (grididx%nc)){
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, 1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if(0 == ((grididx+1)%nc)){
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else{
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, nc)){
                cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, -1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            if((!mtdmn) || compare_domain(model, grididx, 1)){
                cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;}
            else{cooV[curidx] = 0; curidx++;}
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
    }
  /* Gnd grid diagonal block */
  xoffset = nvp + nr*nc + ngp;
  yoffset = nvp + nr*nc + ngp;
  for(i=0; i<nr; i++)
    for(j=0; j<nc; j++){
        grididx = i*nc + j;
        Cg = get_onchip_cap(model, grididx, 0);
        dia_val = 0;
        if(0 == grididx){//top left corner
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if((nc-1) == grididx ){//top right corner
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if((nr*nc-nc) == grididx){//bottom left corner
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if((nr*nc-1) == grididx){//bottom right corner
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if((grididx > 0) && (grididx < nc-1)){
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if(0 == (grididx%nc)){
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else if(0 == ((grididx+1)%nc)){
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
        else{
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
            cooV[curidx] = 1/(Cg*Ry); curidx++; dia_val+=1/Ry;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
            cooV[curidx] = 1/(Cg*Rx); curidx++; dia_val+=1/Rx;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cg; curidx++;
        }
    }
  /* VDD pad two sparse block */
  xoffset = 0;
  yoffset = 0;
  for(i=0; i<nvp; i++){
      grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
      if(-1 == grididx)
        fatal("Cannot find grid index for VDD pad\n");
      Cg = get_onchip_cap(model, grididx, 0);
      cooX[curidx] = grididx+nvp+xoffset; cooY[curidx] = i+yoffset;
      cooV[curidx] = 1/Cg; curidx++;
      cooX[curidx] = i+xoffset; cooY[curidx] = grididx+nvp+yoffset;
      cooV[curidx] = -1/Lp; curidx++;
  }
  /* GND pad two sparse block */
  xoffset = nvp + nr*nc;
  yoffset = nvp + nr*nc;
  for(i=0; i<ngp; i++){
      grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
      if(-1 == grididx)
        fatal("Cannot find grid index for GND pad\n");
      Cg = get_onchip_cap(model, grididx, 0);
      cooX[curidx] = grididx+ngp+xoffset; cooY[curidx] = i+yoffset;
      cooV[curidx] = -1/Cg; curidx++;
      cooX[curidx] = i+xoffset; cooY[curidx] = grididx+ngp+yoffset;
      cooV[curidx] = 1/Lp; curidx++;
  }
  if(model->config.PDN_pkgLC){
      /* Bottom row, VDD part */
      xoffset = nvp + 2*nr*nc + ngp + 1;
      yoffset = 0;
      for(i=0; i<nvp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = -iM*iA*iS; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = xoffset; cooY[curidx] = grididx+nvp+yoffset;
          cooV[curidx] = iM*iA*iP; curidx++;
      }
      /* Bottom row, GND part */
      xoffset = nvp + 2*nr*nc + ngp + 1;
      yoffset = nvp + nr*nc;
      for(i=0; i<ngp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = -iM*iB*iS; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = xoffset; cooY[curidx] = grididx+ngp+yoffset;
          cooV[curidx] = -iM*iB*iP; curidx++;
      }
      /* Right col, VDD part */
      xoffset = 0;
      yoffset = nvp + 2*nr*nc + ngp + 1;
      for(i=0; i<nvp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iQ; curidx++;
      }
      /* Right col, GND part */
      xoffset = nvp + nr*nc;
      yoffset = nvp + 2*nr*nc + ngp + 1;
      for(i=0; i<ngp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iQ; curidx++;
      }
      /* Individual points */
      xoffset = nvp + 2*nr*nc + ngp + 1;
      yoffset = nvp + 2*nr*nc + ngp + 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = -iN; curidx++;
      xoffset = nvp + 2*nr*nc + ngp;
      yoffset = nvp + 2*nr*nc + ngp;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = nvp + 2*nr*nc + ngp + 1;
      yoffset = nvp + 2*nr*nc + ngp;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = -iM; curidx++;
      xoffset = nvp + 2*nr*nc + ngp;
      yoffset = nvp + 2*nr*nc + ngp + 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 1/Cpp; curidx++;
  }
  if(curidx != nnz)
    fatal("COO Matrix has less elements than nnz!\n");
  coo2csc(n, nnz, cooX, cooY, cooV, asub, xa, a);
  /* Create matrix A in the format expected by SuperLU. */
  dCreate_CompCol_Matrix(A, m, n, nnz, a, asub, xa, SLU_NC, SLU_D, SLU_GE);
  if(model->config.PDN_pkgLC){
      // Create B
      if ( !(b = doubleMalloc(nnz)) ) fatal("Malloc fails for b[].\n");
      if ( !(bsub = intMalloc(nnz)) ) fatal("Malloc fails for bsub[].\n");
      if ( !(xb = intMalloc(n+1)) ) fatal("Malloc fails for xb[].\n");
      curidx = 0;
      /* Vdd pad dense block */
      xoffset = 0;
      yoffset = 0;
      for(i=0; i<nvp; i++)
        for(j=0; j<nvp; j++){
            cooX[curidx] = i + xoffset;
            cooY[curidx] = j + yoffset;
            cooV[curidx] = -iP;
            curidx++;
        }
      /* Gnd pad dense block */
      xoffset = nvp + nr*nc;
      yoffset = nvp + nr*nc;
      for(i=0; i<ngp; i++)
        for(j=0; j<ngp; j++){
            cooX[curidx] = i + xoffset;
            cooY[curidx] = j + yoffset;
            cooV[curidx] = -iP;
            curidx++;
        }
      /* Vdd grid diagonal block */
      xoffset = nvp;
      yoffset = nvp;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            if(0 == grididx){//top left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nc-1) == grididx ){//top right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nr*nc-nc) == grididx){//bottom left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nr*nc-1) == grididx){//bottom right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((grididx > 0) && (grididx < nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if(0 == (grididx%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if(0 == ((grididx+1)%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else{
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
        }
      /* Gnd grid diagonal block */
      xoffset = nvp + nr*nc + ngp;
      yoffset = nvp + nr*nc + ngp;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            if(0 == grididx){//top left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nc-1) == grididx ){//top right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nr*nc-nc) == grididx){//bottom left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nr*nc-1) == grididx){//bottom right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((grididx > 0) && (grididx < nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if(0 == (grididx%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if(0 == ((grididx+1)%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else{
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
        }
      /* VDD pad two sparse block */
      xoffset = 0;
      yoffset = 0;
      for(i=0; i<nvp; i++){
          grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = grididx+nvp+xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          cooX[curidx] = i+xoffset; cooY[curidx] = grididx+nvp+yoffset;
          cooV[curidx] = 0; curidx++;
      }
      /* GND pad two sparse block */
      xoffset = nvp + nr*nc;
      yoffset = nvp + nr*nc;
      for(i=0; i<ngp; i++){
          grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
          if(-1 == grididx)
            fatal("Cannot find grid index for GND pad\n");
          cooX[curidx] = grididx+ngp+xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          cooX[curidx] = i+xoffset; cooY[curidx] = grididx+ngp+yoffset;
          cooV[curidx] = 0; curidx++;
      }
      /* Bottom row, VDD part */
      xoffset = nvp + 2*nr*nc + ngp + 1;
      yoffset = 0;
      for(i=0; i<nvp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = xoffset; cooY[curidx] = grididx+nvp+yoffset;
          cooV[curidx] = 0; curidx++;
      }
      /* Bottom row, GND part */
      xoffset = nvp + 2*nr*nc + ngp + 1;
      yoffset = nvp + nr*nc;
      for(i=0; i<ngp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = xoffset; cooY[curidx] = grididx+ngp+yoffset;
          cooV[curidx] = 0; curidx++;
      }
      /* Right col, VDD part */
      xoffset = 0;
      yoffset = nvp + 2*nr*nc + ngp + 1;
      for(i=0; i<nvp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iP; curidx++;
      }
      /* Right col, GND part */
      xoffset = nvp + nr*nc;
      yoffset = nvp + 2*nr*nc + ngp + 1;
      for(i=0; i<ngp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iP; curidx++;
      }
      /* Individual points */
      xoffset = nvp + 2*nr*nc + ngp + 1;
      yoffset = nvp + 2*nr*nc + ngp + 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = nvp + 2*nr*nc + ngp;
      yoffset = nvp + 2*nr*nc + ngp;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = nvp + 2*nr*nc + ngp + 1;
      yoffset = nvp + 2*nr*nc + ngp;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = nvp + 2*nr*nc + ngp;
      yoffset = nvp + 2*nr*nc + ngp + 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      if(curidx != nnz)
        fatal("COO Matrix has less elements than nnz!\n");
      coo2csc(n, nnz, cooX, cooY, cooV, bsub, xb, b);
      dCreate_CompCol_Matrix(&B, m, n, nnz, b, bsub, xb, SLU_NC, SLU_D, SLU_GE);
  }
  // E - B - delta_t*A/2 for pkgLC
  // E - delta_t*A/2 for no pkgLC
  SparseMatrix_mul_SingleNum(A, -delta_t/2);
  if(model->config.PDN_pkgLC)
    SparseMatrix_add(A, &B, -1);
  SparseMatrix_add_Iden(A, 1);
  if ( !(rhs = doubleMalloc(m)) ) fatal("Malloc fails for rhs[].\n");
  for(i=0; i<m; ++i) rhs[i] = 1;
  dCreate_Dense_Matrix(&Z, m, 1, rhs, m, SLU_DN, SLU_D, SLU_GE);
  /* Set the default input options. */
  set_default_options(&options);
  options.ColPerm = MMD_AT_PLUS_A;
  options.DiagPivotThresh = 0.01;
  options.SymmetricMode = NO;
  options.Equil = YES;
  /* Initialize the statistics variables. */
  StatInit(&stat);
  /* Solve the linear system. */
  dgssv(&options, A, perm_c, perm_r, L, U, &Z, &stat, &info);
  // Create RHS
  // E + (delta_t/2)*J
  SparseMatrix_mul_SingleNum(A, -1);
  if(model->config.PDN_pkgLC)
    SparseMatrix_add(A, &B, -2);
  SparseMatrix_add_Iden(A, 2);
  /* De-allocate storage */
  SUPERLU_FREE (rhs);
  Destroy_SuperMatrix_Store(&Z);
  if(model->config.PDN_pkgLC)
    Destroy_CompCol_Matrix(&B);
  StatFree(&stat);
  free_model_vector(p);
  free(cooV);
  free(cooX);
  free(cooY);
}
void trans_matrix_build_3D(model_t *model, double *power, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U, int **perm_c, int **perm_r)
{
  SuperMatrix B, Z;
  double   *a, *b, *rhs;
  int      *asub, *xa, *bsub, *xb;
  double   *cooV;
  int      *cooX, *cooY;
  int      i, j, l, k, m, n, nnz;
  int      tmp_i, tmp_j;
  int      info, direc;
  int      xoffset, yoffset;
  int      grididx, curidx;
  int      ntsv, nIVR;
  int      **ivr_loc;
  double   dia_val;
  superlu_options_t options;
  SuperLUStat_t stat;
  model_vector_t *p;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  int nvtsv = model->layers[0].tsv.num_vdd;
  int ngtsv = model->layers[0].tsv.num_gnd;
  int tsv_count, ivr_idx;
  int vs = model->config.v_stacking;
  double Rpv  = model->c4->pad_r;
  double Lpv  = model->c4->pad_l;
  double Rpg  = model->c4->pad_r;
  double Lpg  = model->c4->pad_l;
  double Rsp = model->config.PDN_pkg_sR;
  double Lsp = model->config.PDN_pkg_sL;
  double Rpp = model->config.PDN_pkg_pR;
  double Lpp = model->config.PDN_pkg_pL;
  double Cpp = model->config.PDN_pkg_C;
  double delta_t = 1/(model->config.proc_clock_freq*model->config.PDN_step_percycle);
  double vdd = model->config.vdd;
  double Rx, Ry, Rload;
  double Cg, Cm;
  double Rtsv, Ltsv;
  double Ront, Ronb, Civr;
  /* Add TSV RL into pad RL */
  // This can be ignored if we can use larger TSVs to connect top-layer pads
  //if(vs){
  //    double Rtsv_sum = 0;
  //    double Ltsv_sum = 0;
  //    for(l=0; l<nl-1; l++){
  //        Rtsv_sum += model->layers[l].tsv.r;
  //        Ltsv_sum += model->layers[l].tsv.l;
  //    }
  //    Rpv += Rtsv_sum;
  //    Lpv += Ltsv_sum;
  //}
  /* Intermediate values */
  double iA = 1 / (nvp*Lsp/Lpv + 1);
  double iB = 1 / (ngp*Lsp/Lpg + 1);
  double iM = 1 / ((iA+iB)*Lsp + Lpp);
  double iN = iM * ((iA+iB)*Rsp + Rpp);
  double iPv = Lsp / Lpv;
  double iQv = Rsp / Lpv;
  double iSv = Rsp - iPv*Rpv;
  double iTv = Rpv / Lpv;
  double iPg = Lsp / Lpg;
  double iQg = Rsp / Lpg;
  double iSg = Rsp - iPg*Rpg;
  double iTg = Rpg / Lpg;
  /* map the block power numbers to the grid	*/
  p = new_model_vector(model);
  PDN_xlate_vector_b2g(model, power, p);
  if(vs){
      ntsv = ngtsv*(nl-1);
      nIVR = model->sc_converter->num_IVR;
      Ront = model->sc_converter->Ron_top;
      Ronb = model->sc_converter->Ron_bottom;
      Civr = model->sc_converter->c;
      ivr_loc = model->sc_converter->loc;
  }
  else{
      ntsv = (nvtsv+ngtsv)*(nl-1);
      nIVR = 0;
  }
  /* matrix dim */
  m = n = model->trans_matrix_dim;
  if( !(*perm_r = (int *) calloc(m, sizeof(int))) ) fatal("Malloc fails for perm_r[].\n");
  if( !(*perm_c = (int *) calloc(m, sizeof(int))) ) fatal("Malloc fails for perm_c[].\n");
  /* Num of non-zeros
   * Five diagonal of both vdd and gnd plane: c*r, c*(r-1), (c-1)*r, c*(r-1), (c-1)*r
   * single diagonal for Vdd-Gnd decap:       2*nr*nc
   * pad<->grid side blocks:                  2*nvp, 2*ngp
   * two dense block for pads:                nvp*nvp, ngp*ngp
   * two side blocks for IVR:                 2*8*(nl-1)*nIVR
   * diaganal for IVR:                        4*(nl-1)*nIVR
   * row for Vc (extra 0 in diaganal):        1+1
   * row for Ic:                              2*nvp + 2*ngp + 2
   * col for Ic:                              nvp + ngp
   */
  nnz = 2*(5*nr*nc - 2*(nr+nc)); 
  nnz += 2*nr*nc;
  nnz *= nl;
  nnz += 2*(nvp+ngp);
  nnz += nvp*nvp + ngp*ngp;
  nnz += 5*ntsv;
  nnz += (2*8*(nl-1)*nIVR + 4*(nl-1)*nIVR);
  if(model->config.PDN_pkgLC){
      nnz += 2*nvp + 2*ngp + 2;
      nnz += nvp + ngp + 2;
  }
  if ( !(cooV = doubleMalloc(nnz)) ) fatal("Malloc fails for cooV[].\n");
  if ( !(cooX = intMalloc(nnz)) ) fatal("Malloc fails for cooX[].\n");
  if ( !(cooY = intMalloc(nnz)) ) fatal("Malloc fails for cooY[].\n");
  // Create A
  if ( !(a = doubleMalloc(nnz)) ) fatal("Malloc fails for a[].\n");
  if ( !(asub = intMalloc(nnz)) ) fatal("Malloc fails for asub[].\n");
  if ( !(xa = intMalloc(n+1)) ) fatal("Malloc fails for xa[].\n");
  curidx = 0;
  /* Vdd pad dense block */
  xoffset = 0;
  yoffset = 0;
  for(i=0; i<nvp; i++)
    for(j=0; j<nvp; j++){
        cooX[curidx] = i + xoffset;
        cooY[curidx] = j + yoffset;
        if(i == j)
          cooV[curidx] = -iQv - iTv;
        else
          cooV[curidx] = -iQv;
        curidx++;
    }
  /* Gnd pad dense block */
  xoffset = nvp;
  yoffset = nvp;
  for(i=0; i<ngp; i++)
    for(j=0; j<ngp; j++){
        cooX[curidx] = i + xoffset;
        cooY[curidx] = j + yoffset;
        if(i == j)
          cooV[curidx] = -iQg - iTg;
        else
          cooV[curidx] = -iQg;
        curidx++;
    }
  /* VDD pad two sparse block */
  xoffset = 0;
  yoffset = 0;
  for(i=0; i<nvp; i++){
      grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
      if(-1 == grididx)
        fatal("Cannot find grid index for VDD pad\n");
      if(vs){
          tmp_i = floor(grididx/nc);
          tmp_j = grididx % nc;
          Cg = get_onchip_cap(model, grididx, nl-1);
          if((IVRLOC == ivr_loc[tmp_i][tmp_j]) && (nl > 1))
            Cm = Cg + 2*Civr;
          else
            Cm = Cg;
          cooX[curidx] = grididx+nvp+ngp+(nl-1)*2*nr*nc+xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 1/Cm; curidx++;
          cooX[curidx] = i+xoffset; cooY[curidx] = grididx+nvp+ngp+(nl-1)*2*nr*nc+yoffset;
          cooV[curidx] = -1/Lpv; curidx++;
      }
      else{
          Cg = get_onchip_cap(model, grididx, 0);
          cooX[curidx] = grididx+nvp+ngp+xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 1/Cg; curidx++;
          cooX[curidx] = i+xoffset; cooY[curidx] = grididx+nvp+ngp+yoffset;
          cooV[curidx] = -1/Lpv; curidx++;
      }
  }
  /* GND pad two sparse block */
  xoffset = nvp;
  yoffset = nvp;
  for(i=0; i<ngp; i++){
      grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
      if(-1 == grididx)
        fatal("Cannot find grid index for GND pad\n");
      tmp_i = floor(grididx/nc);
      tmp_j = grididx % nc;
      Cg = get_onchip_cap(model, grididx, 0);
      if(vs && (IVRLOC == ivr_loc[tmp_i][tmp_j]))
        Cm = Cg + 2*Civr;
      else
        Cm = Cg;
      cooX[curidx] = grididx+ngp+nr*nc+xoffset; cooY[curidx] = i+yoffset;
      cooV[curidx] = -1/Cm; curidx++;
      cooX[curidx] = i+xoffset; cooY[curidx] = grididx+ngp+nr*nc+yoffset;
      cooV[curidx] = 1/Lpg; curidx++;
  }
  /* Onchip nodes */
  for(l=0; l<nl; l++){
      //calculate grid R
      Rx = 0; Ry = 0;
      for(i=0; i<model->layers[l].metal_layers.n_metal; i++){
          direc = model->layers[l].metal_layers.geo[i].direc;
          if(MLCF_X == direc)
            Rx += 1/model->layers[l].metal_layers.gridRL[i].r;
          else
            Ry += 1/model->layers[l].metal_layers.gridRL[i].r;
      }
      Rx = 1/Rx;
      Ry = 1/Ry;
      /* Vdd grid diagonal block */
      xoffset = nvp + ngp + l*2*nr*nc;
      yoffset = nvp + ngp + l*2*nr*nc;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            Cg = get_onchip_cap(model, grididx, l);
            if(vs && (IVRLOC == ivr_loc[i][j]) && (l>0))
              Cm = Cg + 2*Civr;
            else
              Cm = Cg;
            if (p->cuboid[l][i][j] > 0)
              Rload = vdd*vdd/p->cuboid[l][i][j];
            else
              Rload = LARGEINT;
            dia_val = 0;
            if(0 == grididx){//top left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if((nc-1) == grididx ){//top right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if((nr*nc-nc) == grididx){//bottom left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if((nr*nc-1) == grididx){//bottom right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if((grididx > 0) && (grididx < nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if(0 == (grididx%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
            }
            else if(0 == ((grididx+1)%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
            }
            else{
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
            }
            /* Vdd-Gnd grid diagonal for load resisotrs */
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nr*nc+yoffset;
            cooV[curidx] = 1/(Cm*Rload); curidx++; dia_val += 1/Rload;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cm; curidx++;
        }
      /* Gnd grid diagonal block */
      xoffset = nvp + ngp + l*2*nr*nc + nr*nc;
      yoffset = nvp + ngp + l*2*nr*nc + nr*nc;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            Cg = get_onchip_cap(model, grididx, l);
            if(vs && (IVRLOC == ivr_loc[i][j]) && (l<nl-1))
              Cm = Cg + 2*Civr;
            else
              Cm = Cg;
            if (p->cuboid[l][i][j] > 0)
              Rload = vdd*vdd/p->cuboid[l][i][j];
            else
              Rload = LARGEINT;
            dia_val = 0;
            if(0 == grididx){//top left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if((nc-1) == grididx ){//top right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if((nr*nc-nc) == grididx){//bottom left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if((nr*nc-1) == grididx){//bottom right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if((grididx > 0) && (grididx < nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
            }
            else if(0 == (grididx%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
            }
            else if(0 == ((grididx+1)%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
            }
            else{
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 1/(Cm*Ry); curidx++; dia_val+=1/Ry;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 1/(Cm*Rx); curidx++; dia_val+=1/Rx;
            }
            /* Gnd-Vdd grid diagonal for load resisotrs */
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nr*nc+yoffset;
            cooV[curidx] = 1/(Cm*Rload); curidx++; dia_val += 1/Rload;
            if(vs && (IVRLOC == ivr_loc[i][j]) && (l>0))
              dia_val += 2/Ront + 2/Ronb;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = -dia_val/Cm; curidx++;
        }
  }
  if(vs){
      /* Onchip nodes -> TSVs block */
      tsv_count = 0;
      for(l=0; l<nl-1; l++){
          xoffset = nvp + ngp + l*2*nr*nc;
          yoffset = nvp + ngp + nl*2*nr*nc;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                    Cg = get_onchip_cap(model, grididx, l);
                    if((IVRLOC == ivr_loc[i][j]) && (l>0))
                      Cm = Cg + 2*Civr;
                    else
                      Cm = Cg;
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = 1/Cm; curidx++;
                    Cg = get_onchip_cap(model, grididx, l+1);
                    if((IVRLOC == ivr_loc[i][j]) && (l<nl-2))
                      Cm = Cg + 2*Civr;
                    else
                      Cm = Cg;
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = -1/Cm; curidx++;
                    tsv_count++;
                }
            }
      }
      /* TSVs -> Onchip nodes block */
      tsv_count = 0;
      for(l=0; l<nl-1; l++){
          Ltsv = model->layers[l].tsv.l;
          xoffset = nvp + ngp + nl*2*nr*nc;
          yoffset = nvp + ngp + l*2*nr*nc;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+yoffset;
                    cooV[curidx] = -1/Ltsv; curidx++;
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = 1/Ltsv; curidx++;
                    tsv_count++;
                }
            }
      }
      /* TSV diagonal block */
      xoffset = nvp + ngp + nl*2*nr*nc;
      yoffset = nvp + ngp + nl*2*nr*nc;
      tsv_count = 0;
      for(l=0; l<nl-1; l++){
          Rtsv = model->layers[l].tsv.r;
          Ltsv = model->layers[l].tsv.l;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = -Rtsv/Ltsv; curidx++;
                    tsv_count++;
                }
            }
      }
  }
  else{
      /* Onchip nodes -> TSVs block */
      tsv_count = 0;
      for(l=0; l<nl-1; l++){
          xoffset = nvp + ngp + l*2*nr*nc;
          yoffset = nvp + ngp + nl*2*nr*nc;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == VDDTSV){
                    Cg = get_onchip_cap(model, grididx, l);
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = -1/Cg; curidx++;
                    Cg = get_onchip_cap(model, grididx, l+1);
                    cooX[curidx] = grididx+2*nr*nc+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = 1/Cg; curidx++;
                    tsv_count++;
                }
            }
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                    Cg = get_onchip_cap(model, grididx, l);
                    cooX[curidx] = grididx+nr*nc+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = -1/Cg; curidx++;
                    Cg = get_onchip_cap(model, grididx, l+1);
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = 1/Cg; curidx++;
                    tsv_count++;
                }
            }
      }
      /* TSVs -> Onchip nodes block */
      tsv_count = 0;
      for(l=0; l<nl-1; l++){
          Ltsv = model->layers[l].tsv.l;
          xoffset = nvp + ngp + nl*2*nr*nc;
          yoffset = nvp + ngp + l*2*nr*nc;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == VDDTSV){
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+yoffset;
                    cooV[curidx] = 1/Ltsv; curidx++;
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+2*nr*nc+yoffset;
                    cooV[curidx] = -1/Ltsv; curidx++;
                    tsv_count++;
                }
            }
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+nr*nc+yoffset;
                    cooV[curidx] = 1/Ltsv; curidx++;
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = -1/Ltsv; curidx++;
                    tsv_count++;
                }
            }
      }
      /* TSV diagonal block */
      xoffset = nvp + ngp + nl*2*nr*nc;
      yoffset = nvp + ngp + nl*2*nr*nc;
      tsv_count = 0;
      for(l=0; l<nl-1; l++){
          Rtsv = model->layers[l].tsv.r;
          Ltsv = model->layers[l].tsv.l;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                if(model->layers[l].tsv.loc[i][j] == VDDTSV){
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = -Rtsv/Ltsv; curidx++;
                    tsv_count++;
                }
            }
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = -Rtsv/Ltsv; curidx++;
                    tsv_count++;
                }
            }
      }
  }
  /* IVR block */
  if(nIVR > 0){
      /* Onchip nodes -> IVR block */
      ivr_idx = 0;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            if(IVRLOC == ivr_loc[i][j]){
                for(l=0; l<nl-1; l++){
                    grididx = i*nc + j;
                    xoffset = nvp + ngp + l*2*nr*nc;
                    yoffset = nvp + ngp + nl*2*nr*nc + ntsv;
                    Cg = get_onchip_cap(model, grididx, l+1);
                    if(l<nl-2)
                      Cm = Cg + 2*Civr;
                    else
                      Cm = Cg;
                    cooX[curidx] = grididx+2*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 1/(Cm*Ront); curidx++;
                    ivr_idx++;
                    cooX[curidx] = grididx+2*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 1/(Cm*Ront); curidx++;
                    ivr_idx++;
                    cooX[curidx] = grididx+nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 1/(Cm*Ronb); curidx++;
                    ivr_idx++;
                    cooX[curidx] = grididx+nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 1/(Cm*Ronb); curidx++;
                    ivr_idx++;
                }
            }
        }
      /* IVR block -> Onchip nodes */
      ivr_idx = 0;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            if(IVRLOC == ivr_loc[i][j]){
                for(l=0; l<nl-1; l++){
                    grididx = i*nc + j;
                    xoffset = nvp + ngp + nl*2*nr*nc + ntsv;
                    yoffset = nvp + ngp + l*2*nr*nc;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+2*nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = 1/(Civr*Ront); curidx++;
                    ivr_idx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+2*nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = 1/(Civr*Ront); curidx++;
                    ivr_idx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = 1/(Civr*Ronb); curidx++;
                    ivr_idx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = 1/(Civr*Ronb); curidx++;
                    ivr_idx++;
                }
            }
        }
      /* Diagonal block */
      xoffset = nvp + ngp + nl*2*nr*nc + ntsv;
      yoffset = nvp + ngp + nl*2*nr*nc + ntsv;
      ivr_idx = 0;
      for(k=0; k<nIVR; k++)
        for(l=0; l<nl-1; l++){
            cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = ivr_idx+yoffset;
            cooV[curidx] = -1/(Civr*Ront); curidx++; ivr_idx++;
            cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = ivr_idx+yoffset;
            cooV[curidx] = -1/(Civr*Ront); curidx++; ivr_idx++;
            cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = ivr_idx+yoffset;
            cooV[curidx] = -1/(Civr*Ronb); curidx++; ivr_idx++;
            cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = ivr_idx+yoffset;
            cooV[curidx] = -1/(Civr*Ronb); curidx++; ivr_idx++;
        }
  }
  if(model->config.PDN_pkgLC){
      /* Bottom row, VDD part */
      xoffset = m - 1;
      yoffset = 0;
      for(i=0; i<nvp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = -iM*iA*iSv; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          if(vs){
              cooX[curidx] = xoffset; cooY[curidx] = grididx+nvp+ngp+(nl-1)*2*nr*nc+yoffset;
          }
          else{
              cooX[curidx] = xoffset; cooY[curidx] = grididx+nvp+ngp+yoffset;
          }
          cooV[curidx] = iM*iA*iPv; curidx++;
      }
      /* Bottom row, GND part */
      xoffset = m - 1;
      yoffset = nvp;
      for(i=0; i<ngp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = -iM*iB*iSg; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = xoffset; cooY[curidx] = grididx+ngp+nr*nc+yoffset;
          cooV[curidx] = -iM*iB*iPg; curidx++;
      }
      /* Right col, VDD part */
      xoffset = 0;
      yoffset = m - 1;
      for(i=0; i<nvp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iQv; curidx++;
      }
      /* Right col, GND part */
      xoffset = nvp;
      yoffset = m - 1;
      for(i=0; i<ngp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iQg; curidx++;
      }
      /* Individual points */
      xoffset = m - 1;
      yoffset = m - 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = -iN; curidx++;
      xoffset = m - 2;
      yoffset = m - 2;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = m - 1;
      yoffset = m - 2;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = -iM; curidx++;
      xoffset = m - 2;
      yoffset = m - 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 1/Cpp; curidx++;
  }
  if(curidx != nnz){
      printf("%d\t%d\n", curidx, nnz);
      fatal("COO Matrix A has different element count than nnz!\n");
  }
  coo2csc(n, nnz, cooX, cooY, cooV, asub, xa, a);
  /* Create matrix A in the format expected by SuperLU. */
  dCreate_CompCol_Matrix(A, m, n, nnz, a, asub, xa, SLU_NC, SLU_D, SLU_GE);
  // Create B
  if ( !(b = doubleMalloc(nnz)) ) fatal("Malloc fails for b[].\n");
  if ( !(bsub = intMalloc(nnz)) ) fatal("Malloc fails for bsub[].\n");
  if ( !(xb = intMalloc(n+1)) ) fatal("Malloc fails for xb[].\n");
  curidx = 0;
  /* Vdd pad dense block */
  xoffset = 0;
  yoffset = 0;
  for(i=0; i<nvp; i++)
    for(j=0; j<nvp; j++){
        cooX[curidx] = i + xoffset;
        cooY[curidx] = j + yoffset;
        if(model->config.PDN_pkgLC)
          cooV[curidx] = -iPv;
        else
          cooV[curidx] = 0;
        curidx++;
    }
  /* Gnd pad dense block */
  xoffset = nvp;
  yoffset = nvp;
  for(i=0; i<ngp; i++)
    for(j=0; j<ngp; j++){
        cooX[curidx] = i + xoffset;
        cooY[curidx] = j + yoffset;
        if(model->config.PDN_pkgLC)
          cooV[curidx] = -iPg;
        else
          cooV[curidx] = 0;
        curidx++;
    }
  /* VDD pad two sparse block */
  xoffset = 0;
  yoffset = 0;
  for(i=0; i<nvp; i++){
      grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
      if(-1 == grididx)
        fatal("Cannot find grid index for VDD pad\n");
      if(vs){
          cooX[curidx] = grididx+nvp+ngp+(nl-1)*2*nr*nc+xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          cooX[curidx] = i+xoffset; cooY[curidx] = grididx+nvp+ngp+(nl-1)*2*nr*nc+yoffset;
          cooV[curidx] = 0; curidx++;
      }
      else{
          cooX[curidx] = grididx+nvp+ngp+xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          cooX[curidx] = i+xoffset; cooY[curidx] = grididx+nvp+ngp+yoffset;
          cooV[curidx] = 0; curidx++;
      }
  }
  /* GND pad two sparse block */
  xoffset = nvp;
  yoffset = nvp;
  for(i=0; i<ngp; i++){
      grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
      if(-1 == grididx)
        fatal("Cannot find grid index for GND pad\n");
      cooX[curidx] = grididx+ngp+nr*nc+xoffset; cooY[curidx] = i+yoffset;
      cooV[curidx] = 0; curidx++;
      cooX[curidx] = i+xoffset; cooY[curidx] = grididx+ngp+nr*nc+yoffset;
      cooV[curidx] = 0; curidx++;
  }
  /* Onchip nodes */
  for(l=0; l<nl; l++){
      /* Vdd grid diagonal block */
      xoffset = nvp + ngp + l*2*nr*nc;
      yoffset = nvp + ngp + l*2*nr*nc;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            if(0 == grididx){//top left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nc-1) == grididx ){//top right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nr*nc-nc) == grididx){//bottom left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nr*nc-1) == grididx){//bottom right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((grididx > 0) && (grididx < nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if(0 == (grididx%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if(0 == ((grididx+1)%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else{
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = 0; curidx++;
        }
      /* Vdd-Gnd grid diagonal */
      xoffset = nvp + ngp + l*2*nr*nc;
      yoffset = nvp + ngp + l*2*nr*nc + nr*nc;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = 0;
            curidx++;
        }
      /* Gnd grid diagonal block */
      xoffset = nvp + ngp + l*2*nr*nc + nr*nc;
      yoffset = nvp + ngp + l*2*nr*nc + nr*nc;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            if(0 == grididx){//top left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nc-1) == grididx ){//top right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nr*nc-nc) == grididx){//bottom left corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((nr*nc-1) == grididx){//bottom right corner
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((grididx > 0) && (grididx < nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if((grididx > nr*nc-nc) && (grididx < nr*nc-1)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if(0 == (grididx%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else if(0 == ((grididx+1)%nc)){
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            else{
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+nc+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx-1+yoffset;
                cooV[curidx] = 0; curidx++;
                cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+1+yoffset;
                cooV[curidx] = 0; curidx++;
            }
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = 0; curidx++;
        }
      /* Gnd-Vdd grid  diagonal */
      xoffset = nvp + ngp + l*2*nr*nc + nr*nc;
      yoffset = nvp + ngp + l*2*nr*nc;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            grididx = i*nc + j;
            cooX[curidx] = grididx+xoffset; cooY[curidx] = grididx+yoffset;
            cooV[curidx] = 0;
            curidx++;
        }
  }
  if(vs){
      /* Onchip nodes -> TSVs block */
      tsv_count = 0;
      for(l=0; l<nl-1; l++){
          xoffset = nvp + ngp + l*2*nr*nc;
          yoffset = nvp + ngp + nl*2*nr*nc;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = 0; curidx++;
                    tsv_count++;
                }
            }
      }
      /* TSVs -> Onchip nodes block */
      tsv_count = 0;
      for(l=0; l<nl-1; l++){
          xoffset = nvp + ngp + nl*2*nr*nc;
          yoffset = nvp + ngp + l*2*nr*nc;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    tsv_count++;
                }
            }
      }
      /* TSV diagonal block */
      xoffset = nvp + ngp + nl*2*nr*nc;
      yoffset = nvp + ngp + nl*2*nr*nc;
      tsv_count = 0;
      for(l=0; l<nl-1; l++){
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = 0; curidx++;
                    tsv_count++;
                }
            }
      }
  }
  else{
      /* Onchip nodes -> TSVs block */
      tsv_count = 0;
      for(l=0; l<nl-1; l++){
          xoffset = nvp + ngp + l*2*nr*nc;
          yoffset = nvp + ngp + nl*2*nr*nc;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == VDDTSV){
                    cooX[curidx] = grididx+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+2*nr*nc+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = 0; curidx++;
                    tsv_count++;
                }
            }
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                    cooX[curidx] = grididx+nr*nc+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = tsv_count+yoffset;
                    cooV[curidx] = 0; curidx++;
                    tsv_count++;
                }
            }
      }
      /* TSVs -> Onchip nodes block */
      tsv_count = 0;
      for(l=0; l<nl-1; l++){
          xoffset = nvp + ngp + nl*2*nr*nc;
          yoffset = nvp + ngp + l*2*nr*nc;
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == VDDTSV){
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+2*nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    tsv_count++;
                }
            }
          for(i=0; i<nr; i++)
            for(j=0; j<nc; j++){
                grididx = i*nc + j;
                if(model->layers[l].tsv.loc[i][j] == GNDTSV){
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    cooX[curidx] = tsv_count+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    tsv_count++;
                }
            }
      }
      /* TSV diagonal block */
      xoffset = nvp + ngp + nl*2*nr*nc;
      yoffset = nvp + ngp + nl*2*nr*nc;
      for(k=0; k<ntsv; k++){
          cooX[curidx] = k+xoffset; cooY[curidx] = k+yoffset;
          cooV[curidx] = 0; curidx++;
      }
  }
  /* IVR block */
  if(nIVR > 0){
      /* Onchip nodes -> IVR block */
      ivr_idx = 0;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            if(IVRLOC == ivr_loc[i][j]){
                for(l=0; l<nl-1; l++){
                    grididx = i*nc + j;
                    xoffset = nvp + ngp + l*2*nr*nc;
                    yoffset = nvp + ngp + nl*2*nr*nc + ntsv;
                    Cg = get_onchip_cap(model, grididx, l+1);
                    Cm = Cg + 2*Civr;
                    cooX[curidx] = grididx+2*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = Civr/Cm; curidx++;
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    ivr_idx++;
                    cooX[curidx] = grididx+2*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = Civr/Cm; curidx++;
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    ivr_idx++;
                    Cg = get_onchip_cap(model, grididx, l);
                    Cm = Cg + 2*Civr;
                    cooX[curidx] = grididx+nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = Civr/Cm; curidx++;
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    ivr_idx++;
                    cooX[curidx] = grididx+nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = Civr/Cm; curidx++;
                    cooX[curidx] = grididx+3*nr*nc+xoffset; cooY[curidx] = ivr_idx+yoffset;
                    cooV[curidx] = 0; curidx++;
                    ivr_idx++;
                }
            }
        }
      /* IVR block -> Onchip nodes */
      ivr_idx = 0;
      for(i=0; i<nr; i++)
        for(j=0; j<nc; j++){
            if(IVRLOC == ivr_loc[i][j]){
                for(l=0; l<nl-1; l++){
                    grididx = i*nc + j;
                    xoffset = nvp + ngp + nl*2*nr*nc + ntsv;
                    yoffset = nvp + ngp + l*2*nr*nc;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+2*nr*nc+yoffset;
                    cooV[curidx] = 1; curidx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    ivr_idx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+2*nr*nc+yoffset;
                    cooV[curidx] = 1; curidx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    ivr_idx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+nr*nc+yoffset;
                    cooV[curidx] = 1; curidx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    ivr_idx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+nr*nc+yoffset;
                    cooV[curidx] = 1; curidx++;
                    cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = grididx+3*nr*nc+yoffset;
                    cooV[curidx] = 0; curidx++;
                    ivr_idx++;
                }
            }
        }
      /* Diagonal block */
      xoffset = nvp + ngp + nl*2*nr*nc + ntsv;
      yoffset = nvp + ngp + nl*2*nr*nc + ntsv;
      ivr_idx = 0;
      for(k=0; k<nIVR; k++)
        for(l=0; l<nl-1; l++){
            cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = ivr_idx+yoffset;
            cooV[curidx] = 0; curidx++; ivr_idx++;
            cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = ivr_idx+yoffset;
            cooV[curidx] = 0; curidx++; ivr_idx++;
            cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = ivr_idx+yoffset;
            cooV[curidx] = 0; curidx++; ivr_idx++;
            cooX[curidx] = ivr_idx+xoffset; cooY[curidx] = ivr_idx+yoffset;
            cooV[curidx] = 0; curidx++; ivr_idx++;
        }
  }
  if(model->config.PDN_pkgLC){
      /* Bottom row, VDD part */
      xoffset = m - 1;
      yoffset = 0;
      for(i=0; i<nvp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_VDD);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          if(vs){
              cooX[curidx] = xoffset; cooY[curidx] = grididx+nvp+ngp+(nl-1)*2*nr*nc+yoffset;
          }
          else{
              cooX[curidx] = xoffset; cooY[curidx] = grididx+nvp+ngp+yoffset;
          }
          cooV[curidx] = 0; curidx++;
      }
      /* Bottom row, GND part */
      xoffset = m - 1;
      yoffset = nvp;
      for(i=0; i<ngp; i++){
          cooX[curidx] = xoffset; cooY[curidx] = i+yoffset;
          cooV[curidx] = 0; curidx++;
          grididx = PadIdx_to_GridIdx(model, i, LAYER_GND);
          if(-1 == grididx)
            fatal("Cannot find grid index for VDD pad\n");
          cooX[curidx] = xoffset; cooY[curidx] = grididx+ngp+nr*nc+yoffset;
          cooV[curidx] = 0; curidx++;
      }
      /* Right col, VDD part */
      xoffset = 0;
      yoffset = m - 1;
      for(i=0; i<nvp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iPv; curidx++;
      }
      /* Right col, GND part */
      xoffset = nvp;
      yoffset = m - 1;
      for(i=0; i<ngp; i++){
          cooX[curidx] = i+xoffset; cooY[curidx] = yoffset;
          cooV[curidx] = -iPg; curidx++;
      }
      /* Individual points */
      xoffset = m - 1;
      yoffset = m - 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = m - 2;
      yoffset = m - 2;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = m - 1;
      yoffset = m - 2;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
      xoffset = m - 2;
      yoffset = m - 1;
      cooX[curidx] = xoffset; cooY[curidx] = yoffset;
      cooV[curidx] = 0; curidx++;
  }
  if(curidx != nnz){
      printf("%d\t%d\n", curidx, nnz);
      fatal("COO Matrix B has different element count than nnz!\n");
  }
  coo2csc(n, nnz, cooX, cooY, cooV, bsub, xb, b);
  dCreate_CompCol_Matrix(&B, m, n, nnz, b, bsub, xb, SLU_NC, SLU_D, SLU_GE);
  // E - B - delta_t*A/2
  SparseMatrix_mul_SingleNum(A, -delta_t/2);
  SparseMatrix_add(A, &B, -1);
  SparseMatrix_add_Iden(A, 1);
  if ( !(rhs = doubleMalloc(m)) ) fatal("Malloc fails for rhs[].\n");
  for(i=0; i<m; ++i) rhs[i] = 1;
  dCreate_Dense_Matrix(&Z, m, 1, rhs, m, SLU_DN, SLU_D, SLU_GE);
  /* Set the default input options. */
  set_default_options(&options);
  options.ColPerm = MMD_AT_PLUS_A;
  options.DiagPivotThresh = 0.01;
  options.SymmetricMode = NO;
  options.Equil = YES;
  /* Initialize the statistics variables. */
  StatInit(&stat);
  /* Solve the linear system. */
  dgssv(&options, A, *perm_c, *perm_r, L, U, &Z, &stat, &info);
  // Create RHS
  // E + (delta_t/2)*J
  SparseMatrix_mul_SingleNum(A, -1);
  SparseMatrix_add(A, &B, -2);
  SparseMatrix_add_Iden(A, 2);
  /* De-allocate storage */
  SUPERLU_FREE (rhs);
  Destroy_SuperMatrix_Store(&Z);
  Destroy_CompCol_Matrix(&B);
  StatFree(&stat);
  free_model_vector(p);
  free(cooV);
  free(cooX);
  free(cooY);
}
void PDN_init_trans_vector(model_t *model, double *g)
{
  int i, l;
  int cur, ntsv;
  int nIVR;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  int nvtsv = model->layers[0].tsv.num_vdd;
  int ngtsv = model->layers[0].tsv.num_gnd;
  int nml = model->layers[0].metal_layers.n_metal/2;
  int nbr = 2*nr*nc - nr - nc;
  int vs = model->config.v_stacking;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  cur = 0;
  if(!model->is_3D){
      for(i=0; i<nvp; i++){
          g[cur] = 0; cur++;
      }
      for(i=0; i<(nr*nc); i++){
          g[cur] = vdd; cur++;
      }
      if(model->config.PDN_gridL){
          for(i=0; i<nbr*nml; i++){
              g[cur] = 0; cur++;
          }
      }
      for(i=0; i<ngp; i++){
          g[cur] = 0; cur++;
      }
      for(i=0; i<(nr*nc); i++){
          g[cur] = gnd; cur++;
      }
      if(model->config.PDN_gridL){
          for(i=0; i<nbr*nml; i++){
              g[cur] = 0; cur++;
          }
      }
      if(model->config.PDN_pkgLC){
          g[cur] = vdd-gnd; cur++;
          g[cur] = 0; cur++;
      }
  }
  else{
      if(vs)
        ntsv = ngtsv*(nl-1);
      else
        ntsv = (nvtsv+ngtsv)*(nl-1);
      for(i=0; i<nvp; i++){
          g[cur] = 0; cur++;
      }
      for(i=0; i<ngp; i++){
          g[cur] = 0; cur++;
      }
      for(l=0; l<nl; l++){
          if(vs){
              for(i=0; i<(nr*nc); i++){
                  g[cur] = (l+1)*vdd; cur++;
              }
              for(i=0; i<(nr*nc); i++){
                  g[cur] = l*vdd; cur++;
              }
          }
          else{
              for(i=0; i<(nr*nc); i++){
                  g[cur] = vdd; cur++;
              }
              for(i=0; i<(nr*nc); i++){
                  g[cur] = gnd; cur++;
              }
          }
      }
      for(i=0; i<ntsv; i++){
          g[cur] = 0;
          cur++;
      }
      if(vs){
          nIVR = model->sc_converter->num_IVR;
          for(i=0; i<nIVR; i++)
            for(l=0; l<nl-1; l++){
                g[cur] = (l+1)*vdd; cur++;
                g[cur] = (l+1)*vdd; cur++;
                g[cur] = (l+1)*vdd; cur++;
                g[cur] = (l+1)*vdd; cur++;
            }
      }
      if(model->config.PDN_pkgLC){
          if(vs)
            g[cur] = nl*(vdd-gnd);
          else
            g[cur] = vdd-gnd;
          cur++;
          g[cur] = 0;
          cur++;
      }
  }
}
void Finalize_rhs(model_t *model, model_vector_t *power)
{
  int i, l;
  int tmp_i, tmp_j;
  int cur;
  int ntsv, nIVR;
  int **ivr_loc;
  int nr = model->rows;
  int nc = model->cols;
  int nl = model->n_layers;
  int nvp = model->c4->vdd_num;
  int ngp = model->c4->gnd_num;
  int nvtsv = model->layers[0].tsv.num_vdd;
  int ngtsv = model->layers[0].tsv.num_gnd;
  int nbr = 2*nr*nc - nr - nc;
  int nml = model->layers[0].metal_layers.n_metal/2;
  int vs = model->config.v_stacking;
  double Cg, Cm, Civr;
  double Lpv = model->c4->pad_l;
  double Lpg = model->c4->pad_l;
  double Lsp = model->config.PDN_pkg_sL;
  double Lpp = model->config.PDN_pkg_pL;
  double vdd = model->config.vdd;
  double gnd = model->config.gnd;
  double delta_t = 1/(model->config.proc_clock_freq*model->config.PDN_step_percycle);
  /* Add TSV RL into pad RL */
  //if(model->is_3D && vs){
  //    double Ltsv_sum = 0;
  //    for(l=0; l<nl-1; l++){
  //        Ltsv_sum += model->layers[l].tsv.l;
  //    }
  //    Lpv += Ltsv_sum;
  //}
  double iA = 1 / (nvp*Lsp/Lpv + 1);
  double iB = 1 / (ngp*Lsp/Lpg + 1);
  double iM = 1 / ((iA+iB)*Lsp + Lpp);
  // Perform last_trans += delta_t(fn + f(n+1))/2
  cur = 0;
  if(!model->is_3D){
      for(i=0; i<nvp; i++){
          model->last_trans[cur] += delta_t * vdd / Lpv;
          cur++;
      }
      for(i=0; i<(nr*nc); i++){
          Cg = get_onchip_cap(model, i, 0);
          model->last_trans[cur] -= (delta_t/2) * 
            (power->cuboid[0][0][i] + model->last_power[i]) / (Cg * (vdd-gnd));
          cur++;
      }
      if(model->config.PDN_gridL){
          for(i=0; i<nbr*nml; i++){
              model->last_trans[cur] += 0;
              cur++;
          }
      }
      for(i=0; i<ngp; i++){
          model->last_trans[cur] -= delta_t * gnd / Lpg;
          cur++;
      }
      for(i=0; i<(nr*nc); i++){
          Cg = get_onchip_cap(model, i, 0);
          model->last_trans[cur] += (delta_t/2) * 
            (power->cuboid[0][0][i] + model->last_power[i]) / (Cg * (vdd-gnd));
          cur++;
      }
      if(model->config.PDN_gridL){
          for(i=0; i<nbr*nml; i++){
              model->last_trans[cur] += 0;
              cur++;
          }
      }
      if(model->config.PDN_pkgLC){
          model->last_trans[cur] += 0;
          cur++;
          model->last_trans[cur] += delta_t * (vdd*iM*iA - gnd*iM*iB);
          cur++;
      }
  }
  else{
      if(vs){
          ntsv = ngtsv*(nl-1);
          nIVR = model->sc_converter->num_IVR;
          Civr = model->sc_converter->c;
          ivr_loc = model->sc_converter->loc;
      }
      else{
          ntsv = (nvtsv+ngtsv)*(nl-1);
          nIVR = 0;
      }
      if(vs)
        for(i=0; i<nvp; i++){
            model->last_trans[cur] += delta_t * nl*vdd / Lpv;
            cur++;
        }
      else
        for(i=0; i<nvp; i++){
            model->last_trans[cur] += delta_t * vdd / Lpv;
            cur++;
        }
      for(i=0; i<ngp; i++){
          model->last_trans[cur] -= delta_t * gnd / Lpg;
          cur++;
      }
      for(l=0; l<nl; l++){
          for(i=0; i<(nr*nc); i++){
              model->last_trans[cur] += 0;
              cur++;
          }
          for(i=0; i<(nr*nc); i++){
              model->last_trans[cur] += 0;
              cur++;
          }
      }
      for(i=0; i<ntsv; i++){
          model->last_trans[cur] += 0;
          cur++;
      }
      for(i=0; i<nIVR*(nl-1)*4; i++){
          model->last_trans[cur] += 0;
          cur++;
      }
      if(model->config.PDN_pkgLC){
          model->last_trans[cur] += 0;
          cur++;
          if(vs)
            model->last_trans[cur] += delta_t * (nl*vdd*iM*iA - gnd*iM*iB);
          else
            model->last_trans[cur] += delta_t * (vdd*iM*iA - gnd*iM*iB);
          cur++;
      }
  }
}
</document_content>
</document>
<document index="26">
<source>pad.c</source>
<document_content>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <math.h>
#include <assert.h>
#include "pad.h"
/* parse pad location information	
 * initialize padloc matrix in PDN struct
 */
void parse_pad_loc(model_t *model, char *file)
{
  char str[LINE_SIZE], copy[LINE_SIZE]; 
  char s[STR_SIZE];
  char name[STR_SIZE];
  int grid_x, grid_y;
  int pad_x, pad_y;
  char *ptr;
  FILE *fp;
  /* short cuts */  
  int nr = model->rows;
  int nc = model->cols;
  int rpg = model->c4->pad_grid_row;
  int cpg = model->c4->pad_grid_col;
  int itv_row = (int)(nr - 1)/(rpg - 1);
  int itv_col = (int)(nc - 1)/(cpg - 1);
  if (!strcasecmp(file, "stdin"))
    fp = stdin;
  else
    fp = fopen (file, "r");
  if (!fp) {
      sprintf(s, "error opening padloc file %s\n", file);
      fatal(s);
  }
  fseek(fp, 0, SEEK_SET);
  while(!feof(fp)) {
      fgets(str, LINE_SIZE, fp);
      if (feof(fp))
        break;
      strcpy(copy, str);
      /* ignore comments and empty lines */
      ptr = strtok(str, " \r\t\n");
      if (!ptr || ptr[0] == '#')
        continue;
      if((0 == model->config.padloc_format) || 
         (1 == model->config.padloc_format)){
          // parse index as metal grid
          if (sscanf(copy, "%s%d%d", name, &grid_x, &grid_y) == 3) {
              if ((grid_x >= model->cols) || (grid_y >= model->rows) ||
                  (grid_x < 0) || (grid_y < 0)){
                  printf("x = %d, y = %d\n", grid_x, grid_y);
                  printf("grid_size = %d*%d\n", model->cols, model->rows);
                  fatal("Pad location does not fit in current grid!\n");
              }
              if (!strcmp(name, "V")){
                  if (PGPAD & model->c4->vdd_loc[nr - grid_y - 1][grid_x])
                    warning("Duplication exists in pad location file .padloc\n");
                  model->c4->vdd_loc[nr - grid_y - 1][grid_x] |= PGPAD;
              }
              else if (!strcmp(name, "G")){
                  if (PGPAD & model->c4->gnd_loc[nr - grid_y - 1][grid_x])
                    warning("Duplication exists in pad location file .padloc\n");
                  model->c4->gnd_loc[nr - grid_y - 1][grid_x] |= PGPAD;
              }
              else
                fatal("Pad location is neither V(vdd) nor G(ground)\n");
          }
          else
            fatal("invalid pad location file format\n");
      }
      else{
          // parse index as pad grid
          if (sscanf(copy, "%s%d%d", name, &pad_x, &pad_y) == 3) {
              grid_x = pad_x * itv_col;
              grid_y = (rpg - pad_y - 1) * itv_row;
              if ((pad_x >= cpg) || (pad_y >= rpg) ||
                  (pad_x < 0) || (pad_y < 0)){
                  printf("pad_x = %d, pad_y = %d\n", pad_x, pad_y);
                  printf("grid_size = %d*%d\n", cpg, rpg);
                  fatal("Pad location does not fit in current grid!\n");
              }
              if (!strcmp(name, "V")){
                  if (PGPAD & model->c4->vdd_loc[grid_y][grid_x])
                    warning("Duplication exists in pad location file .padloc\n");
                  model->c4->vdd_loc[grid_y][grid_x] |= PGPAD;
              }
              else if (!strcmp(name, "G")){
                  if (PGPAD & model->c4->gnd_loc[grid_y][grid_x])
                    warning("Duplication exists in pad location file .padloc\n");
                  model->c4->gnd_loc[grid_y][grid_x] |= PGPAD;
              }
              else
                fatal("Pad location is neither V(vdd) nor G(ground)\n");
          }
          else
            fatal("invalid pad location file format\n");
      }
  }
  if(fp != stdin)
    fclose(fp);
}
/* check whether a grid node is allowed to place IO */
int node_allow_io(model_t *model, int r, int c)
{
  int allow = 0;
  char *name;
  blist_t *ptr;
  ptr = model->layers[0].b2gmap[r][c];
  name = model->layers[0].flp->units[ptr->idx].name;
  if(strlen(name) < 3){
      warning("Some block's name is shorter than 3 char, not going put IO under it\n");
      allow = 0;
  }
  if(name[0] == 'M' &&
     name[1] == 'C'){
      allow = 1;
  }
  else if(name[0] == 'L' &&
          name[1] == '2'){
      allow = 1;
  }
  else if(name[0] == 'N' &&
          name[1] == 'o' &&
          name[2] == 'C'){
      allow = 1;
  }
  else
    allow = 0;
  return allow;
}
/* check whether a grid node is pad candidate */
int is_grid_pad(model_t *model, int r, int c, int layer)
{
  int rpg = model->c4->pad_grid_row;
  int cpg = model->c4->pad_grid_col;
  int nr = model->rows;
  int nc = model->cols;
  int itv_r, itv_c;
  itv_r = (int)((nr - 1)/(rpg - 1));
  itv_c = (int)((nc - 1)/(cpg - 1));
  if(r % itv_r)
    return 0;
  if(c % itv_c)
    return 0;
  if(LAYER_VDD == layer){
      if(((r/itv_r)%2) == ((c/itv_c)%2))
        return 1;
  }
  else if(LAYER_GND == layer){
      if(((r/itv_r)%2) != ((c/itv_c)%2))
        return 1;
  }
  else
    fatal("Wrong arguemnt layer received by is_grid_pad!\n");
  return 0;
}
/* Mark I/O pads as IOPAD or mark range as IORAN
 * Firt mark pads under MCs, if need to mark more,
 * expand along y axis.
 * */
void mark_pads(model_t *model, int pad_type)
{
  int i, m, n;
  PDN_flp_t *flp = model->layers[0].flp;
  int flp_count = flp->n_units;
  double w = model->width;
  double h = model->height;
  double lx, rx, by, ty;
  int lx_cordt, rx_cordt, by_cordt, ty_cordt;
  int **vp = model->c4->vdd_loc;
  int **gp = model->c4->gnd_loc;
  int rpg = model->c4->pad_grid_row;
  int cpg = model->c4->pad_grid_col;
  int nr = model->rows;
  int nc = model->cols;
  int top, btm, lft, rgt;
  int mc_count = 0;
  int padleft_v = 0;
  int padleft_g = 0;
  for(i = 0; i < flp_count; i++){
      if((flp->units[i].name[0] == 'M') && (flp->units[i].name[1] == 'C')){
          if(IOPAD & pad_type){
              padleft_v = model->config.MC_pads / (2 * 0.5);
              padleft_g = model->config.MC_pads / (2 * 0.5);
          }
          else if(IORAN & pad_type){
              padleft_v = model->config.MC_pads / (2 * model->config.IO_dense);
              padleft_g = model->config.MC_pads / (2 * model->config.IO_dense);
          }
          lx = flp->units[i].leftx;
          rx = lx + flp->units[i].width;
          by = flp->units[i].bottomy;
          ty = by + flp->units[i].height;
          lx_cordt = ceil(lx * (nc-1) / w);
          rx_cordt = floor(rx * (nc-1) / w);
          ty_cordt = nr - ceil(by * (nr-1) / h) - 1;
          by_cordt = nr - floor(ty * (nr-1) / h) - 1;
          //under MC
          for(m=by_cordt; m<=ty_cordt; m++)
            for(n=lx_cordt; n<=rx_cordt; n++){
                if ((padleft_v > 0) && 
                    (1 == is_grid_pad(model, m, n, LAYER_VDD))){
                    if (!(vp[m][n] & pad_type)){
                        vp[m][n] |= pad_type;
                        padleft_v--;
                    }
                }
                if ((padleft_g > 0) && 
                    (1 == is_grid_pad(model, m, n, LAYER_GND))){
                    if (!(gp[m][n] & pad_type)){
                        gp[m][n] |= pad_type;
                        padleft_g--;
                    }
                }
            }
          top = ty_cordt;
          btm = by_cordt;
          lft = lx_cordt;
          rgt = rx_cordt;
          while(padleft_v > 0){
              // top
              for(n=lft; n<=rgt; n++){
                  if(padleft_v == 0)
                    break;
                  if(top > nr-1)
                    break;
                  if (1 == is_grid_pad(model, top, n, LAYER_VDD)){
                      if (!(vp[top][n] & pad_type) && node_allow_io(model, top, n)){
                          vp[top][n] |= pad_type;
                          padleft_v--;
                      }
                  }
              }
              // bottom
              for(n=lft; n<=rgt; n++){
                  if(padleft_v == 0)
                    break;
                  if(btm < 0)
                    break;
                  if (1 == is_grid_pad(model, btm, n, LAYER_VDD)){
                      if (!(vp[btm][n] & pad_type) && node_allow_io(model, btm, n)){
                          vp[btm][n] |= pad_type;
                          padleft_v--;
                      }
                  }
              }
              // left
              for(m=btm; m<=top; m++){
                  if(padleft_v == 0)
                    break;
                  if(lft < 0)
                    break;
                  if (1 == is_grid_pad(model, m, lft, LAYER_VDD)){
                      if (!(vp[m][lft] & pad_type) && node_allow_io(model, m, lft)){
                          vp[m][lft] |= pad_type;
                          padleft_v--;
                      }
                  }
              }
              // right
              for(m=btm; m<=top; m++){
                  if(padleft_v == 0)
                    break;
                  if(rgt > nc-1)
                    break;
                  if (1 == is_grid_pad(model, m, rgt, LAYER_VDD)){
                      if (!(vp[m][rgt] & pad_type) && node_allow_io(model, m, rgt)){
                          vp[m][rgt] |= pad_type;
                          padleft_v--;
                      }
                  }
              }
              if(top < nr-1)
                top++;
              else if(btm > 0)
                btm--;
              else if(lft > 0)
                lft--;
              else if(rgt < nc-1)
                rgt++;
              else{
                  warning("All VDD pads are marked!\n");
                  break;
              }
          }
          top = ty_cordt;
          btm = by_cordt;
          lft = lx_cordt;
          rgt = rx_cordt;
          while(padleft_g > 0){
              // top
              for(n=lft; n<=rgt; n++){
                  if(padleft_g == 0)
                    break;
                  if(top > nr-1)
                    break;
                  if (1 == is_grid_pad(model, top, n, LAYER_GND)){
                      if (!(gp[top][n] & pad_type) && node_allow_io(model, top, n)){
                          gp[top][n] |= pad_type;
                          padleft_g--;
                      }
                  }
              }
              // bottom
              for(n=lft; n<=rgt; n++){
                  if(padleft_g == 0)
                    break;
                  if(btm < 0)
                    break;
                  if (1 == is_grid_pad(model, btm, n, LAYER_GND)){
                      if (!(gp[btm][n] & pad_type) && node_allow_io(model, btm, n)){
                          gp[btm][n] |= pad_type;
                          padleft_g--;
                      }
                  }
              }
              // left
              for(m=btm; m<=top; m++){
                  if(padleft_g == 0)
                    break;
                  if(lft < 0)
                    break;
                  if (1 == is_grid_pad(model, m, lft, LAYER_GND)){
                      if (!(gp[m][lft] & pad_type) && node_allow_io(model, m, lft)){
                          gp[m][lft] |= pad_type;
                          padleft_g--;
                      }
                  }
              }
              // right
              for(m=btm; m<=top; m++){
                  if(padleft_g == 0)
                    break;
                  if(rgt > nc-1)
                    break;
                  if (1 == is_grid_pad(model, m, rgt, LAYER_GND)){
                      if (!(gp[m][rgt] & pad_type) && node_allow_io(model, m, rgt)){
                          gp[m][rgt] |= pad_type;
                          padleft_g--;
                      }
                  }
              }
              if(top < nr-1)
                top++;
              else if(btm > 0)
                btm--;
              else if(lft > 0)
                lft--;
              else if(rgt < nc-1)
                rgt++;
              else{
                  warning("All GND pads are marked!\n");
                  break;
              }
          }
          if(padleft_v)
            printf("There are %d Vdd pads not marked yet for MC%d\n", padleft_v, mc_count);
          if(padleft_g)
            printf("There are %d Gnd pads not marked yet for MC%d\n", padleft_g, mc_count);
          mc_count++;
      }
  }
}
void mark_all(model_t *model, int pad_type)
{
  int i, j, nr, nc;
  int rpg, cpg;//pad grid
  int r_cordt, c_cordt;//cordt for pad
  int itv_row, itv_col;
  /* shortcuts */
  nr = model->rows;
  nc = model->cols;
  rpg = model->c4->pad_grid_row;
  cpg = model->c4->pad_grid_col;
  itv_row = (int)(nr - 1)/(rpg - 1);
  itv_col = (int)(nc - 1)/(cpg - 1);
  for(i=0; i<rpg; i++)
    for(j=0; j<cpg; j++){
        r_cordt = i * itv_row;
        c_cordt = j * itv_col;
        if ( (i%2) == (j%2) ){
            model->c4->vdd_loc[r_cordt][c_cordt] |= pad_type;
        }
        else {
            model->c4->gnd_loc[r_cordt][c_cordt] |= pad_type;
        }
    }
}
//radom remove pads for IO
void remove_pg_for_io(model_t *model)
{
  int i, j;
  int vcounter, gcounter;
  vcounter = 0;
  gcounter = 0;
  /* shortcuts */
  int nr = model->rows;
  int nc = model->cols;
  int **vloc = model->c4->vdd_loc;
  int **gloc = model->c4->gnd_loc;
  for(i=0; i<nr; i++){
      for(j=0; j<nc; j++){
          if ((vloc[i][j] & PGPAD) && (vloc[i][j] & IOPAD) &&
              (!check_pad_neighbour(model, i, j, LAYER_VDD)) ){
              vloc[i][j] &= (~PGPAD);
              vcounter++;
          }
          if ((gloc[i][j] & PGPAD) && (gloc[i][j] & IOPAD) &&
              (!check_pad_neighbour(model, i, j, LAYER_GND)) ){
              gloc[i][j] &= (~PGPAD);
              gcounter++;
          }
      }
  }
}
/* Find the neighbor pads of a given pad node.
 * If all of them are connected to power pad, return 0,
 * if not, return 1
 */
int check_pad_neighbour(model_t *model, int r, int c, int grid_type)
{
  int nr, nc;
  int **loc;
  int rpg_r, rpg_c;
  int itv_r, itv_c;
  int rpg, cpg;//pad grid
  int cordt_r,cordt_c;
  int flag = 0;
  /* Shortcuts */
  if(LAYER_VDD == grid_type){
      loc = model->c4->vdd_loc;
  }
  else if(LAYER_GND == grid_type){
      loc = model->c4->gnd_loc;
  }
  else
    fatal("Func check_pad_neighbour received wrong argument grid_type!\n");
  nr = model->rows;
  nc = model->cols;
  rpg = model->c4->pad_grid_row;
  cpg = model->c4->pad_grid_col;
  itv_r = (int)((nr - 1)/(rpg - 1));
  itv_c = (int)((nc - 1)/(cpg - 1));
  if((r%itv_r) || (c%itv_c))
    fatal("Function check_pad_neighbour: got non-pad grid input!\n");
  rpg_r = r / itv_r;
  rpg_c = c / itv_c;
  // North
  if(rpg_r < rpg-2){
      cordt_r = itv_r * (rpg_r + 2);
      cordt_c = itv_c * rpg_c;
      if (!(PGPAD & loc[cordt_r][cordt_c]))
        flag = 1;
  }
  // South
  if(rpg_r > 1){
      cordt_r = itv_r * (rpg_r - 2);
      cordt_c = itv_c * rpg_c;
      if (!(PGPAD & loc[cordt_r][cordt_c]))
        flag = 1;
  }
  // West
  if(rpg_c > 1){
      cordt_r = itv_r * rpg_r;
      cordt_c = itv_c * (rpg_c - 2);
      if (!(PGPAD & loc[cordt_r][cordt_c]))
        flag = 1;
  }
  // East
  if(rpg_c < cpg-2){
      cordt_r = itv_r * rpg_r;
      cordt_c = itv_c * (rpg_c + 2);
      if (!(PGPAD & loc[cordt_r][cordt_c]))
        flag = 1;
  }
  return flag;
  /* An alternative way to do interleave
   * Tend to end up with uneven Vdd/Gnd number
  // North East
  if((rpg_r < rpg-1) && (rpg_c < cpg-1)){
  cordt_r = itv_r * (rpg_r + 1);
  cordt_c = itv_c * (rpg_c + 1);
  if (!(PGPAD & loc[cordt_r][cordt_c]))
  flag = 1;
  }
  // North West
  if((rpg_r < rpg-1) && (rpg_c > 0)){
  cordt_r = itv_r * (rpg_r + 1);
  cordt_c = itv_c * (rpg_c - 1);
  if (!(PGPAD & loc[cordt_r][cordt_c]))
  flag = 1;
  }
  // South West
  if((rpg_r > 0) && (rpg_c > 0)){
  cordt_r = itv_r * (rpg_r - 1);
  cordt_c = itv_c * (rpg_c - 1);
  if (!(PGPAD & loc[cordt_r][cordt_c]))
  flag = 1;
  }
  // South East
  if((rpg_r > 0) && (rpg_c < cpg-1)){
  cordt_r = itv_r * (rpg_r - 1);
  cordt_c = itv_c * (rpg_c + 1);
  if (!(PGPAD & loc[cordt_r][cordt_c]))
  flag = 1;
  }
  */
}
void dump_anypadloc(model_t *model, char *file, int type)
{
  int i, j;
  int pad_r, pad_c;
  char str[STR_SIZE];
  FILE *fp;
  /* shortcuts */
  int nr = model->rows;
  int nc = model->cols;
  int **vloc = model->c4->vdd_loc;
  int **gloc = model->c4->gnd_loc;
  int rpg = model->c4->pad_grid_row;
  int cpg = model->c4->pad_grid_col;
  int itv_row = (int)(nr - 1)/(rpg - 1);
  int itv_col = (int)(nc - 1)/(cpg - 1);
  if (!strcasecmp(file, "stdout"))
    fp = stdout;
  else if (!strcasecmp(file, "stderr"))
    fp = stderr;
  else 	
    fp = fopen (file, "w");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for writing\n", file);
      fatal(str);
  }
  if((0 == model->config.padloc_format) || 
     (2 == model->config.padloc_format)){
      // dump metal grid index
      for(i=0; i < nr; i++){
          for(j=0; j < nc; j++){
              if (vloc[i][j] & type){
                  fprintf(fp, "V\t%d\t%d\n", j, nr-i-1);
              }
              if (gloc[i][j] & type){
                  fprintf(fp, "G\t%d\t%d\n", j, nr-i-1);
              }
          }
      }
  }
  else{
      // dump pad grid index
      for(i=0; i < nr; i++){
          for(j=0; j < nc; j++){
              if (vloc[i][j] & type){
                  pad_r = i/itv_row;
                  pad_c = j/itv_col;
                  fprintf(fp, "V\t%d\t%d\n", pad_c, rpg-pad_r-1);
              }
              if (gloc[i][j] & type){
                  pad_r = i/itv_row;
                  pad_c = j/itv_col;
                  fprintf(fp, "G\t%d\t%d\n", pad_c, rpg-pad_r-1);
              }
          }
      }
  }
  if(fp != stdout && fp != stderr)
    fclose(fp);	
}
void dump_cur_with_cordt(model_t *model, status_t *status, char *file)
{
  int i, j;
  int pad_r, pad_c;
  char str[STR_SIZE];
  FILE *fp;
  /* shortcuts */
  int nr = model->rows;
  int nc = model->cols;
  int rpg = model->c4->pad_grid_row;
  int cpg = model->c4->pad_grid_col;
  int itv_row = (int)(nr - 1)/(rpg - 1);
  int itv_col = (int)(nc - 1)/(cpg - 1);
  int **vloc = model->c4->vdd_loc;
  int **gloc = model->c4->gnd_loc;
  double **vcur = status->vdd_cur;
  double **gcur = status->gnd_cur;
  double padD = model->config.PDN_padD/2;
  double pad_area = PI * padD * padD;
  if (!strcasecmp(file, "stdout"))
    fp = stdout;
  else if (!strcasecmp(file, "stderr"))
    fp = stderr;
  else 	
    fp = fopen (file, "w");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for writing\n", file);
      fatal(str);
  }
  if((0 == model->config.padloc_format) || 
     (2 == model->config.padloc_format)){
      // dump metal grid index
      for(i=0; i < nr; i++){
          for(j=0; j < nc; j++){
              if (vloc[i][j] & PGPAD){
                  fprintf(fp, "V\t%d\t%d\t%e\n", j, nr-i-1, vcur[i][j]/pad_area);
              }
              if (gloc[i][j] & PGPAD){
                  fprintf(fp, "G\t%d\t%d\t%e\n", j, nr-i-1, gcur[i][j]/pad_area);
              }
          }
      }
  }
  else{
      // dump pad grid index
      for(i=0; i < nr; i++){
          for(j=0; j < nc; j++){
              if (vloc[i][j] & PGPAD){
                  pad_r = i/itv_row;
                  pad_c = j/itv_col;
                  fprintf(fp, "V\t%d\t%d\t%e\n", pad_c, rpg-pad_r-1, vcur[i][j]/pad_area);
              }
              if (gloc[i][j] & PGPAD){
                  pad_r = i/itv_row;
                  pad_c = j/itv_col;
                  fprintf(fp, "G\t%d\t%d\t%e\n", pad_c, rpg-pad_r-1, gcur[i][j]/pad_area);
              }
          }
      }
  }
  if(fp != stdout && fp != stderr)
    fclose(fp);	
}
// count pads that at least have type pad_type
int count_pads(int **loc, int nr, int nc, int pad_type)
{
  int sum = 0;
  int i, j;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++){
        if ((pad_type & loc[i][j]) == pad_type)
          sum++;
    }
  return sum;
}
</document_content>
</document>
<document index="27">
<source>pad.h</source>
<document_content>
#ifndef __PAD_H_
#define __PAD_H_
#include "PDN_sim.h"
#include "PDN_analyze.h"
// pad location definition
#define UNDEF            0
#define PGPAD            1
#define IOPAD            (1<<1)
#define IORAN            (1<<2)
/* pad manipulation	*/
void mark_pads(model_t *model, int pad_type);
void mark_all(model_t *model, int pad_type);
void remove_pg_for_io(model_t *model);
int check_pad_neighbour(model_t *model, int r, int c, int grid_type);
int is_grid_pad(model_t *model, int r, int c, int layer);
int node_allow_io(model_t *model, int r, int c);
void parse_pad_loc(model_t *model, char *file);
int count_pads(int **loc, int nr, int nc, int pad_type);
void dump_anypadloc(model_t *model, char *file, int type);
void dump_cur_with_cordt(model_t *model, status_t *status, char *file);
#endif
</document_content>
</document>
<document index="28">
<source>pdn.config</source>
<document_content>
# PDN physical parameters
  # C4 pad pitch (m)
  -PDN_padpitch  285e-6
  # C4 pad diameter (m)
  -PDN_padD      100e-6
  # C4 pad resistance (Ohm)
  -PDN_padR      10e-3
  # C4 pad current density threshold (A/m^2)
  -PDN_cur_dense 8.5e7
  # How are the pads distributed 
  # 0: load pad location from padloc_file_in;
  # 1: all seats for pads are filled with P/G;
  -PDN_padconfig    1
	# pad location input file
	-padloc_file_in	  example.padloc
  # pad location file format
  # 0: parse as on-chip virtual grid, dump as on-chip virtual grid
  # 1: parse as on-chip virtual grid, dump as pad grid
  # 2: parse as pad grid, dump as on-chip virtual grid
  # 3: parse as pad grid, dump as pad grid
  -padloc_format    0
	# Metal layer specification file
  # If not specified, use default values. For more details,
  # see function populate_defalt_mlayers in PDN_sim.c
	-mlayer_spec_file   (null)
  # On-chip decap
  -PDN_decap_dense    100       # decap density (nF/mm2)
  -PDN_decap_ratio    0.10      # % of chip area dedicated for decap
  # Package RLC values
  -PDN_padL           7.2e-12   # pad L
  -PDN_pkg_sL         3e-12     # serial part of package L
  -PDN_pkg_sR         0.015e-3  # serial part of package R
  -PDN_pkg_C          26.4e-6   # package C
  -PDN_pkg_pR         0.5415e-3 # parallel part of package R
  -PDN_pkg_pL         4.61e-12  # parallel part of package L
  # Supply voltage
  -vdd                   1         # global power supply (V)
  -gnd                   0         # global ground (V)
# 3D PDN
  # 3D layer spec file
	-layer_file_3D       (null)
  # switch for voltage stacking
	-v_stacking          0
  # how are the TSVs distributed 
  # 0: through tsvloc files specified by lcf file
  # 1: all grid nodes are connected to TSVs;
	-TSV_config          1
  # TSV parameters 
	-TSV_R               46.85e-3
	-TSV_L               34.262e-12
  # location file for IVRs (all layer same loc)
  -IVR_loc_file        (null)
  # Parameters for SC converters
  -SC_freq             50e6
  -SC_totcap           8e-9
  -SC_Rontop           1.052
  -SC_Ronbtm           1.17
# PDN simulation parameters
  # modeling granularity, larger numer => finer on-chip grid
  # on-chip grid row/col ~= PDN_grid_intv * pad grid row/col
  -PDN_grid_intv       2
  # switch for steady state PDN simulation 
  # 0 - no steady state; 
  # 1 - run steady state, use ptrace average
  -run_PDN      0
  # Processor clock frequency (Hz)
  -proc_clock_freq       3.7e9
  # Power trace sampling interval (number of clock cycles)
	-ptrace_sampling_intvl 1
  # Transient Time step (per clock cycle)
  -PDN_step_percycle     5 
	# number of power trace lines for warm up, no stats analyse during warm up
	-PDN_ptrace_warmup     0
  # transient package switch, if 0, package only have resistance
  -PDN_pkgLC     1
  # transient onchip L switch, if 0, on-chip gird only have resistance
  -PDN_gridL     1
# PDN stats dump files
	# pad current output file
	-padcur_file	      (null)
	# grid voltage output file
  # Can be used for both steady state drop and transient droop
	-gridvol_file	      (null)
	# grid voltage output file
	-vio_file   	      (null)
	# grid node per cycle violatoin trace file
	-node_viotrace_file    (null)
  # Voltage noise threshold in analysis (%Vdd)
  -PDN_noise_th    5
# Debug/Development parameters
	# sensor location input file, automatically use if specified
	-senloc_file       (null)
  # Create voltage map animation, one frame per intv time steps
  #-animation     0 # 1-2D Voltage plot, 2-3D Voltage plot, 3-Current plot
  #-frame_intv    5
  # Color map range for Voltage graph, ratio of Vdd
  #-legend_lwr    0.05
  #-legend_upr    0.03
  # Color map range for Current graph, in A 
  #-legend_curupr 0.02
  # generate sin wave as power trace internally
  # switch
  #-PDN_sin_pattern   0
  # how many time steps to simulate
  #-PDN_sin_totstep   5000
  # frequency of sin wave
  #-PDN_sin_freq      100e6
  # multi-domain PDN; cores per domain, 0 for uni-domain
  # negative values for special
  #-PDN_multi_dom     0
  # use this parameter scale package parameters
  #-PDN_pkg_scale      1         # Area_chip/Area_domain
</document_content>
</document>

<document index="31">
<source>steady.gridIR</source>
<document_content>
#Layer:0
0	72	0.121134
1	72	0.133823
... ... ...
40	0	0.078362 
</document_content>
</document>
<document index="32">
<source>trans.viomap</source>
<document_content>
0	73	1	0.151128	5.096285
1	73	2	0.163924	5.122604
... ... ... ... ...
72	1	2	0.107067	5.036376
END_OF_PER_NODE_STATS
MC1	38	7.249590
FPU1	33	6.060830
ALU1	45	8.091207
IntRF1	22	5.762257
CplALU1	22	5.788025
FlpRF1	17	5.745610
ROB1	38	14.179164
IntIW1	39	6.201446
FlpIW1	26	6.258839
IntRAT1	24	6.336719
FL1	18	6.424052
FlpRAT1	19	6.604247
Dtlb1	10	5.890047
Itlb1	7	6.073685
InstDec1	19	5.966648
BTB1	8	5.869554
InstBuf1	9	5.941206
BrP1	9	5.757754
ICache1	14	5.953783
StQ1	26	6.164495
LdQ1	20	5.846878
DCache1	28	7.402492
NoC1	7	5.750811
L2_1	6	5.671669
FPU2	35	7.462680
ALU2	59	7.731755
IntRF2	28	7.483663
CplALU2	24	7.096018
FlpRF2	22	7.076219
ROB2	60	11.491233
IntIW2	43	7.481453
FlpIW2	33	7.211434
IntRAT2	34	7.009609
FL2	26	6.757681
FlpRAT2	29	6.848995
Dtlb2	13	5.738599
Itlb2	10	5.747617
InstDec2	27	6.427957
BTB2	11	5.609028
InstBuf2	11	5.814614
BrP2	13	5.718679
ICache2	21	6.292450
StQ2	20	6.649985
LdQ2	20	6.584647
DCache2	29	6.213618
NoC2	10	5.471312
L2_2	8	5.461321
</document_content>
</document>
<document index="33">
<source>trans.vtrace</source>
<document_content>
PDN_grid_intv=2
Metal Layer 0: p3.000000e-05	w1.000000e-05	t3.500000e-06
R:0.029265	L:4.504143e-11
Metal Layer 1: p3.000000e-05	w1.000000e-05	t3.500000e-06
R:0.029265	L:4.504118e-11
Metal Layer 2: p8.100000e-07	w4.000000e-07	t7.200000e-07
R:0.095817	L:4.759316e-13
Metal Layer 3: p8.100000e-07	w4.000000e-07	t7.200000e-07
R:0.095817	L:4.759289e-13
PDN_padpitch=2.850000e-04
PDN_padD=1.000000e-04
PDN_padR=1.000000e-02
PDN_cur_dense=8.500000e+07
PDN_padconfig=1
padloc_format=0
PDN_decap_dense=1.000000e+02
PDN_decap_ratio=1.000000e-01
PDN_decap_unifm=0
PDN_padL=7.200000e-12
PDN_pkg_sL=3.000000e-12
PDN_pkg_sR=1.500000e-05
PDN_pkg_C=2.640000e-05
PDN_pkg_pR=5.415000e-04
PDN_pkg_pL=4.610000e-12
PDN_pkg_scale=1.000000e+00
vdd=1.000000e+00
gnd=0.000000e+00
proc_clock_freq=3.700000e+09
PDN_step_percycle=5
ptrace_sampling_intvl=1
PDN_ptrace_warmup=0
PDN_multi_dom=0
v_stacking=0
TSV_config=1
TSV_R=0.046850
TSV_L=0.000000
SC_freq=50000000.000000
SC_totcap=0.000000
SC_Rontop=1.052000
SC_Ronbtm=1.170000
run_PDN=0
PDN_pkgLC=1
PDN_gridL=1
PDN_sin_pattern=0
PDN_sin_totstep=10000
PDN_sin_freq=1.000000e+08
mlayer_spec_file=(null)
layer_file_3D=(null)
padloc_file_out=(null)
vio_file=(null)
node_viotrace_file=(null)
trans_vgradient_file=(null)
senloc_file=(null)
padcur_file=(null)
tsvcur_file=(null)
gridvol_file=(null)
END_OF_CONFIGS
pkgDrop	max_onchip_drop	
0.0224	0.5441	
0.2295	1.4570	
......     ......
-0.3579	-0.2028	
#END
</document_content>
</document>
<document index="34">
<source>util.c</source>
<document_content>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <sys/time.h>
#include <time.h>
#include "slu_ddefs.h"
#ifdef _MSC_VER
#define strcasecmp    _stricmp
#define strncasecmp   _strnicmp
#else
#include <strings.h>
#endif
#include <assert.h>
#include "util.h"
int eq(double x, double y)
{
  return (fabs(x-y) <  DELTA);
}
int le(double x, double y)
{
  return ((x < y) || eq(x,y));
}
int ge(double x, double y)
{
  return ((x > y) || eq(x,y));
}
void fatal(char *s)
{
  fprintf(stderr, "error: %s", s);
  exit(1);
}
void warning(char *s)
{
  fprintf(stderr, "warning: %s", s);
}
void swap_ival (int *a, int *b)
{
  int t = *a;
  *a = *b;
  *b = t;
}
void swap_dval (double *a, double *b)
{
  double t = *a;
  *a = *b;
  *b = t;
}
int tolerant_ceil(double val)
{
  double nearest = floor(val+0.5);
  /* numbers close to integers	*/
  if (eq(val, nearest))
    return ((int) nearest);
  /* all others	*/	
  else 
    return ((int) ceil(val));
}
int tolerant_floor(double val)
{
  double nearest = floor(val+0.5);
  /* numbers close to integers	*/
  if (eq(val, nearest))
    return ((int) nearest);
  /* all others	*/	
  else 
    return ((int) floor(val));
}
double *dvector(int n)
{
  double *v;
  v=(double *)calloc(n, sizeof(double));
  if (!v) fatal("allocation failure in dvector()\n");
  return v;
}
double **dvector_2D(int n, int d)
{
  double **v;
  int i;
  v=(double **)calloc(d, sizeof(double *));
  if (!v) fatal("allocation failure in dvector_2D()\n");
  for (i=0; i<d; i++){
      v[i]=(double *)calloc(n, sizeof(double));
      if (!v[i]) fatal("allocation failure in dvector_2D()\n");
  }
  return v;
}
void free_dvector(double *v)
{
  free(v);
}
void free_dvector_2D(double **v, int d)
{
  int i;
  for (i=0; i<d; i++)
    free(v[i]);
  free(v);
}
void dump_dvector (double *v, int n)
{
  int i;
  for (i=0; i < n; i++)
    fprintf(stdout, "%e\t", v[i]);
  //fprintf(stdout, "%18.20e\t", v[i]);
  fprintf(stdout, "\n");
}	
void copy_dvector (double *dst, double *src, int n)
{
  memmove(dst, src, sizeof(double) * n);
}
void zero_dvector (double *v, int n)
{
  memset(v, 0, sizeof(double) * n);
}
void negL_dvector (double *v, int n)
{
  int i;
  for(i=0; i < n; i++)
    v[i] = -LARGENUM;
}
/* sum of the elements	*/
double sum_dvector (double *m, int n)
{
  double sum = 0;
  int i;
  for(i=0; i < n; i++)
    sum += m[i];
  return sum;	
}
void mul_val_dvector(double *m, double val, int len)
{
  int i;
  for(i = 0; i < len; i++)
    m[i] = m[i] * val;
}
void sub_dvector(double *dst, double *rs1, double *rs2, int len)
{
  int i;
  for(i = 0; i < len; i++)
    dst[i] = rs1[i] - rs2[i];
}
void add_dvector(double *dst, double *rs1, double *rs2, int len)
{
  int i;
  for(i = 0; i < len; i++)
    dst[i] = rs1[i] + rs2[i];
}
void sin_dvector(double *dst, double *amp, double time, double freq, int len)
{
  int i;
  for(i = 0; i < len; i++){
      dst[i] = 3*amp[i]/4 + (amp[i]*sin(2*PI*freq*time)/4);
  }
}
int *ivector(int n)
{
  int *v;
  v = (int *)calloc(n, sizeof(int));
  if (!v) fatal("allocation failure in ivector()\n");
  return v;
}
int **ivector_2D(int n, int d)
{
  int **v;
  int i;
  v=(int **)calloc(d, sizeof(int *));
  if (!v) fatal("allocation failure in ivector_2D()\n");
  for (i=0; i<d; i++){
      v[i]=(int *)calloc(n, sizeof(int));
      if (!v[i]) fatal("allocation failure in ivector_2D()\n");
  }
  return v;
}
void free_ivector(int *v)
{
  free(v);
}
void free_ivector_2D(int **v, int d)
{
  int i;
  for (i=0; i<d; i++)
    free(v[i]);
  free(v);
}
void dump_ivector (int *v, int n)
{
  int i;
  for (i=0; i < n; i++)
    fprintf(stdout, "%d\t", v[i]);
  fprintf(stdout, "\n\n");
}
void copy_ivector (int *dst, int *src, int n)
{
  memmove(dst, src, sizeof(int) * n);
}
void zero_ivector (int *v, int n)
{
  memset(v, 0, sizeof(int) * n);
}
void abs_ivector (int *v, int n)
{
  int i;
  for (i=0; i < n; i++){
      if(v[i] < 0)
        v[i] *= -1;
  }
}
void abs_dvector (double *v, int n)
{
  int i;
  for (i=0; i < n; i++){
      if(v[i] < 0)
        v[i] = -v[i];
  }
}
/* 
 * Thanks to Greg Link from Penn State University 
 * for these memory allocators/deallocators	
 */
double **dmatrix(int nr, int nc)
{
  int i;
  double **m;
  m = (double **) calloc (nr, sizeof(double *));
  assert(m != NULL);
  m[0] = (double *) calloc (nr * nc, sizeof(double));
  assert(m[0] != NULL);
  for (i = 1; i < nr; i++)
    m[i] =  m[0] + nc * i;
  return m;
}
void free_dmatrix(double **m)
{
  free(m[0]);
  free(m);
}
int **imatrix(int nr, int nc)
{
  int i;
  int **m;
  m = (int **) calloc (nr, sizeof(int *));
  assert(m != NULL);
  m[0] = (int *) calloc (nr * nc, sizeof(int));
  assert(m[0] != NULL);
  for (i = 1; i < nr; i++)
    m[i] = m[0] + nc * i;
  return m;
}
void free_imatrix(int **m)
{
  free(m[0]);
  free(m);
}
void dump_dmatrix (double **m, int nr, int nc)
{
  int i;
  for (i=0; i < nr; i++)
    dump_dvector(m[i], nc);
  fprintf(stdout, "\n");
}	
void dump_dmatrix_file(double **m, int nr, int nc, char *file)
{
  int i, j;
  char str[STR_SIZE];
  FILE *fp;
  if (!strcasecmp(file, "stdout"))
    fp = stdout;
  else if (!strcasecmp(file, "stderr"))
    fp = stderr;
  else 	
    fp = fopen (file, "w");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for writing\n", file);
      fatal(str);
  }
  for(i=0; i < nr; i++){
      for(j=0; j < nc; j++){
          fprintf(fp, "%.6f ",m[i][j]);
      }
      fprintf(fp, "\n");
  }
  if(fp != stdout && fp != stderr)
    fclose(fp);	
}
void dump_dmatrix_skip0_file(double **m, int nr, int nc, char *file)
{
  int i, j;
  int flag;
  char str[STR_SIZE];
  FILE *fp;
  if (!strcasecmp(file, "stdout"))
    fp = stdout;
  else if (!strcasecmp(file, "stderr"))
    fp = stderr;
  else 	
    fp = fopen (file, "w");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for writing\n", file);
      fatal(str);
  }
  for(i=0; i < nr; i++){
      flag = 0;
      for(j=0; j < nc; j++){
          if (m[i][j]!=0.0){
              flag = 1;
              fprintf(fp, "%.6f ",m[i][j]);
          }
      }
      if (flag == 1)
        fprintf(fp, "\n");
  }
  if(fp != stdout && fp != stderr)
    fclose(fp);	
}
void copy_dmatrix (double **dst, double **src, int nr, int nc)
{
  memmove(dst[0], src[0], sizeof(double) * nr * nc);
}
void zero_dmatrix(double **m, int nr, int nc)
{
  memset(m[0], 0, sizeof(double) * nr * nc);
}
void resize_dmatrix(double **m, int nr, int nc)
{
  int i;
  for (i = 1; i < nr; i++)
    m[i] = m[0] + nc * i;
}
/* allocate 3-d matrix with 'nr' rows, 'nc' cols, 
 * 'nl' layers	and a tail of 'xtra' elements 
 */
double ***dcuboid_tail(int nr, int nc, int nl, int xtra)
{
  int i, j;
  double ***m;
  /* 1-d array of pointers to the rows of the 2-d array below	*/
  m = (double ***) calloc (nl, sizeof(double **));
  assert(m != NULL);
  /* 2-d array of pointers denoting (layer, row)	*/
  m[0] = (double **) calloc (nl * nr, sizeof(double *));
  assert(m[0] != NULL);
  /* the actual 3-d data array	*/
  m[0][0] = (double *) calloc (nl * nr * nc + xtra, sizeof(double));
  assert(m[0][0] != NULL);
  /* remaining pointers of the 1-d pointer array	*/
  for (i = 1; i < nl; i++)
    m[i] =  m[0] + nr * i;
  /* remaining pointers of the 2-d pointer array	*/
  for (i = 0; i < nl; i++)
    for (j = 0; j < nr; j++)
      /* to reach the jth row in the ith layer, 
       * one has to cross i layers i.e., i*(nr*nc)
       * values first and then j rows i.e., j*nc 
       * values next
       */
      m[i][j] =  m[0][0] + (nr * nc) * i + nc * j;
  return m;
}
void free_dcuboid(double ***m)
{
  free(m[0][0]);
  free(m[0]);
  free(m);
}
/* mirror the lower triangle to make 'm' fully symmetric	*/
void mirror_dmatrix(double **m, int n)
{
  int i, j;
  for(i=0; i < n; i++)
    for(j=0; j < i; j++)
      m[j][i] = m[i][j];
}
void dump_imatrix (int **m, int nr, int nc)
{
  int i;
  for (i=0; i < nr; i++)
    dump_ivector(m[i], nc);
  fprintf(stdout, "\n");
}	
void dump_imatrix_file(int **m, int nr, int nc, char *file)
{
  int i, j;
  char str[STR_SIZE];
  FILE *fp;
  if (!strcasecmp(file, "stdout"))
    fp = stdout;
  else if (!strcasecmp(file, "stderr"))
    fp = stderr;
  else 	
    fp = fopen (file, "w");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for writing\n", file);
      fatal(str);
  }
  for(i=0; i < nr; i++){
      for(j=0; j < nc; j++){
          fprintf(fp, "%d ",m[i][j]);
      }
      fprintf(fp, "\n");
  }
  if(fp != stdout && fp != stderr)
    fclose(fp);	
}
void dump_imatrix_skip0_file(int **m, int nr, int nc, char *file)
{
  int i, j;
  int flag;
  char str[STR_SIZE];
  FILE *fp;
  if (!strcasecmp(file, "stdout"))
    fp = stdout;
  else if (!strcasecmp(file, "stderr"))
    fp = stderr;
  else 	
    fp = fopen (file, "w");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for writing\n", file);
      fatal(str);
  }
  for(i=0; i < nr; i++){
      flag = 0;
      for(j=0; j < nc; j++){
          if (m[i][j]!=0){
              flag = 1;
              fprintf(fp, "%d ",m[i][j]);
          }
      }
      if (flag == 1)
        fprintf(fp, "\n");
  }
  if(fp != stdout && fp != stderr)
    fclose(fp);	
}
void copy_imatrix (int **dst, int **src, int nr, int nc)
{
  memmove(dst[0], src[0], sizeof(int) * nr * nc);
}
void resize_imatrix(int **m, int nr, int nc)
{
  int i;
  for (i = 1; i < nr; i++)
    m[i] = m[0] + nc * i;
}
/* Added by Runjie
 * Cound # of elements in a matrix larger than threshold */
int above_threshold_dmatrix(double **m, int nr, int nc, double th)
{
  int i, j;
  int count = 0;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++){
        if (m[i][j] >= th)
          count++;
    }
  return count;
}
/* Added by Runjie
 * Cound # of elements in a vector larger than threshold */
int above_threshold_dvector(double *m, int n, double th)
{
  int i;
  int count = 0;
  for(i = 0; i < n; i++)
    if (m[i] >= th)
      count++;
  return count;
}
double sum_dmatrix(double **m, int nr, int nc)
{
  int i, j;
  double sum = 0;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++)
      sum += m[i][j];
  return sum;
}
int sum_imatrix(int **m, int nr, int nc)
{
  int i, j;
  int sum = 0;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++)
      sum += m[i][j];
  return sum;
}
double ave_dmatrix(double **m, int nr, int nc)
{
  int i, j;
  double ave;
  double temp = 0;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++)
      temp += m[i][j];
  ave = temp / (nr*nc);
  return ave;
}
double ave_dvector(double *m, int n)
{
  int i;
  double ave;
  double temp = 0;
  for(i = 0; i < n; i++)
    temp += m[i];
  ave = temp / n;
  return ave;
}
double max_dmatrix(double **m, int nr, int nc)
{
  int i, j;
  double max = -LARGENUM;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++)
      if(m[i][j] > max)
        max = m[i][j];
  return max;
}
double max_dmatrix_pos(double **m, int nr, int nc, int *x, int *y)
{
  int i, j;
  double max = -LARGENUM;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++)
      if(m[i][j] > max)
        {
          max = m[i][j];
          *x=i;
          *y=j;
        }
  return max;
}
double max_dvector(double *m, int n)
{
  int i;
  double max = -LARGENUM;
  for(i = 0; i < n; i++)
    if(m[i] > max)
      max = m[i];
  return max;
}
double min_dmatrix(double **m, int nr, int nc)
{
  int i, j;
  double min = LARGENUM;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++)
      if(m[i][j] < min)
        min = m[i][j];
  return min;
}
double min_dmatrix_pos(double **m, int nr, int nc, int *x, int *y)
{
  int i, j;
  double min = LARGENUM;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++)
      if(m[i][j] < min)
        {
          min = m[i][j];
          *x=i;
          *y=j;
        }
  return min;
}
double min_dvector(double *m, int n)
{
  int i;
  double min = LARGENUM;
  for(i = 0; i < n; i++)
    if(m[i] < min)
      min = m[i];
  return min;
}
double var_dmatrix(double **m, int nr, int nc, double ave)
{
  int i, j;
  double temp = 0;
  double var;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++){
        temp += (ave - m[i][j]) * (ave - m[i][j]);
    }
  var  = (double) temp / (nc*nr);
  return sqrt(var);
}
double var_dvector(double *m, int n, double ave)
{
  int i;
  double temp = 0;
  double var;
  for(i = 0; i < n; i++)
    temp += (ave - m[i]) * (ave - m[i]);
  var  = (double) temp / n;
  return sqrt(var);
}
double ave_dmatrix_skip0(double **m, int nr, int nc)
{
  int i, j;
  int counter = 0;
  double ave;
  double temp = 0;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++)
      if (m[i][j] != 0){
          counter++;
          temp += m[i][j];
      }
  ave = temp / counter;
  return ave;
}
double max_dmatrix_skip0(double **m, int nr, int nc)
{
  int i, j;
  double max = -LARGENUM;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++)
      if((m[i][j] != 0) && (m[i][j] > max))
        max = m[i][j];
  return max;
}
double max_dvector_skip0(double *m, int n)
{
  int i;
  double max = -LARGENUM;
  for(i = 0; i < n; i++)
    if((m[i] != 0) && (m[i] > max))
      max = m[i];
  return max;
}
double min_dmatrix_skip0(double **m, int nr, int nc)
{
  int i, j;
  double min = LARGENUM;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++)
      if((m[i][j] != 0) && (m[i][j] < min))
        min = m[i][j];
  return min;
}
double var_dmatrix_skip0(double **m, int nr, int nc, double ave)
{
  int i, j;
  int counter = 0;
  double temp = 0;
  double var;
  for(i = 0; i < nr; i++)
    for(j = 0; j < nc; j++)
      if (m[i][j] != 0){
          counter++;
          temp += (ave - m[i][j]) * (ave - m[i][j]);
      }
  var  = (double) temp / counter;
  return sqrt(var);
}
/* initialize random number generator	*/
void init_rand(void)
{
  srand(RAND_SEED);
}
/* random number within the range [0, max-1]	*/
int rand_upto(int max)
{
  return (int) (max * (double) rand() / (RAND_MAX+1.0));
}
/* random number in the range [0, 1)	*/
double rand_fraction(void)
{
  return ((double) rand() / (RAND_MAX+1.0));
}
/* 
 * reads tab-separated name-value pairs from file into
 * a table of size max_entries and returns the number 
 * of entries read successfully
 */
int read_str_pairs(str_pair *table, int max_entries, char *file)
{
  int i=0;
  char str[LINE_SIZE], copy[LINE_SIZE];
  char name[STR_SIZE];
  char *ptr;
  FILE *fp = fopen (file, "r");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for reading\n", file);
      fatal(str);
  }
  while(i < max_entries) {
      fgets(str, LINE_SIZE, fp);
      if (feof(fp))
        break;
      strcpy(copy, str);
      /* ignore comments and empty lines  */
      ptr = strtok(str, " \r\t\n");
      if (!ptr || ptr[0] == '#') 
        continue;
      if ((sscanf(copy, "%s%s", name, table[i].value) != 2) || (name[0] != '-'))
        fatal("invalid file format\n");
      /* ignore the leading "-"	*/
      strcpy(table[i].name, &name[1]);
      i++;
  }
  fclose(fp);
  return i;
}
/* 
 * same as above but from command line instead of a file. the command
 * line is of the form <prog_name> <name-value pairs> where
 * <name-value pairs> is of the form -<variable> <value>
 */
int parse_cmdline(str_pair *table, int max_entries, int argc, char **argv)
{
  int i, count;
  for (i=1, count=0; i < argc && count < max_entries; i++) {
      if (i % 2) {	/* variable name	*/
          if (argv[i][0] != '-')
            fatal("invalid command line. check usage\n");
          /* ignore the leading "-"	*/	
          strncpy(table[count].name, &argv[i][1], STR_SIZE-1);
          table[count].name[STR_SIZE-1] = '\0';
      } else {		/* value	*/
          strncpy(table[count].value, argv[i], STR_SIZE-1);
          table[count].value[STR_SIZE-1] = '\0';
          count++;
      }
  }
  return count;
}
/* append the table onto a file	*/
void dump_str_pairs(str_pair *table, int size, char *file, char *prefix)
{
  int i; 
  char str[STR_SIZE];
  FILE *fp = fopen (file, "w");
  if (!fp) {
      sprintf (str,"error: %s could not be opened for writing\n", file);
      fatal(str);
  }
  for(i=0; i < size; i++)
    fprintf(fp, "%s%s\t%s\n", prefix, table[i].name, table[i].value);
  fclose(fp);	
}
/* table lookup	for a name */
int get_str_index(str_pair *table, int size, char *str)
{
  int i;
  if (!table)
    fatal("null pointer in get_str_index\n");
  for (i = 0; i < size; i++) 
    if (!strcasecmp(str, table[i].name)) 
      return i;
  return -1;
}
/* delete entry at 'at'	*/
void delete_entry(str_pair *table, int size, int at)
{
  int i;
  /* 
   * overwrite this entry using the next and 
   * shift all later entries once
   */
  for (i=at+1; i < size; i++) {
      strcpy(table[i-1].name, table[i].name);
      strcpy(table[i-1].value, table[i].value);
  }
}
/* 
 * remove duplicate names in the table - the entries later 
 * in the table are discarded. returns the new size of the
 * table
 */
int str_pairs_remove_duplicates(str_pair *table, int size)
{
  int i, j;
  for(i=0; i < size-1; i++)
    for(j=i+1; j < size; j++)
      if (!strcasecmp(table[i].name, table[j].name)) {
          delete_entry(table, size, j);
          size--;
          j--;
      }
  return size;
}
/* debug	*/
void print_str_pairs(str_pair *table, int size)
{
  int i;
  fprintf(stdout, "printing string table\n");
  for (i=0; i < size; i++)
    fprintf(stdout, "%s\t%s\n", table[i].name, table[i].value);
}
/* 
 * binary search a sorted double array 'arr' of size 'n'. if found,
 * the 'loc' pointer has the address of 'ele' and the return 
 * value is TRUE. otherwise, the return value is FALSE and 'loc' 
 * points to the 'should have been' location
 */
int bsearch_double(double *arr, int n, double ele, double **loc)
{
  if(n < 0)
    fatal("wrong index in binary search\n");
  if(n == 0) {
      *loc = arr;
      return FALSE;
  }
  if(eq(arr[n/2], ele)) {
      *loc = &arr[n/2];
      return TRUE;
  } else if (arr[n/2] < ele) {
      return bsearch_double(&arr[n/2+1], (n-1)/2, ele, loc);
  } else
    return bsearch_double(arr, n/2, ele, loc);
}
/* 
 * binary search and insert an element into a partially sorted
 * double array if not already present. returns FALSE if present
 */
int bsearch_insert_double(double *arr, int n, double ele)
{
  double *loc;
  int i;
  /* element found - nothing more left to do	*/
  if (bsearch_double(arr, n, ele, &loc))
    return FALSE;
  else {
      for(i=n-1; i >= (loc-arr); i--)
        arr[i+1] = arr[i];
      arr[loc-arr] = ele;	
  }
  return TRUE;
}
int full_search_int(int *arr, int size, int ele)
{
  int i;
  int idx;
  idx = -1;
  for(i=0; i<size; i++){
      if(arr[i] == ele){
          idx = i;
          break;
      }
  }
  return idx;
}
/* 
 * population count of an 8-bit integer - using pointers from 
 * http://aggregate.org/MAGIC/
 */
unsigned int ones8(register unsigned char n)
{
  /* group the bits in two and compute the no. of 1's within a group
   * this works because 00->00, 01->01, 10->01, 11->10 or 
   * n = n - (n >> 1). the 0x55 masking prevents bits flowing across
   * group boundary
   */
  n -= ((n >> 1) & 0x55);
  /* add the 2-bit sums into nibbles */
  n = ((n & 0x33) + ((n >> 2) & 0x33));
  /* add both the nibbles */
  n = ((n + (n >> 4)) & 0x0F);
  return n;
}
/* 
 * find the number of non-empty, non-comment lines
 * in a file open for reading
 */
int count_significant_lines(FILE *fp)
{
  char str[LINE_SIZE], *ptr;
  int count = 0;
  fseek(fp, 0, SEEK_SET);
  while(!feof(fp)) {
      fgets(str, LINE_SIZE, fp);
      if (feof(fp))
        break;
      /* ignore comments and empty lines	*/
      ptr = strtok(str, " \r\t\n");
      if (!ptr || ptr[0] == '#')
        continue;
      count++;
  }
  return count;
}
/* if even, return 1, odd 0 */
int even_or_odd(int x)
{
  return ((int) (x+1)/2 == (int) (x/2));
}
void print_time()
{
  //time
  char buffer[30];
  struct timeval tv;
  time_t curtime;
  gettimeofday(&tv, NULL);
  curtime=tv.tv_sec;
  strftime(buffer,30,"%m-%d-%Y  %T.",localtime(&curtime));
  printf("%s\n", buffer);
}
/* Multiply CSC matrix A with vector rhs, store results in rhs */
void SparseMatrix_mul_Vector(SuperMatrix *A, double *rhs)
{
  NCformat *Astore;
  double *result;
  int i, j, row_index;
  int m, n;
  double *a;
  int *asub, *xa;
  m = A->nrow;
  n = A->ncol;
  Astore = A->Store;
  a = Astore->nzval;
  asub = Astore->rowind;
  xa = Astore->colptr;
  if ( !(result = (double *) calloc(m, sizeof(double))) ) 
    fatal("Malloc fails for result[].\n");
  for(i=0; i<m; i++)
    result[i] = 0;
  for(i=0; i<n; i++){
      j = xa[i];
      while(j<xa[i+1]){
          row_index = asub[j];
          result[row_index] += a[j] * rhs[i];
          j++;
      }
  }
  copy_dvector(rhs, result, m);
  free(result);
}
// A = A + mul * B
// A and B should have same structure.
void SparseMatrix_add(SuperMatrix *A, SuperMatrix *B, int mul)
{
  NCformat *Astore, *Bstore;
  int i;
  int ma, na, nnza;
  int mb, nb, nnzb;
  double *a, *b;
  int *asub, *xa;
  int *bsub, *xb;
  ma = A->nrow; na = A->ncol;
  mb = B->nrow; nb = B->ncol;
  Astore = A->Store;
  Bstore = B->Store;
  nnza = Astore->nnz;
  nnzb = Bstore->nnz;
  a = Astore->nzval;
  asub = Astore->rowind;
  xa = Astore->colptr;
  b = Bstore->nzval;
  bsub = Bstore->rowind;
  xb = Bstore->colptr;
  if((nnza != nnzb) || 
     (ma != mb) || (na != nb)){
      fatal("Adding matrices with different strucutres in SparseMatrix_add!\n");
  }
  for(i=0; i<nnza; i++)
    if(asub[i] != bsub[i]){
        printf("%d\n", i);
        fatal("Adding matrices with different strucutres in SparseMatrix_add!\n");
    }
  for(i=0; i<na+1; i++)
    if(xa[i] != xb[i]){
        printf("%d\n", i);
        fatal("Adding matrices with different strucutres in SparseMatrix_add!\n");
    }
  for(i=0; i<nnza; i++)
    a[i] += (mul * b[i]);
}
// V1 = V1+V2
void Vector_add_Vector(int m, double *v1, double *v2)
{
  int i; 
  for(i=0; i<m; i++){
      v1[i] += v2[i];
  }
}
// Matrix dump dianonal
void SparseMatrix_dump_diag(SuperMatrix *A)
{
  NCformat *Astore;
  int i, j;
  int n;
  double *a;
  int *asub, *xa;
  int flag = 1;
  n = A->ncol;
  Astore = A->Store;
  a = Astore->nzval;
  asub = Astore->rowind;
  xa = Astore->colptr;
  for(i=0; i<n; i++){
      flag = 1;
      j = xa[i];
      while(j<xa[i+1]){
          if(asub[j] == i){
              printf("%e\n", a[j]);
              flag = 0;
          }
          j++;
      }
      if(flag)
        fatal("Matrix missing diagonal element! Cannot support that yet\n");
  }
}
// Matrix + mul*Iden
void SparseMatrix_add_Iden(SuperMatrix *A, int mul)
{
  NCformat *Astore;
  int i, j;
  int n;
  double *a;
  int *asub, *xa;
  int flag = 1;
  n = A->ncol;
  Astore = A->Store;
  a = Astore->nzval;
  asub = Astore->rowind;
  xa = Astore->colptr;
  for(i=0; i<n; i++){
      flag = 1;
      j = xa[i];
      while(j<xa[i+1]){
          if(asub[j] == i){
              a[j] += 1*mul;
              flag = 0;
          }
          j++;
      }
      if(flag)
        fatal("Matrix missing diagonal element! Cannot support that yet\n");
  }
}
void SparseMatrix_mul_SingleNum(SuperMatrix *A, double num)
{
  NCformat *Astore;
  int i;
  int nnz;
  double *a;
  Astore = A->Store;
  nnz = Astore->nnz;
  a = Astore->nzval;
  for(i=0; i<nnz; i++){
      a[i] *= num;
  }
}
void Print_CompCol_Matrix_detail(char *what, SuperMatrix *A)
{
  NCformat     *Astore;
  register int i,n;
  double       *dp;
  printf("\nCompCol matrix %s:\n", what);
  printf("Stype %d, Dtype %d, Mtype %d\n", A->Stype,A->Dtype,A->Mtype);
  n = A->ncol;
  Astore = (NCformat *) A->Store;
  dp = (double *) Astore->nzval;
  printf("nrow %d, ncol %d, nnz %d\n", A->nrow,A->ncol,Astore->nnz);
  printf("nzval: ");
  for (i = 0; i < Astore->colptr[n]; ++i) printf("%18.20e  ", dp[i]);
  printf("\nrowind: ");
  for (i = 0; i < Astore->colptr[n]; ++i) printf("%d  ", Astore->rowind[i]);
  printf("\ncolptr: ");
  for (i = 0; i <= n; ++i) printf("%d  ", Astore->colptr[i]);
  printf("\n");
  fflush(stdout);
}
/* Ke's code: Coo2CSC */
struct coo_elem
{
  int x;
  int y;
  double val;
};
int c2c_cmp( const void *a , const void *b ) 
{  
  struct coo_elem *c = (struct coo_elem *)a;
  struct coo_elem *d = (struct coo_elem *)b;
  if(c->y != d->y) return c->y - d->y;
  else return c->x - d->x;
}  
int coo2csc(int size, int nnz, 
            int *cooX, int *cooY, double *cooV,  // input COO array
            int *cscRowInd, int *cscColPtr, double *cscV) //output CSC array
{
  int i, j;
  int prev_x, prev_y;
  // Init struct array
  struct coo_elem *cooArray;
  cooArray = (struct coo_elem *) calloc (nnz, sizeof(struct coo_elem));
  // Copy in
  for (i =0; i <nnz; i++) {
      cooArray[i].x = cooX[i];
      cooArray[i].y = cooY[i];
      cooArray[i].val = cooV[i];
  }
  // Sort in col major 
  qsort(cooArray, nnz, sizeof(cooArray[0]), c2c_cmp);
  // Copy out, check duplicate
  j = -1;
  prev_x = -1;
  prev_y = -1;
  for (i =0; i <nnz; i++) {
      cscRowInd[i]=cooArray[i].x;
      cscV[i]=cooArray[i].val;
      while(j<cooArray[i].y){
          j++;
          cscColPtr[j]=i;
      }
      if((cooArray[i].x == prev_x) &&
         (cooArray[i].y == prev_y))
        printf("Warning: Duplicate elements in Matrix!\n");
      prev_x = cooArray[i].x;
      prev_y = cooArray[i].y;
  }  
  cscColPtr[j+1]=i;  
  free(cooArray);
  return 1;
}
void int_to_str(int input, int width, char *strOut)
{
  int i;
  char name[STR_SIZE];
  char tmp[STR_SIZE];
  int  length = 0;
  int  test = input;
  while(test>0){
      test /= 10;
      length++;
  }
  if(length > width)
    fatal("In function int_to_str, input is too wide alaready\n");
  if(input)
    sprintf(name,"%d", input);
  else
    sprintf(name,"");
  for(i=0; i<(width-length); i++){
      sprintf(tmp,"%d%s", 0, name);
      strncpy(name, tmp, STR_SIZE);
  }
  strncpy(strOut, name, STR_SIZE);
}
</document_content>
</document>
<document index="35">
<source>util.h</source>
<document_content>
#ifndef __UTIL_H
#define __UTIL_H
#include <stdio.h>
#include "slu_ddefs.h"
#define MAX(x,y)		(((x)>(y))?(x):(y))
#define MIN(x,y)		(((x)<(y))?(x):(y))
#define MAX3(a,b,c)		MAX(MAX(a,b),c)
#define MIN3(a,b,c)		MIN(MIN(a,b),c)
#define MID3(a,b,c)		((MIN(a,b)<(c))?(MIN(MAX(a,b),c)):(MAX(MIN(a,b),c)))
#define MAX4(a,b,c,d)	MAX(MAX(MAX(a,b),c),d)
#define MIN4(a,b,c,d)	MIN(MIN(MIN(a,b),c),d)
#define DELTA			1.0e-6
#define LARGENUM		1.0e100
#define LARGEINT		99999999
#define NULLFILE		"(null)"
#define VAPER		    1.256637e-6
#define PI	3.1416
#define TRUE	  		1
#define	FALSE	  		0
#define MAXIMUM			1
#define	MINIMUM			0
#define RAND_SEED		1500450271
#define SEED_UPPER	1000000000
#define SEED_LOWER	100000000
#define STR_SIZE		512
#define LINE_SIZE		65536
#define MAX_ENTRIES		512
int eq(double x, double y);
int le(double x, double y);
int ge(double x, double y);
void fatal (char *s);
void warning (char *s);
void swap_ival (int *a, int *b);
void swap_dval (double *a, double *b);
int tolerant_ceil(double val);
int tolerant_floor(double val);
/* vector routines	*/
double 	*dvector(int n);
void free_dvector(double *v);
void dump_dvector(double *v, int n);
void copy_dvector (double *dst, double *src, int n);
void zero_dvector (double *v, int n);
void abs_dvector (double *v, int n);
void negL_dvector (double *v, int n);
double **dvector_2D(int n, int d);
void free_dvector_2D(double **v, int d);
int *ivector(int n);
void free_ivector(int *v);
void dump_ivector(int *v, int n);
void copy_ivector (int *dst, int *src, int n);
void zero_ivector (int *v, int n);
void abs_ivector (int *v, int n);
int **ivector_2D(int n, int d);
void free_ivector_2D(int **v, int d);
/* matrix routines - Thanks to Greg Link
 * from Penn State University for the 
 * memory allocators/deallocators
 */
double **dmatrix(int nr, int nc);
void free_dmatrix(double **m);
void dump_dmatrix(double **m, int nr, int nc);
void dump_dmatrix_file(double **m, int nr, int nc, char *file);
void dump_dmatrix_skip0_file(double **m, int nr, int nc, char *file);
void copy_dmatrix(double **dst, double **src, int nr, int nc);
void zero_dmatrix(double **m, int nr, int nc);
void resize_dmatrix(double **m, int nr, int nc);
/* mirror the lower triangle to make 'm' fully symmetric	*/
void mirror_dmatrix(double **m, int n);
int **imatrix(int nr, int nc);
void free_imatrix(int **m);
void dump_imatrix(int **m, int nr, int nc);
void dump_imatrix_file(int **m, int nr, int nc, char *file);
void dump_imatrix_skip0_file(int **m, int nr, int nc, char *file);
void copy_imatrix(int **dst, int **src, int nr, int nc);
void resize_imatrix(int **m, int nr, int nc);
int  sum_imatrix(int **m, int nr, int nc);
/* Matrix analysis*/
double sum_dmatrix(double **m, int nr, int nc);
double ave_dmatrix(double **m, int nr, int nc);
double max_dmatrix(double **m, int nr, int nc);
double max_dmatrix_pos(double **m, int nr, int nc, int* i, int *j);
double min_dmatrix(double **m, int nr, int nc);
double min_dmatrix_pos(double **m, int nr, int nc, int* i, int *j);
double var_dmatrix(double **m, int nr, int nc, double ave);
int    above_threshold_dmatrix(double **m, int nr, int nc, double th);
/* skip0 only deals with non-zero values */
double ave_dmatrix_skip0(double **m, int nr, int nc);
double max_dmatrix_skip0(double **m, int nr, int nc);
double min_dmatrix_skip0(double **m, int nr, int nc);
double var_dmatrix_skip0(double **m, int nr, int nc, double ave);
/* vector analysis*/
double sum_dvector(double *m, int n);
double ave_dvector(double *m, int n);
double max_dvector(double *m, int n);
double min_dvector(double *m, int n);
double var_dvector(double *m, int n, double ave);
double max_dvector_skip0(double *m, int n);
int    above_threshold_dvector(double *m, int n, double th);
/* vector operation */
void add_dvector(double *dst, double *rs1, double *rs2, int len); // dst = rs1+rs2
void sub_dvector(double *dst, double *rs1, double *rs2, int len); // dst = rs1-rs2
void mul_val_dvector(double *m, double val, int len); // m = m*val
void sin_dvector(double *dst, double *amp, double time, double freq, int len); // dst = amp*sin(2*pi*f*t)
/* routines for 3-d matrix with tail	*/
/* allocate 3-d matrix with 'nr' rows, 'nc' cols, 
 * 'nl' layers	and a tail of 'xtra' elements 
 */
double ***dcuboid_tail(int nr, int nc, int nl, int xtra);
/* destructor	*/
void free_dcuboid(double ***m);
/* initialize random number generator	*/
void init_rand(void);
/* random number within the range [0, max-1]	*/
int rand_upto(int max);
/* random number in the range [0, 1)	*/
double rand_fraction(void);
/* a table of name value pairs	*/
typedef struct str_pair_st
{
	char name[STR_SIZE];
	char value[STR_SIZE];
}str_pair;
/* 
 * reads tab-separated name-value pairs from file into
 * a table of size max_entries and returns the number 
 * of entries read successfully
 */
int read_str_pairs(str_pair *table, int max_entries, char *file);
/* same as above but from command line instead of a file	*/
int parse_cmdline(str_pair *table, int max_entries, int argc, char **argv);
/* append the table onto a file	*/
void dump_str_pairs(str_pair *table, int size, char *file, char *prefix);
/* table lookup	for a name */
int get_str_index(str_pair *table, int size, char *str);
/* 
 * remove duplicate names in the table - the entries later 
 * in the table are discarded. returns the new size of the
 * table
 */
int str_pairs_remove_duplicates(str_pair *table, int size);
/* 
 * binary search a sorted double array 'arr' of size 'n'. if found,
 * the 'loc' pointer has the address of 'ele' and the return 
 * value is TRUE. otherwise, the return value is FALSE and 'loc' 
 * points to the 'should have been' location
 */
int bsearch_double(double *arr, int n, double ele, double **loc);
/* 
 * binary search and insert an element into a partially sorted
 * double array if not already present. returns FALSE if present
 */
int bsearch_insert_double(double *arr, int n, double ele);
/* 
 * Full search an arbitary array, if found, return index
 * return -1 if not found
 */
int full_search_int(int *arr, int size, int ele);
/* 
 * population count of an 8-bit integer - using pointers from 
 * http://aggregate.org/MAGIC/
 */
unsigned int ones8(register unsigned char n);
/* 
 * find the number of non-empty, non-comment lines
 * in a file open for reading
 */
int count_significant_lines(FILE *fp);
/* if even, return 1, odd 0 */
int even_or_odd(int x);
void print_time();
void int_to_str(int input, int width, char *strOut);
/* Sparse Matrix operations */
void SparseMatrix_mul_Vector(SuperMatrix *A, double *rhs);
void Vector_add_Vector(int m, double *v1, double *v2);
void SparseMatrix_add_Iden(SuperMatrix *A, int mul);
void SparseMatrix_dump_diag(SuperMatrix *A);
void SparseMatrix_mul_SingleNum(SuperMatrix *A, double num);
void SparseMatrix_add(SuperMatrix *A, SuperMatrix *B, int mul);
void Print_CompCol_Matrix_detail(char *what, SuperMatrix *A);
int coo2csc(int size, int nnz, 
            int *cooX, int *cooY, double *cooV,
            int *cscRowInd, int *cscColPtr, double *cscV);
int c2c_cmp( const void *a , const void *b);
#endif
</document_content>
</document>
<document index="36">
<source>voltspot.c</source>
<document_content>
/* 
 * This is a trace-level thermal simulator. It reads power values 
 * from an input trace file and outputs the corresponding instantaneous 
 * voltage values to an output trace file. It also outputs the steady 
 * state voltage/current values to designated files.
 */
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include "PDN_sim.h"
#include "PDN_analyze.h"
#include "flp.h"
#include "util.h"
#include "voltspot.h"
/* Lib for SuperLU */
#include "slu_ddefs.h"
void usage(int argc, char **argv)
{
  fprintf(stdout, "Usage: %s -f <file> -p <file> [-c <file>] [options]\n", argv[0]);
  fprintf(stdout, "Options:(may be specified in any order, within \"[]\" means optional)\n");
  fprintf(stdout, "   -f <file>\tfloorplan input file (e.g. example.flp) - overridden by the\n");
  fprintf(stdout, "            \tlayer configuration file (e.g. 3D.lcf) when the\n");
  fprintf(stdout, "            \tlatter is specified\n");
  fprintf(stdout, "   -p <file>\tpower trace input file (e.g. example.ptrace)\n");
  fprintf(stdout, "  [-c <file>]\tinput configuration parameters from file (e.g. pdn.config)\n");
  fprintf(stdout, "  [-v <file>]\ttransient PDN output file - will skip transient simulation\n");
  fprintf(stdout, "            \tif not provided\n");
  fprintf(stdout, "  [options]\tzero or more options of the form \"-<name> <value>\",\n");
  fprintf(stdout, "           \toverride the options from config file.\n");
}
/* 
 * parse a table of name-value string pairs and add the configuration
 * parameters to 'config'
 */
void global_config_from_strs(global_config_t *config, str_pair *table, int size)
{
  int idx;
  if((idx = get_str_index(table, size, "f")) >= 0) {
      if(sscanf(table[idx].value, "%s", config->flp_file) != 1)
        fatal("invalid format for configuration  parameter flp_file\n");
  } else {
      fatal("required parameter flp_file missing. check usage\n");
  }
  if((idx = get_str_index(table, size, "p")) >= 0) {
      if(sscanf(table[idx].value, "%s", config->p_infile) != 1)
        fatal("invalid format for configuration  parameter p_infile\n");
  } else {
      fatal("required parameter p_infile missing. check usage\n");
  }
  if((idx = get_str_index(table, size, "c")) >= 0) {
      if(sscanf(table[idx].value, "%s", config->config) != 1)
        fatal("invalid format for configuration  parameter config\n");
  } else {
      strcpy(config->config, NULLFILE);
  }
  if((idx = get_str_index(table, size, "d")) >= 0) {
      if(sscanf(table[idx].value, "%s", config->dump_config) != 1)
        fatal("invalid format for configuration  parameter dump_config\n");
  } else {
      strcpy(config->dump_config, NULLFILE);
  }
  if((idx = get_str_index(table, size, "v")) >= 0) {
      if(sscanf(table[idx].value, "%s", config->v_outfile) != 1)
        fatal("invalid format for configuration  parameter v_outfile\n");
  } else {
      strcpy(config->v_outfile, NULLFILE);
  }
}
/* 
 * read a single line of trace file containing names
 * of functional blocks
 */
int read_names(FILE *fp, char **names)
{
  char line[LINE_SIZE], temp[LINE_SIZE], *src;
  int i;
  /* skip empty lines	*/
  do {
      /* read the entire line	*/
      fgets(line, LINE_SIZE, fp);
      if(feof(fp))
        fatal("not enough names in trace file\n");
      strcpy(temp, line);
      src = strtok(temp, " \r\t\n");
  } while (!src);
  /* new line not read yet	*/	
  if(line[strlen(line)-1] != '\n')
    fatal("line too long\n");
  /* chop the names from the line read	*/
  for(i=0,src=line; *src && i < MAX_UNITS; i++) {
      if(!sscanf(src, "%s", names[i]))
        fatal("invalid format of names\n");
      src += strlen(names[i]);
      while (isspace((int)*src))
        src++;
  }
  if(*src && i == MAX_UNITS)
    fatal("no. of units exceeded limit\n");
  return i;
}
/* read a single line of power trace numbers	*/
int read_vals(FILE *fp, double *vals)
{
  char line[LINE_SIZE], temp[LINE_SIZE], *src;
  int i;
  /* skip empty lines	*/
  do {
      /* read the entire line	*/
      fgets(line, LINE_SIZE, fp);
      if(feof(fp))
        return 0;
      strcpy(temp, line);
      src = strtok(temp, " \r\t\n");
  } while (!src);
  /* new line not read yet	*/	
  if(line[strlen(line)-1] != '\n')
    fatal("line too long\n");
  /* chop the power values from the line read	*/
  for(i=0,src=line; *src && i < MAX_UNITS; i++) {
      if(!sscanf(src, "%s", temp) || !sscanf(src, "%lf", &vals[i]))
        fatal("invalid format of values\n");
      src += strlen(temp);
      while (isspace((int)*src))
        src++;
  }
  if(*src && i == MAX_UNITS)
    fatal("no. of entries exceeded limit\n");
  return i;
}
int compare_names(char **n1, char **n2, int size)
{
  int i;
  int flag = 0;
  for(i=0; i < size-1; i++)
    if(strcmp(n1[i], n2[i])){
        flag = 1;
        break;
    }
  return flag;
}
char **alloc_names(int nr, int nc)
{
  int i;
  char **m;
  m = (char **) calloc (nr, sizeof(char *));
  assert(m != NULL);
  m[0] = (char *) calloc (nr * nc, sizeof(char));
  assert(m[0] != NULL);
  for (i = 1; i < nr; i++)
    m[i] =  m[0] + nc * i;
  return m;
}
void free_names(char **m)
{
  free(m[0]);
  free(m);
}
int main(int argc, char **argv)
{
  int i, j, m, idx, base = 0, count = 0, n = 0;
  int num, size, lines = 0;
  int do_transient = TRUE;
  int intv, trans_intvl, switch_intvl;
  int warmup_steps;
  char **names; double *vals;
  /* trace file pointers	*/
  FILE *pin; 
  FILE *vout = NULL;
  /* floorplan	*/
  PDN_flp_t *flp;
  /* PDN model */
  model_t *model;
  status_t *status;
  /* instantaneous power values	*/
  double *power;
  double *cur_power, *delta_power;
  double total_power = 0.0;
  /* steady state power values	*/
  double *overall_power;
  /* PDN model configuration parameters	*/
  PDN_config_t config;
  /* global configuration parameters	*/
  global_config_t global_config;
  /* table to hold options and configuration */
  str_pair table[MAX_ENTRIES];
  /* SLU Matrix for Transient Solving */
  SuperMatrix A, L, U;
  int         *perm_r; /* row permutations from partial pivoting */
  int         *perm_c; /* column permutation vector */
  if(!(argc >= 6 && argc % 2)) {
      usage(argc, argv);
      return 1;
  }
  size = parse_cmdline(table, MAX_ENTRIES, argc, argv);
  global_config_from_strs(&global_config, table, size);
  /* no PDN transient simulation, only steady state	*/
  if(!strcmp(global_config.v_outfile, NULLFILE))
    do_transient = FALSE;
  /* read configuration file	*/
  if(strcmp(global_config.config, NULLFILE))
    size += read_str_pairs(&table[size], MAX_ENTRIES, global_config.config);
  /* 
   * earlier entries override later ones. so, command line options 
   * have priority over config file 
   */
  size = str_pairs_remove_duplicates(table, size);
  /* get defaults PDN config*/
  config = default_PDN_config();
  /* modify according to command line / config file	*/
  PDN_config_add_from_strs(&config, table, size);
  /* initialization: the flp_file global configuration 
   * parameter is overridden by the layer configuration 
   * file in the layer_file_3D when the latter is specified.
   */
  flp = PDN_read_flp(global_config.flp_file);
  /* Manually set domain for PDN */
  if(config.PDN_multi_dom)
    set_flp_domain(flp, &config);
  /* Simulation mode checking */
  int is_3D = FALSE;
  if(strcmp(config.layer_file_3D, NULLFILE))
    is_3D = TRUE;
  if((!is_3D) && config.v_stacking)
    fatal("Please turn on 3D if you want to do voltage stacking.\n");
  if(do_transient){
      if(1 == config.run_PDN){
          fatal("We do not allow running transient simulation along with\
                steady state simulation.\n");
      }
      else if(2 == config.run_PDN){
          fatal("Running transient simulation and per-line steady state simulation together \
                does not make much sense. Modify voltspot.c to override this interruption.\n");
      }
  }
  if(config.PDN_multi_dom && config.v_stacking)
    fatal("Multi_dom and v_stacking do not work together yet.\n");
  /* allocate and initialize the R model for PDN	*/
  model = alloc_model(&config, flp);
  populate_C4_PDN(model);
  if(is_3D)
    populate_TSV_PDN(model);
  if(config.v_stacking)
    populate_IVR(model);
  populate_R_model_PDN(model);
  if(do_transient){
      populate_LC_model_PDN(model);
      m = PDN_trans_matrix_dim(model);
      model->trans_matrix_dim = m;
      model->last_trans = dvector(m);
      if(!is_3D){
          if( !(perm_r = (int *) calloc(m, sizeof(int))) ) fatal("Malloc fails for perm_r[].\n");
          if( !(perm_c = (int *) calloc(m, sizeof(int))) ) fatal("Malloc fails for perm_c[].\n");
      }
  }
  status = alloc_status(model);
  populate_status(model, status);
  /* n is the sum total of the number of functional blocks
   * of all the floorplans */
  n = model->total_n_blocks;
  /* allocate the power arrays	*/
  power = dvector(n);
  /* For trans PDN step input elimination */
  cur_power = dvector(n);
  delta_power = dvector(n);
  overall_power = dvector(n);
  if(!(pin = fopen(global_config.p_infile, "r")))
    fatal("unable to open power trace input file\n");
  if(do_transient && !(vout = fopen(global_config.v_outfile, "w")))
    fatal("unable to open PDN trace file for output\n");
  /* names of functional units	*/
  names = alloc_names(MAX_UNITS, STR_SIZE);
  if(read_names(pin, names) != n)
    fatal("no. of units in floorplan and trace file differ\n");
  vals = dvector(MAX_UNITS);
  /* Initialize Matrix, power trace*/
  if(do_transient){
      status->trans_counter = 0;
      status->draw_counter = 0;
      /* Zero power before the first line */
      zero_dvector(cur_power, n);
      /* Create J matrix, LU decomposition */
      if(!is_3D){
          if(model->config.PDN_gridL){
              trans_SLU_init(model, cur_power, &A, &L, &U, perm_c, perm_r);
          }
          else{
              trans_SLU_init_nogridL(model, cur_power, &A, &L, &U, perm_c, perm_r);
          }
      }
      /* Init vector  */
      PDN_init_trans_vector(model, model->last_trans);
      if(model->config.PDN_sin_pattern)
        trans_intvl = model->config.PDN_sin_totstep;
      else
        trans_intvl = model->config.ptrace_sampling_intvl * model->config.PDN_step_percycle;
      warmup_steps = model->config.PDN_ptrace_warmup * trans_intvl;
      if(model->config.v_stacking){
          double Fsw_ratio = model->config.proc_clock_freq*model->config.PDN_step_percycle/model->sc_converter->freq;
          if(fabs(floor(Fsw_ratio+0.5)-Fsw_ratio) < DELTA)
            switch_intvl = (int) Fsw_ratio;
          else
            fatal("Please use an integer ratio between SC converters switching T and solver timestep!\n");
      }
      else{
          switch_intvl = 0;
      }
      dump_PDN_config(model, vout);
      print_trans_header(model, status, vout);
  }
  /* read the instantaneous power trace	*/
  while ((num=read_vals(pin, vals)) != 0) {
      if(num != n){
          fatal("invalid trace file format\n");
      }
      /* permute the power numbers according to the floorplan order	*/
      for(i=0, base=0, count=0; i<model->n_layers; i++) {
          for(j=0; j<model->layers[i].flp->n_units; j++) {
              idx = PDN_get_blk_index(model->layers[i].flp, names[count+j]);
              power[base+idx] = vals[count+j];
          }
          count += model->layers[i].flp->n_units;
          base += model->layers[i].flp->n_units;	
      }
      /* compute PDN voltage */
      if(do_transient){
          if(is_3D){
              if(model->config.PDN_sin_pattern){
                  for(intv=0; intv<trans_intvl; intv++){
                      status->trans_counter++;
                      sin_dvector(cur_power, power, 
                                  intv/(model->config.proc_clock_freq*model->config.PDN_step_percycle), 
                                  model->config.PDN_sin_freq, n);
                      trans_matrix_build_3D(model, cur_power, &A, &L, &U, &perm_c, &perm_r);
                      compute_PDN_SLU(model, cur_power, &A, &L, &U, perm_c, perm_r);
                      if(model->config.v_stacking)
                        switch_SCconverters(model, status->trans_counter, switch_intvl);
                      perstep_droop_3D(model, vout);
                      SUPERLU_FREE (perm_r);
                      SUPERLU_FREE (perm_c);
                      Destroy_CompCol_Matrix(&A);
                      Destroy_SuperNode_Matrix(&L);
                      Destroy_CompCol_Matrix(&U);
                  }
                  lines++;
                  break;
              }
              else{
                  trans_matrix_build_3D(model, power, &A, &L, &U, &perm_c, &perm_r);
                  for(intv=0; intv<trans_intvl; intv++){
                      status->trans_counter++;
                      compute_PDN_SLU(model, power, &A, &L, &U, perm_c, perm_r);
                      if(model->config.v_stacking)
                        switch_SCconverters(model, status->trans_counter, switch_intvl);
                      if(status->trans_counter > warmup_steps){ // ignore warm up
                          PDN_trans_analyze(model, status);
                          if(!(status->trans_counter % model->config.PDN_step_percycle))
                            print_trans_analyze(model, status, vout);
                      }
                  }
                  SUPERLU_FREE (perm_r);
                  SUPERLU_FREE (perm_c);
                  Destroy_CompCol_Matrix(&A);
                  Destroy_SuperNode_Matrix(&L);
                  Destroy_CompCol_Matrix(&U);
              }
          }
          else{
              if(model->config.PDN_sin_pattern){
                  for(intv=0; intv<trans_intvl; intv++){
                      sin_dvector(cur_power, power, 
                                  intv/(model->config.proc_clock_freq*model->config.PDN_step_percycle), 
                                  model->config.PDN_sin_freq, n);
                      compute_PDN_SLU(model, cur_power, &A, &L, &U, perm_c, perm_r);
                      print_step_singlenode(model, vout, 0, 0);
                  }
                  lines++;
                  break;
              }
              else{
                  sub_dvector(delta_power, power, cur_power, n);
                  mul_val_dvector(delta_power, ((double)1/trans_intvl), n);
                  for(intv=0; intv<trans_intvl; intv++){
                      status->trans_counter++;
                      add_dvector(cur_power, cur_power, delta_power, n);
                      compute_PDN_SLU(model, cur_power, &A, &L, &U, perm_c, perm_r);
                      if(status->trans_counter > warmup_steps){ // ignore warm up
                          PDN_trans_analyze(model, status);
                          if(!(status->trans_counter % model->config.PDN_step_percycle))
                            print_trans_analyze(model, status, vout);
                      }
                  }
              }
          }
          printf("Done with ptrace line %d\n", lines+1);
      }
      /* per-line steady state */
      if(2 == model->config.run_PDN){
          steady_state_PDN(model, power);
          PDN_steady_analyze(model, status);
          if(model->config.animation){
              draw_single_gif(model, status, status->draw_counter, STEADY);
              status->draw_counter++;
          }
          printf("Done with ptrace line %d\n", lines+1);
      }
      /* for computing average	*/
      for(i=0, base=0; i<model->n_layers; i++) {
          for(j=0; j<model->layers[i].flp->n_units; j++)
            overall_power[base+j] += power[base+j];
          base += model->layers[i].flp->n_units;	
      }
      lines++;
  }
  if(!lines)
    fatal("no power numbers in trace file\n");
  int tot_cycles;
  if(do_transient){
      /* Mark end in vtrace */
      fprintf(vout, "#END\n");
      // calculate per cycle average gridnode noise
      tot_cycles = (lines - model->config.PDN_ptrace_warmup) * model->config.ptrace_sampling_intvl;
      mul_val_dvector(status->gridstats.integral_2D[0], ((double)1/tot_cycles), model->rows*model->cols);
      dump_files(model, status, TRANSIENT);
  }
  if(2 == model->config.run_PDN){
      dump_files(model, status, STEADY);
  }
  if(model->config.animation)
    create_animation(status->draw_counter, model->config.animation);
  /* for computing average	*/
  for(i=0, base=0; i<model->n_layers; i++) {
      for(j=0; j<model->layers[i].flp->n_units; j++) {
          overall_power[base+j] /= lines;
          total_power += overall_power[base+j];
      }
      base += model->layers[i].flp->n_units;	
  }
  if(1 == model->config.run_PDN){
      /* steady state PDN */
      steady_state_PDN(model, overall_power);
      /* analyze and print PDN status */
      PDN_steady_analyze(model, status);
      print_steady_analyze(model, status);
      dump_files(model, status, STEADY);
  }
  /* cleanup	*/
  fclose(pin);
  PDN_free_flp(flp);
  free_dvector(power);
  free_dvector(cur_power);
  free_dvector(delta_power);
  free_dvector(overall_power);
  free_names(names);
  free_dvector(vals);
  if(do_transient && (!is_3D)){
      fclose(vout);
      SUPERLU_FREE (perm_r);
      SUPERLU_FREE (perm_c);
      Destroy_CompCol_Matrix(&A);
      Destroy_SuperNode_Matrix(&L);
      Destroy_CompCol_Matrix(&U);
  }
  free_status(model, status);
  delete_model(model);
  return 0;
}
</document_content>
</document>
<document index="37">
<source>voltspot.h</source>
<document_content>
#ifndef __VOLTSPOT_H_
#define __VOLTSPOT_H_
#include "util.h"
/* global configuration parameters for HotSpot	*/
typedef struct global_config_t_st
{
	/* floorplan input file */
	char flp_file[STR_SIZE];
	/* input power trace file */
	char p_infile[STR_SIZE];
	/* output file for the voltage trace */
	char v_outfile[STR_SIZE];
	/* input configuration parameters from file	*/
	char config[STR_SIZE];
	/* output configuration parameters to file	*/
	char dump_config[STR_SIZE];
}global_config_t;
/* 
 * parse a table of name-value string pairs and add the configuration
 * parameters to 'config'
 */
void global_config_from_strs(global_config_t *config, str_pair *table, int size);
#endif
</document_content>
</document>
</documents>